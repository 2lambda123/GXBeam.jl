<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rotating Beam with a Swept Tip · GXBeam.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GXBeam.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../guide/">Getting Started</a></li><li><a class="tocitem" href="../section/">Computing Stiffness and Mass Matrices</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../cantilever/">Cantilever with a Uniform Load</a></li><li><a class="tocitem" href="../overdetermined/">Overdetermined Beam</a></li><li><a class="tocitem" href="../tipforce/">Cantilever with a Tip Force</a></li><li><a class="tocitem" href="../tipmoment/">Cantilever with a Tip Moment</a></li><li><a class="tocitem" href="../curved/">Bending of an Initially Curved Beam</a></li><li class="is-active"><a class="tocitem" href>Rotating Beam with a Swept Tip</a></li><li><a class="tocitem" href="../excited/">Excited Second Bending Mode</a></li><li><a class="tocitem" href="../wind-turbine-blade/">Time-Domain Simulation of a Wind Turbine Blade</a></li><li><a class="tocitem" href="../static-joined-wing/">Static Analysis of a Joined-Wing</a></li><li><a class="tocitem" href="../dynamic-joined-wing/">Time-Domain Simulation of a Joined-Wing</a></li><li><a class="tocitem" href="../vertical-axis-wind-turbine/">Sandia 34-Meter Vertical Axis Wind Turbine</a></li></ul></li><li><a class="tocitem" href="../diffeq/">Using GXBeam with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../reference/reference/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Rotating Beam with a Swept Tip</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rotating Beam with a Swept Tip</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/rotating.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="rotating"><a class="docs-heading-anchor" href="#rotating">Rotating Beam with a Swept Tip</a><a id="rotating-1"></a><a class="docs-heading-anchor-permalink" href="#rotating" title="Permalink"></a></h1><p>In this example we analyze a rotating beam with a swept tip.  The parameters for this example come from &quot;Finite element solution of nonlinear intrinsic equations for curved composite beams&quot; by Hodges, Shang, and Cesnik.</p><p><img src="../../assets/rotating-drawing.svg" alt/></p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This example is also available as a Jupyter notebook: <a href="https://nbviewer.jupyter.org/github/byuflowlab/GXBeam.jl/blob/gh-pages/dev/examples/rotating.ipynb"><code>rotating.ipynb</code></a>.</p></div></div><pre><code class="language-julia hljs">using GXBeam, LinearAlgebra

sweep = 45 * pi/180
rpm = 0:25:750

# straight section of the beam
L_b1 = 31.5 ## inch
r_b1 = [2.5, 0, 0]
nelem_b1 = 13
lengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)

# swept section of the beam
L_b2 = 6 ## inch
r_b2 = [34, 0, 0]
nelem_b2 = 3
cs, ss = cos(sweep), sin(sweep)
frame_b2 = [cs ss 0; -ss cs 0; 0 0 1]
lengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2;
    frame = frame_b2)

# combine elements and points into one array
nelem = nelem_b1 + nelem_b2
points = vcat(xp_b1, xp_b2[2:end])
start = 1:nelem_b1 + nelem_b2
stop = 2:nelem_b1 + nelem_b2 + 1
lengths = vcat(lengths_b1, lengths_b2)
midpoints = vcat(xm_b1, xm_b2)
Cab = vcat(Cab_b1, Cab_b2)

# cross section
w = 1 ## inch
h = 0.063 ## inch

# material properties
E = 1.06e7 ## lb/in^2
ν = 0.325
ρ = 2.51e-4 ## lb sec^2/in^4

# shear and torsion correction factors
ky = 1.2000001839588001
kz = 14.625127919304001
kt = 65.85255016982444

A = h*w
Iyy = w*h^3/12
Izz = w^3*h/12
J = Iyy + Izz

# apply corrections
Ay = A/ky
Az = A/kz
Jx = J/kt

G = E/(2*(1+ν))

compliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy),
    1/(E*Izz)]), nelem)

mass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)

# create assembly
assembly = Assembly(points, start, stop;
    compliance = compliance,
    mass = mass,
    frames = Cab,
    lengths = lengths,
    midpoints = midpoints)

# create dictionary of prescribed conditions
prescribed_conditions = Dict(
    # root section is fixed
    1 =&gt; PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)
    )

nonlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))
linear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))
for i = 1:length(rpm)
    # global frame rotation
    w0 = [0, 0, rpm[i]*(2*pi)/60]

    # perform nonlinear steady state analysis
    system, converged = steady_state_analysis(assembly,
        angular_velocity = w0,
        prescribed_conditions = prescribed_conditions)

    nonlinear_states[i] = AssemblyState(system, assembly;
        prescribed_conditions = prescribed_conditions)

    # perform linear steady state analysis
    system, converged = steady_state_analysis(assembly,
        angular_velocity = w0,
        prescribed_conditions = prescribed_conditions,
        linear = true)

    linear_states[i] = AssemblyState(system, assembly;
        prescribed_conditions = prescribed_conditions)
end</code></pre><p>To visualize the solutions we will plot the root moment and tip deflections against the angular speed.</p><pre><code class="language-julia hljs">using Plots
pyplot()
colors = get_color_palette(:auto, 17)</code></pre><pre><code class="language-julia hljs"># root moment
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    yticks = 0.0:2:12,
    ylabel = &quot;\$M_z\$ at the root (lb-in)&quot;,
    grid = false,
    overwrite_figure=false
    )
Mz_nl = [-nonlinear_states[i].points[1].M[3] for i = 1:length(rpm)]
Mz_l = [-linear_states[i].points[1].M[3] for i = 1:length(rpm)]
plot!(rpm, Mz_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, Mz_l, label=&quot;Linear&quot;)
plot!(show=true)</code></pre><p><img src="../../assets/rotating-Mz.svg" alt/></p><pre><code class="language-julia hljs"># x tip deflection
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    ylim = (-0.002, 0.074),
    yticks = 0.0:0.01:0.07,
    ylabel = &quot;\$u_x\$ at the tip (in)&quot;,
    grid = false,
    overwrite_figure=false
    )
ux_nl = [nonlinear_states[i].points[end].u[1] for i = 1:length(rpm)]
ux_l = [linear_states[i].points[end].u[1] for i = 1:length(rpm)]
plot!(rpm, ux_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, ux_l, label=&quot;Linear&quot;)
plot!(show=true)</code></pre><p><img src="../../assets/rotating-ux.svg" alt/></p><pre><code class="language-julia hljs"># y tip deflection
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    ylim = (-0.01, 0.27),
    yticks = 0.0:0.05:0.25,
    ylabel = &quot;\$u_y\$ at the tip (in)&quot;,
    grid = false,
    overwrite_figure=false
    )
uy_nl = [nonlinear_states[i].points[end].u[2] for i = 1:length(rpm)]
uy_l = [linear_states[i].points[end].u[2] for i = 1:length(rpm)]
plot!(rpm, uy_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, uy_l, label=&quot;Linear&quot;)
plot!(show=true)</code></pre><p><img src="../../assets/rotating-uy.svg" alt/></p><pre><code class="language-julia hljs"># rotation of the tip
plot(
    xlim = (0, 760),
    xticks = 0:100:750,
    xlabel = &quot;Angular Speed (RPM)&quot;,
    ylabel = &quot;\$θ_z\$ at the tip&quot;,
    grid = false,
    overwrite_figure=false
    )
theta_z_nl = [4*atan(nonlinear_states[i].points[end].theta[3]/4)
    for i = 1:length(rpm)]
theta_z_l = [4*atan(linear_states[i].points[end].theta[3]/4)
    for i = 1:length(rpm)]

plot!(rpm, theta_z_nl, label=&quot;Nonlinear&quot;)
plot!(rpm, theta_z_l, label=&quot;Linear&quot;)

plot!(show=true)</code></pre><p><img src="../../assets/rotating-theta_z.svg" alt/></p><p>We will now compute the eigenvalues of this system for a range of sweep angles and and angular speeds.</p><pre><code class="language-julia hljs">sweep = (0:2.5:45) * pi/180
rpm = [0, 500, 750]
nev = 30

λ = Matrix{Vector{ComplexF64}}(undef, length(sweep), length(rpm))
U = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))
V = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))
state = Matrix{AssemblyState{Float64}}(undef, length(sweep), length(rpm))
eigenstates = Matrix{Vector{AssemblyState{ComplexF64}}}(undef, length(sweep), length(rpm))

for i = 1:length(sweep)

    local L_b1, r_b1, nelem_b1, lengths_b1
    local xp_b1, xm_b1, Cab_b1
    local cs, ss
    local L_b2, r_b2, nelem_b2, frame_b2, lengths_b2
    local xp_b2, xm_b2, Cab_b2
    local nelem, points, start, stop
    local lengths, midpoints, Cab, compliance, mass, assembly

    # straight section of the beam
    L_b1 = 31.5 # inch
    r_b1 = [2.5, 0, 0]
    nelem_b1 = 20
    lengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)

    # swept section of the beam
    L_b2 = 6 # inch
    r_b2 = [34, 0, 0]
    nelem_b2 = 20
    cs, ss = cos(sweep[i]), sin(sweep[i])
    frame_b2 = [cs ss 0; -ss cs 0; 0 0 1]
    lengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2;
        frame = frame_b2)

    # combine elements and points into one array
    nelem = nelem_b1 + nelem_b2
    points = vcat(xp_b1, xp_b2[2:end])
    start = 1:nelem_b1 + nelem_b2
    stop = 2:nelem_b1 + nelem_b2 + 1
    lengths = vcat(lengths_b1, lengths_b2)
    midpoints = vcat(xm_b1, xm_b2)
    Cab = vcat(Cab_b1, Cab_b2)

    compliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx),
        1/(E*Iyy), 1/(E*Izz)]), nelem)

    mass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)

    # create assembly
    assembly = Assembly(points, start, stop;
        compliance = compliance,
        mass = mass,
        frames = Cab,
        lengths = lengths,
        midpoints = midpoints)

    # create system
    system = DynamicSystem(assembly)

    for j = 1:length(rpm)

        # global frame rotation
        w0 = [0, 0, rpm[j]*(2*pi)/60]

        # define previous left eigenvector matrix (used for correlating eigenmodes)
        if i == 1 &amp;&amp; j == 1
            Uprev = nothing
        elseif i == 1
            Uprev = U[i,j-1]
        else
            Uprev = U[i-1,j]
        end

        # eigenvalues and eigenvectors
        system, λ[i,j], U[i,j], V[i,j], converged = eigenvalue_analysis!(system, assembly;
            angular_velocity = w0,
            prescribed_conditions = prescribed_conditions,
            nev = nev,
            left = true,
            Uprev = Uprev)

        # post-process state variables
        state[i,j] = AssemblyState(system, assembly; prescribed_conditions)

        # post-process eigenvector state variables
        eigenstates[i,j] = [
            AssemblyState(system, assembly, V[i,j][:,k]; prescribed_conditions)
            for k = 1:nev
        ]
    end
end

# extract frequencies
frequency = [
    [imag(λ[i,j][k])/(2*pi) for i = 1:length(sweep), j=1:length(rpm)] for k = 1:2:nev
    ]</code></pre><p>Note that we correlated each eigenmode by taking advantage of the fact that left and right eigenvectors satisfy the following relationships:</p><p class="math-container">\[\begin{aligned}
u^H M v &amp;= 1 &amp;\text{if \(u\) and \(v\) correspond to the same eigenmode} \\
u^H M v &amp;= 0 &amp;\text{if \(u\) and \(v\) correspond to different eigenmodes}
\end{aligned}\]</p><p>In this case these eigenmode correlations work, but remember that large changes in the underlying parameters (or just drastic changes in the eigenvectors themselves due to a small perturbation) can cause these correlations to fail.</p><p>We&#39;ll now plot the frequency of the different eigenmodes against those found by Epps and Chandra in &quot;The Natural Frequencies of Rotating Composite Beams With Tip Sweep&quot;.</p><pre><code class="language-julia hljs"># index of first bending mode
index = 1

# experimental data
experiment_sweep = [0, 15, 30, 45]
experiment_rpm = [0, 500, 750]
experiment_frequencies = [
    1.4 10.2 14.8;
    1.8 10.1 14.4;
    1.7 10.2 14.9;
    1.6 10.2 14.7;
]

# initialize plot
plot(
    xlabel = &quot;Sweep Angle (degrees)&quot;,
    xticks = 0:15:45,
    xlim = (0, 45),
    ylabel = &quot;Frequency (Hz)&quot;,
    yticks = 0:2.5:20.0,
    ylim = (0, 20),
    grid = false,
    legend= :topright,
    overwrite_figure=false,
    )

# initialize legend entries
plot!([], [], color=:black, label=&quot;GXBeam&quot;)
scatter!([], [], color=:black, label = &quot;Experiment&quot;)

# plot frequency for each rotation rate
for j = 1:length(rpm)
    # gxbeam
    plot!(sweep*180/pi, frequency[index][:,j], label=&quot;&quot;, color=colors[j])
    # experimental
    scatter!(experiment_sweep, experiment_frequencies[:,j], label=&quot;&quot;, color=colors[j])
    # annotation
    iann = round(Int, 1/4*length(sweep))
    xann = sweep[iann]*180/pi
    yann = frequency[index][iann,j] + 1.5
    annotate!(xann, yann, text(&quot;$(rpm[j]) RPM&quot;, 8, :center, :bottom, colors[j]))
end
plot!(show=true)
savefig(&quot;../assets/rotating-frequencies-1.svg&quot;);</code></pre><p><img src="../../assets/rotating-frequencies-1.svg" alt/></p><pre><code class="language-julia hljs"># index of second bending mode
index = 2

# experimental data
experiment_sweep = [0, 15, 30, 45]
experiment_rpm = [0, 500, 750]
experiment_frequencies = [
    10.3  25.2  36.1;
    10.2  25.2  34.8;
    10.4  23.7  30.7;
    10.4  21.6  26.1;
]

# initialize plot
plot(
    xlabel = &quot;Sweep Angle (degrees)&quot;,
    xticks = 0:15:45,
    xlim = (0, 45),
    ylabel = &quot;Frequency (Hz)&quot;,
    yticks = 0:5:45,
    ylim = (0, 45),
    grid = false,
    legend = :topright,
    overwrite_figure=false
    )

# initialize legend entries
plot!([], [], color=:black, label=&quot;GXBeam&quot;)
scatter!([], [], color=:black, label = &quot;Experiment&quot;)

# plot frequency for each rotation rate
for j = 1:length(rpm)
    # gxbeam
    plot!(sweep*180/pi, frequency[index][:,j], label=&quot;&quot;, color=colors[j])
    # experimental
    scatter!(experiment_sweep, experiment_frequencies[:,j], label=&quot;&quot;, color=colors[j])
    # annotation
    iann = round(Int, 1/4*length(sweep))
    xann = sweep[iann]*180/pi
    yann = frequency[index][iann,j] + 1.5
    annotate!(xann, yann, text(&quot;$(rpm[j]) RPM&quot;, &quot;Serif&quot;, 8, :center, :bottom, colors[j]))
end
plot!(show=true)
savefig(&quot;../assets/rotating-frequencies-2.svg&quot;);</code></pre><p><img src="../../assets/rotating-frequencies-2.svg" alt/></p><pre><code class="language-julia hljs"># index of third bending mode
index = 4

# experimental data
experiment_sweep = [0, 15, 30, 45]
experiment_rpm = [0, 500, 750]
experiment_frequencies = [
    27.7  47.0  62.9
    27.2  44.4  55.9
    26.6  39.3  48.6
    24.8  35.1  44.8
]

# initialize plot
plot(
    xlabel = &quot;Sweep Angle (degrees)&quot;,
    xticks = 0:15:45,
    xlim = (0, 45),
    ylabel = &quot;Frequency (Hz)&quot;,
    yticks = 0:10:70.0,
    ylim = (0, 70),
    grid = false,
    legend = :bottomright,
    overwrite_figure=false
    )

# initialize legend entries
plot!([], [], color=:black, label=&quot;GXBeam&quot;)
scatter!([], [], color=:black, label = &quot;Experiment&quot;)

# plot frequency for each rotation rate
for j = 1:length(rpm)
    # gxbeam
    plot!(sweep*180/pi, frequency[index][:,j], label=&quot;&quot;, color=colors[j])
    # experimental
    scatter!(experiment_sweep, experiment_frequencies[:,j], label=&quot;&quot;, color=colors[j])
    # annotation
    iann = round(Int, 1/4*length(sweep))
    xann = sweep[iann]*180/pi
    yann = frequency[index][iann,j] + 1.5
    annotate!(xann, yann, text(&quot;$(rpm[j]) RPM&quot;, &quot;Serif&quot;, 8, :center, :bottom, colors[j]))
end
plot!(show=true)</code></pre><p><img src="../../assets/rotating-frequencies-3.svg" alt/></p><pre><code class="language-julia hljs"># names and indices of modes
names = [&quot;1T/5B&quot;, &quot;5B/1T&quot;, &quot;4B/1T&quot;]
indices = [5, 7, 6]

# experimental data
experiment_sweep = [0, 15, 30, 45]
experiment_rpm = 750
experiment_frequencies = [
    95.4  106.6  132.7;
    87.5  120.1  147.3;
    83.7  122.6  166.2;
    78.8  117.7  162.0;
]

# initialize plot
plot(
    xlabel = &quot;Sweep Angle (degrees)&quot;,
    xticks = 0:15:45,
    xlim = (0, 45),
    ylabel = &quot;Frequency (Hz)&quot;,
    yticks = 0:20:180,
    ylim = (0, 180),
    grid = false,
    legend = :bottomright,
    overwrite_figure=false,
    )

# initialize legend entries
plot!([], [], color=:black, label=&quot;GXBeam&quot;)
scatter!([], [], color=:black, label = &quot;Experiment&quot;)

for k = 1:length(indices)
    # gxbeam
    plot!(sweep*180/pi, frequency[indices[k]][:,end]; label=&quot;&quot;, color=colors[k])
    # experimental
    scatter!(experiment_sweep, experiment_frequencies[:,k]; label=&quot;&quot;, color=colors[k])
    # annotation
    iann = round(Int, 1/4*length(sweep))
    xann = sweep[iann]*180/pi
    yann = frequency[indices[k]][iann,end] + 1.5
    annotate!(xann, yann, text(&quot;$(names[k])&quot;, &quot;Serif&quot;, 8, :center, :bottom, colors[k]))
end
plot!(show=true)
savefig(&quot;../assets/rotating-frequencies-4.svg&quot;);</code></pre><p><img src="../../assets/rotating-frequencies-4.svg" alt/></p><p>As you can see, the frequency results from the eigenmode analysis in this package compare well with experimental results.</p><p>We can also visualize eigenmodes using ParaView.  Here we will visualize the first bending mode for the 45 degree swept tip at a rotational speed of 750 RPM.  This can be helpful for identifying different eigenmodes.</p><pre><code class="language-julia hljs"># write the response to vtk files for visualization using ParaView
mkpath(&quot;rotating-eigenmode&quot;)
write_vtk(&quot;rotating-eigenmode/rotating-eigenmode&quot;, assembly, state[end,end],
    λ[end,end][1], eigenstates[end,end][1]; mode_scaling = 100.0)</code></pre><p><img src="../../assets/rotating-eigenmode.gif" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../curved/">« Bending of an Initially Curved Beam</a><a class="docs-footer-nextpage" href="../excited/">Excited Second Bending Mode »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 3 November 2022 20:48">Thursday 3 November 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
