<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · GXBeam.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GXBeam.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../examples/guide/">Getting Started</a></li><li><a class="tocitem" href="../../examples/section/">Section Properties and Strain Recovery</a></li><li><a class="tocitem" href="../../examples/sensitivities/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../../examples/diffeq/">DifferentialEquations</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/cantilever/">Cantilever with a Uniform Load</a></li><li><a class="tocitem" href="../../examples/overdetermined/">Overdetermined Beam</a></li><li><a class="tocitem" href="../../examples/tipforce/">Cantilever with a Tip Force</a></li><li><a class="tocitem" href="../../examples/tipmoment/">Cantilever with a Tip Moment</a></li><li><a class="tocitem" href="../../examples/curved/">Bending of an Initially Curved Beam</a></li><li><a class="tocitem" href="../../examples/rotating/">Rotating Beam with a Swept Tip</a></li><li><a class="tocitem" href="../../examples/excited/">Excited Second Bending Mode</a></li><li><a class="tocitem" href="../../examples/wind-turbine-blade/">Time-Domain Simulation of a Wind Turbine Blade</a></li><li><a class="tocitem" href="../../examples/static-joined-wing/">Static Analysis of a Joined-Wing</a></li><li><a class="tocitem" href="../../examples/dynamic-joined-wing/">Time-Domain Simulation of a Joined-Wing</a></li><li><a class="tocitem" href="../../examples/vertical-axis-wind-turbine/">Sandia 34-Meter Vertical Axis Wind Turbine</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Private-API"><span>Private API</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/reference/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><ul></ul><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><h3 id="Creating-an-Assembly"><a class="docs-heading-anchor" href="#Creating-an-Assembly">Creating an Assembly</a><a id="Creating-an-Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-Assembly" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.curve_length" href="#GXBeam.curve_length"><code>GXBeam.curve_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">curve_length(start, stop, curvature)</code></pre><p>Calculate the length of a curve given its endpoints and its curvature vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/assembly.jl#L291-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.discretize_beam" href="#GXBeam.discretize_beam"><code>GXBeam.discretize_beam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">discretize_beam(L, start, discretization; frame, curvature)</code></pre><p>Discretize a beam of length <code>L</code> located at <code>start</code> according to the discretization provided  in <code>discretization</code></p><p>Return the lengths, endpoints, midpoints, and reference frame of the beam elements.</p><p><strong>Arguments</strong></p><ul><li><code>L</code>: Beam length</li><li><code>start</code>: Beam starting point</li><li><code>discretization</code>: Number of beam elements, or the normalized endpoints of each beam       element, with values ranging from 0 to 1.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>frame</code>: Reference frame at the start of the beam element, represented by a 3x3       transformation matrix from the undeformed local frame to the body frame.</li><li><code>curvature</code>: curvature vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/assembly.jl#L197-L215">source</a></section><section><div><pre><code class="nohighlight hljs">discretize_beam(start, stop, discretization; frame, curvature)</code></pre><p>Discretize a beam from <code>start</code> to <code>stop</code> according to the discretization provided in  <code>discretization</code>.</p><p>Return the lengths, endpoints, midpoints, and reference frame of the beam elements.</p><p><strong>Arguments</strong></p><ul><li><code>start</code>: Beam starting point</li><li><code>stop</code>: Beam ending point</li><li><code>discretization</code>: Number of beam elements, or the normalized endpoints of each beam       element, with values ranging from 0 to 1.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>frame</code>: Reference frame at the start of the beam element, represented by a 3x3      transformation matrix from the undeformed local frame to the body frame.</li><li><code>curvature</code>: curvature vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/assembly.jl#L253-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.Assembly" href="#GXBeam.Assembly"><code>GXBeam.Assembly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Assembly{TF, TP&lt;:AbstractVector{&lt;:AbstractVector{TF}},
    TC&lt;:AbstractVector{&lt;:Integer}, TE&lt;:AbstractVector{Element{TF}}}</code></pre><p>Composite type that defines an assembly of connected nonlinear beam elements.</p><p><strong>Fields</strong></p><ul><li><code>points</code>: Array of all beam element endpoints</li><li><code>start</code>: Array containing point index where each beam element starts</li><li><code>stop</code>: Array containing point index where each beam element stops</li><li><code>elements</code>: Array containing beam element definitions (see <a href="#GXBeam.Element"><code>Element</code></a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/assembly.jl#L116-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.Assembly-Tuple{Any, Any, Any}" href="#GXBeam.Assembly-Tuple{Any, Any, Any}"><code>GXBeam.Assembly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Assembly(points, start, stop; kwargs...)</code></pre><p>Construct an assembly of connected nonlinear beam elements.  Beam lengths and midpoints  may be manually specified in case beam elements are curved rather than straight.</p><p><strong>Arguments</strong></p><ul><li><code>points</code>: Array of all beam element endpoints</li><li><code>start</code>: Array containing point indices where each beam element starts</li><li><code>stop</code>: Array containing point indices where each beam element stops</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>frames</code>: Array of (3 x 3) tranformation matrices for each beam element.      Transforms from the local undeformed beam frame to the global frame.       Defaults to the identity matrix.</li><li><code>compliance</code>: Array of (6 x 6) compliance matrices for each beam element.      Defaults to <code>zeros(6,6)</code> for each beam element.</li><li><code>mass</code>: Array of (6 x 6) mass matrices for each beam element.       Defaults to <code>zeros(6,6)</code> for each beam element.</li><li><code>damping</code>: Array of (6) structural damping coefficients for each beam element.       Defaults to <code>fill(0.01, 6)</code> for each beam element.</li><li><code>lengths</code>: Array containing the length of each beam element.      Defaults to the distance between beam endpoints.</li><li><code>midpoints</code>: Array containing the midpoint of each beam element.      Defaults to the average of the beam element endpoints.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/assembly.jl#L157-L182">source</a></section></article><h3 id="Section-Properties"><a class="docs-heading-anchor" href="#Section-Properties">Section Properties</a><a id="Section-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Section-Properties" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.Material" href="#GXBeam.Material"><code>GXBeam.Material</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Material(E1, E2, E3, G12, G13, G23, nu12, nu13, nu23, rho,
    S1t=1.0, S1c=1.0, S2t=1.0, S2c=1.0, S3t=1.0, S3c=1.0, S12=1.0, S13=1.0, S23=1.0)</code></pre><p>General orthotropic material properties. 1 is along main ply axis. 2 is transverse. 3 is normal to ply. for a fiber orientation of zero, 1 is along the beam axis. strength properties are optional</p><p><strong>Arguments</strong></p><ul><li><code>Ei:float</code>: Young&#39;s modulus along 1st, 2nd and 3rd axes.</li><li><code>Gij::float</code>: shear moduli</li><li><code>nuij::float</code>: Poisson&#39;s ratio.  <span>$nu_ij E_j = nu_ji E_i$</span></li><li><code>rho::float</code>: density</li><li><code>Sit/c::float</code>: strength in ith direction for tension and compression</li><li><code>Sij::float</code>: strength in ij direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/section.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.Node" href="#GXBeam.Node"><code>GXBeam.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Node(x, y)</code></pre><p>A node in the finite element mesh at location x, y.  If assembled in a vector, the vector index corresponds to the node number.</p><p><strong>Arguments</strong></p><ul><li><code>x::float</code>: x location of node in global coordinate system</li><li><code>y::float</code>: y location of node in global coordinate system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/section.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.MeshElement" href="#GXBeam.MeshElement"><code>GXBeam.MeshElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeshElement(nodenum, material, theta)</code></pre><p>An element in the mesh, consisting of four ordered nodes, a material, and a fiber orientation.</p><p><strong>Arguments</strong></p><ul><li><code>nodenum::Vector{integer}</code>: a vector of four node numbers corresponding the the four nodes defining this element (vector indices of the nodes).   Node order should be counterclockwise starting from the bottom left node using the local coordinate sytem (see figure).</li><li><code>material::Material</code>: material properties of this element</li><li><code>theta::float</code>: fiber orientation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/section.jl#L71-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.Layer" href="#GXBeam.Layer"><code>GXBeam.Layer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Layer(material, t, theta)</code></pre><p>A layer (could be one ply or many plys of same material). A layup is a vector of layers.</p><p><strong>Arguments</strong></p><ul><li><code>material::Material</code>: material of layer</li><li><code>t::float</code>: thickness of layer</li><li><code>theta::float</code>: fiber orientation (rad)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/afmesh.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.afmesh" href="#GXBeam.afmesh"><code>GXBeam.afmesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">afmesh(xaf, yaf, chord, twist, paxis, xbreak, webloc, segments, webs; ds=nothing, dt=nothing, ns=nothing, nt=nothing, wns=4, wnt=nothing)</code></pre><p>Create structural mesh for airfoil.  The airfoil coordinates define the meshing density tangential to the airfoil. Whereas the number of layers defines the resolution normal to the airfoil. All segments are meshed with the same resolution in the normal direction, using the number of grid points as defined by segment with the most layers.</p><p><strong>Arguments</strong></p><ul><li><code>xaf, yaf::Vector{float}</code>: points defining airfoil start at trailing edge and traverse counterclockwise back to trailing edge (can be blunt or sharp T.E.)</li><li><code>chord::float</code>: chord length</li><li><code>twist::float</code>: twist angle (rad)</li><li><code>paxis::float</code>: pitch axis (normalized by chord). e.g., 0.25 means twist about quarter chord.</li><li><code>xbreak::Vector{float}</code>: x-locations, normalized by chord, defining break points between segments. must start at 0 and end at 1. e.g., [0, 0.2, 0.4, 0.7, 1.0] defines 4 segments.</li><li><code>webloc::Vector{float}</code>: x-locations, normalized by chord, defining web centers (and length of vector is number of webs).  e.g., [0.25, 0.55] means there is a web at 25% chord and a second web at 55% chord.</li><li><code>segments::Vector{Vector{Layer}}</code>: A Layer defines a ply (or multiple plys with the same material/orientation).  At a given x location the ply stack (segment) is defined a vector of layers starting from outside surface towards inside. Segments then is a vector of these segments that defines properties between segments as defined by xbreak.</li><li><code>webs::Vector{Vector{Layer}}</code>: same structure as segments, except each inner vector is from left to right (although this is usually symmetric), and each outer vector is for a separate web</li><li><code>ds::float</code>: if provided, airfoil spacing will be resampling with approximately this spacing, normalized by chord.  e.g., 0.01 will have points on the airfoil roughly 1% chord apart.</li><li><code>dt::float</code>: if provided, thickness will be resampled with this maximum mesh size (thickness is absolute). Note that the total number of cells remains constant along airfoil, so most thicknesses will be much less.  e.g., 0.01 will target a maximum mesh thickness of 0.01 (absolute).</li><li><code>ns::vector{int}</code>: if provided, rather than use a targert size ds, we specify the number of cells to use in each segment.  This is desirable for gradient-based optimization, if airfoil coordinates are changed, so that during resizing operations the  mesh stretch/shrinks rather than experiencing discrete jumps.  For example, ns=[15, 20, 40, 30] would use 15 elements between xbreak[1] and xbreak[2] and so on.  </li><li><code>nt::vector{vector{int}}</code>: if provided, defines how many elements to use across tangential direction.  Again, prefered over dt for gradient-based optimization, if the thicknesses are changed during optimization.  each entry defines how many cells to put in that layer following order of original layup.  for example, nt=[[1, 2, 1], [1, 3]] would use 1 element, 2 elements (subdivide), then 1 elements over first sector, and so on.</li><li><code>wns::int</code>: discretization level for number of elements vertically along web.</li><li><code>wnt::vector{vector{int}}</code>: same definition as nt but for the webs</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Vector{Node{Float64}}</code>: nodes for this mesh</li><li><code>elements::Vector{MeshElement{Vector{Int},Float64}}</code>: elements for this mesh</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/afmesh.jl#L796-L822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initialize_cache" href="#GXBeam.initialize_cache"><code>GXBeam.initialize_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialize_cache(nodes, elements, etype=Float64)</code></pre><p>create cache.  set sizes of static matrices, and set sparsity patterns for those that are fixed.</p><p><strong>Arguments</strong></p><ul><li><code>etype::Type</code>: the element type (typically a float or a dual type)</li><li><code>d::Int</code>: the number of variables you are taking derivatives w.r.t (i.e., number of design variables)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/section.jl#L142-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.compliance_matrix" href="#GXBeam.compliance_matrix"><code>GXBeam.compliance_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compliance_matrix(nodes, elements; cache=initialize_cache(nodes, elements), gxbeam_order=true)</code></pre><p>Compute compliance matrix given the finite element mesh described by nodes and elements.</p><p><strong>Arguments</strong></p><ul><li><code>nodes::Vector{Node{TF}}</code>: all the nodes in the mesh</li><li><code>elements::Vector{MeshElement{VI, TF}}</code>: all the elements in the mesh</li><li><code>cache::SectionCache</code>: if number of nodes, number of elements, and connectivity of mesh stays the same (and you will be repeating calls)   then you can should initialize cache yourself and pass in so you don&#39;t have to keep reconstructing it.</li><li><code>gxbeam_order::Bool</code>: true if output compliance matrix should be in GXBeam order or internal ordering</li></ul><p><strong>Returns</strong></p><ul><li><code>S::Matrix</code>: compliance matrix (about the shear center as long as gxbeam_order = true)</li><li><code>sc::Vector{float}</code>: x, y location of shear center   (location where a transverse/shear force will not produce any torsion, i.e., beam will not twist)</li><li><code>tc::Vector{float}</code>: x, y location of tension center, aka elastic center, aka centroid   (location where an axial force will not produce any bending, i.e., beam will remain straight)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/section.jl#L727-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.mass_matrix" href="#GXBeam.mass_matrix"><code>GXBeam.mass_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mass_matrix(nodes, elements)</code></pre><p>Compute mass matrix for the structure using GXBeam ordering.</p><p><strong>Returns</strong></p><ul><li><code>M::Matrix</code>: mass matrix</li><li><code>mc::Vector{float}</code>: x, y location of mass center</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/section.jl#L873-L881">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.plotmesh" href="#GXBeam.plotmesh"><code>GXBeam.plotmesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotmesh(nodes, elements, pyplot; plotnumbers=false)</code></pre><p>plot nodes and elements for a quick visualization. Need to pass in a PyPlot object as PyPlot is not loaded by this package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/section.jl#L934-L939">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.strain_recovery" href="#GXBeam.strain_recovery"><code>GXBeam.strain_recovery</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strain_recovery(F, M, nodes, elements, cache)</code></pre><p>Compute stresses and strains at each element in cross section.</p><p><strong>Arguments</strong></p><ul><li><code>F::Vector(3)</code>: force at this cross section in x, y, z directions</li><li><code>M::Vector(3)</code>: moment at this cross section in x, y, z directions</li><li><code>nodes::Vector{Node{TF}}</code>: all the nodes in the mesh</li><li><code>elements::Vector{MeshElement{VI, TF}}</code>: all the elements in the mesh</li><li><code>cache::SectionCache</code>: needs to reuse data from the compliance solve   (thus must initialize cache and pass it to both compliance and this function)</li></ul><p><strong>Returns</strong></p><ul><li><code>strain_b::Vector(6, ne)</code>: strains in beam coordinate system for each element. order: xx, yy, zz, xy, xz, yz</li><li><code>stress_b::Vector(6, ne)</code>: stresses in beam coordinate system for each element. order: xx, yy, zz, xy, xz, yz</li><li><code>strain_p::Vector(6, ne)</code>: strains in ply coordinate system for each element. order: 11, 22, 33, 12, 13, 23</li><li><code>stress_p::Vector(6, ne)</code>: stresses in ply coordinate system for each element. order: 11, 22, 33, 12, 13, 23</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/section.jl#L967-L985">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.plotsoln" href="#GXBeam.plotsoln"><code>GXBeam.plotsoln</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotsoln(nodes, elements, soln, pyplot)</code></pre><p>plot stress/strain on mesh soln could be any vector that is of length # of elements, e.g., sigma_b[3, :] Need to pass in a PyPlot object as PyPlot is not loaded by this package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/section.jl#L1050-L1056">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.tsai_wu" href="#GXBeam.tsai_wu"><code>GXBeam.tsai_wu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tsai_wu(stress_p, elements)</code></pre><p>Tsai Wu failure criteria</p><p><strong>Arguments</strong></p><ul><li><code>stress_p::vector(6, ne)</code>: stresses in ply coordinate system</li><li><code>elements::Vector{MeshElement{VI, TF}}</code>: all the elements in the mesh</li></ul><p><strong>Returns</strong></p><ul><li><code>failure::vector(ne)</code>: tsai-wu failure criteria for each element.  fails if &gt;= 1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/section.jl#L1116-L1127">source</a></section></article><h3 id="Defining-Point-Masses"><a class="docs-heading-anchor" href="#Defining-Point-Masses">Defining Point Masses</a><a id="Defining-Point-Masses-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Point-Masses" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PointMass" href="#GXBeam.PointMass"><code>GXBeam.PointMass</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PointMass{T}</code></pre><p>Type which contains the aggregated inertial properties of one or more point masses which are rigidly attached to the center of an element.</p><p><strong>Fields:</strong></p><ul><li><code>mass</code>: Mass matrix corresponding to the point masses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/loads.jl#L488-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PointMass-Tuple{Any, Any, Any}" href="#GXBeam.PointMass-Tuple{Any, Any, Any}"><code>GXBeam.PointMass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PointMass(m, p, I)</code></pre><p>Define a point mass given its mass <code>m</code>, offset <code>p</code>, and inertia matrix <code>I</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/loads.jl#L513-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.combine_masses" href="#GXBeam.combine_masses"><code>GXBeam.combine_masses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combine_masses(masses)</code></pre><p>Combine the point masses in the iterable collection <code>masses</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/loads.jl#L520-L524">source</a></section></article><h3 id="Defining-Distributed-Loads"><a class="docs-heading-anchor" href="#Defining-Distributed-Loads">Defining Distributed Loads</a><a id="Defining-Distributed-Loads-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Distributed-Loads" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.DistributedLoads" href="#GXBeam.DistributedLoads"><code>GXBeam.DistributedLoads</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DistributedLoads{T}</code></pre><p>Type which contains pre-integrated distributed forces and moments applied to a beam element.</p><p><strong>Fields</strong></p><ul><li>f1: Integrated non-follower distributed force corresponding to the start of the beam element.</li><li>f2: Integrated non-follower distributed force corresponding to the end of the beam element.</li><li>m1: Integrated non-follower distributed moment corresponding to the start of the beam element.</li><li>m2: Integrated non-follower distributed moment corresponding to the end of the beam element.</li><li>f1_follower: Integrated follower distributed force corresponding to the start of the beam element.</li><li>f2_follower: Integrated follower distributed force corresponding to the end of the beam element.</li><li>m1_follower: Integrated follower distributed moment corresponding to the start of the beam element.</li><li>m2_follower: Integrated follower distributed moment corresponding to the end of the beam element.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/loads.jl#L247-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.DistributedLoads-Tuple{Any, Any}" href="#GXBeam.DistributedLoads-Tuple{Any, Any}"><code>GXBeam.DistributedLoads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DistributedLoads(assembly, ielem; kwargs...)</code></pre><p>Pre-integrate distributed loads on a beam element for use in an analysis.</p><p><strong>Arguments</strong></p><ul><li><code>assembly</code>: Beam element assembly (of type <a href="#GXBeam.Assembly"><code>Assembly</code></a>)</li><li><code>ielem</code>: Beam element index</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>s1 = 0.0</code>: Start of the beam element (used solely for integrating the distributed loads)</li><li><code>s2 = 1.0</code>: End of the beam element (used solely for integrating the distributed loads)</li><li><code>method = (f, s1, s2) -&gt; gauss_quadrature(f, s1, s2)</code>: Method which integrates function</li></ul><p><code>f</code> from <code>s1</code> to <code>s2</code>. Defaults to the Gauss-Legendre quadrature with 4 points on each element.</p><ul><li><code>fx = (s) -&gt; 0.0</code>: Distributed x-direction force</li><li><code>fy = (s) -&gt; 0.0</code>: Distributed y-direction force</li><li><code>fz = (s) -&gt; 0.0</code>: Distributed z-direction force</li><li><code>mx = (s) -&gt; 0.0</code>: Distributed x-direction moment</li><li><code>my = (s) -&gt; 0.0</code>: Distributed y-direction moment</li><li><code>mz = (s) -&gt; 0.0</code>: Distributed z-direction moment</li><li><code>fx_follower = (s) -&gt; 0.0</code>: Distributed x-direction follower force</li><li><code>fy_follower = (s) -&gt; 0.0</code>: Distributed y-direction follower force</li><li><code>fz_follower = (s) -&gt; 0.0</code>: Distributed z-direction follower force</li><li><code>mx_follower = (s) -&gt; 0.0</code>: Distributed x-direction follower moment</li><li><code>my_follower = (s) -&gt; 0.0</code>: Distributed y-direction follower moment</li><li><code>mz_follower = (s) -&gt; 0.0</code>: Distributed z-direction follower moment</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/loads.jl#L282-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.combine_loads" href="#GXBeam.combine_loads"><code>GXBeam.combine_loads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combine_loads(loads)</code></pre><p>Combine the distributed loads in the iterable collection <code>loads</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/loads.jl#L461-L465">source</a></section></article><h3 id="Defining-Prescribed-Conditions"><a class="docs-heading-anchor" href="#Defining-Prescribed-Conditions">Defining Prescribed Conditions</a><a id="Defining-Prescribed-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Prescribed-Conditions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PrescribedConditions" href="#GXBeam.PrescribedConditions"><code>GXBeam.PrescribedConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrescribedConditions{T}</code></pre><p>Type which defines the prescribed displacements and loads at a point.</p><p><strong>Fields:</strong></p><ul><li><code>pd</code>: Flag for each degree of freedom indicating whether displacements are prescribed</li><li><code>pl</code>: Flag for each degree of freedom indicating whether loads are prescribed</li><li><code>u</code>: Linear displacement</li><li><code>theta</code>: Angular displacement</li><li><code>F</code>: External forces</li><li><code>M</code>: External moments</li><li><code>Ff</code>: Follower forces</li><li><code>Mf</code>: Follower moments</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/loads.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PrescribedConditions-Tuple{}" href="#GXBeam.PrescribedConditions-Tuple{}"><code>GXBeam.PrescribedConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PrescribedConditions(; kwargs...)</code></pre><p>Define the prescribed conditions at a point.  Individual prescribed conditions may be assigned as either a scalar parameter or as a function of time.</p><p>Prescribed Wiener-Milenkovic parameters must satisfy the following inequality: sqrt(theta<em>x^2 + theta</em>y^2 + theta_z^2) &lt;= 4.  Note that this restriction still allows all possible rotations to be represented.</p><p>Note that if displacements and loads corresponding to the same degree of freedom are prescribed at the same point, the global body-fixed acceleration corresponding to the same degree of freedom will be modified to attempt to satisfy both conditions.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>ux</code>: Prescribed x-displacement (in the body frame)</li><li><code>uy</code>: Prescribed y-displacement (in the body frame)</li><li><code>uz</code>: Prescribed z-displacement (in the body frame)</li><li><code>theta_x</code>: Prescribed first Wiener-Milenkovic parameter</li><li><code>theta_y</code>: Prescribed second Wiener-Milenkovic parameter</li><li><code>theta_z</code>: Prescribed third Wiener-Milenkovic parameter</li><li><code>Fx</code>: Prescribed x-direction force</li><li><code>Fy</code>: Prescribed y-direction force</li><li><code>Fz</code>: Prescribed z-direction force</li><li><code>Mx</code>: Prescribed x-direction moment</li><li><code>My</code>: Prescribed y-direction moment</li><li><code>Mz</code>: Prescribed z-direction moment</li><li><code>Fx_follower</code>: Prescribed x-direction follower force</li><li><code>Fy_follower</code>: Prescribed y-direction follower force</li><li><code>Fz_follower</code>: Prescribed z-direction follower force</li><li><code>Mx_follower</code>: Prescribed x-direction follower moment</li><li><code>My_follower</code>: Prescribed y-direction follower moment</li><li><code>Mz_follower</code>: Prescribed z-direction follower moment</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/loads.jl#L35-L68">source</a></section></article><h3 id="Pre-Initializing-Memory-for-an-Analysis"><a class="docs-heading-anchor" href="#Pre-Initializing-Memory-for-an-Analysis">Pre-Initializing Memory for an Analysis</a><a id="Pre-Initializing-Memory-for-an-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-Initializing-Memory-for-an-Analysis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.AbstractSystem" href="#GXBeam.AbstractSystem"><code>GXBeam.AbstractSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSystem</code></pre><p>Supertype for types which contain the system state, residual vector, and jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.StaticSystem" href="#GXBeam.StaticSystem"><code>GXBeam.StaticSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StaticSystem{TF, TV&lt;:AbstractVector{TF}, TM&lt;:AbstractMatrix{TF}} &lt;: AbstractSystem</code></pre><p>Contains the system state, residual vector, and jacobian matrix for a static system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.StaticSystem-Tuple{Any}" href="#GXBeam.StaticSystem-Tuple{Any}"><code>GXBeam.StaticSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StaticSystem([TF=eltype(assembly),] assembly; kwargs...)</code></pre><p>Initialize an object of type <a href="#GXBeam.StaticSystem"><code>StaticSystem</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>TF:</code>(optional) Floating point type, defaults to the floating point type of <code>assembly</code></li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>force_scaling</code>: Factor used to scale system forces/moments internally.  If  not specified, a suitable default will be chosen based on the entries of the  beam element compliance matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L225-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.DynamicSystem" href="#GXBeam.DynamicSystem"><code>GXBeam.DynamicSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DynamicSystem{TF, TV&lt;:AbstractVector{TF}, TM&lt;:AbstractMatrix{TF}} &lt;: AbstractSystem</code></pre><p>Contains the system state, residual vector, and jacobian matrix for a dynamic system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.DynamicSystem-Tuple{Any}" href="#GXBeam.DynamicSystem-Tuple{Any}"><code>GXBeam.DynamicSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DynamicSystem([TF=eltype(assembly),] assembly; kwargs...)</code></pre><p>Initialize an object of type <a href="#GXBeam.DynamicSystem"><code>DynamicSystem</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>TF:</code>(optional) Floating point type, defaults to the floating point type of <code>assembly</code></li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>force_scaling</code>: Factor used to scale system forces/moments internally.  If  not specified, a suitable default will be chosen based on the entries of the  beam element compliance matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L279-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.ExpandedSystem" href="#GXBeam.ExpandedSystem"><code>GXBeam.ExpandedSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExpandedSystem{TF, TV&lt;:AbstractVector{TF}, TM&lt;:AbstractMatrix{TF}} &lt;: AbstractSystem</code></pre><p>Contains the system state, residual vector, and jacobian matrix for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L317-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.ExpandedSystem-Tuple{Any}" href="#GXBeam.ExpandedSystem-Tuple{Any}"><code>GXBeam.ExpandedSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExpandedSystem([TF=eltype(assembly),] assembly; kwargs...)</code></pre><p>Initialize an object of type <a href="#GXBeam.ExpandedSystem"><code>ExpandedSystem</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>TF:</code>(optional) Floating point type, defaults to the floating point type of <code>assembly</code></li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>force_scaling</code>: Factor used to scale system forces/moments internally.  If  not specified, a suitable default will be chosen based on the entries of the  beam element compliance matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L335-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.reset_state!" href="#GXBeam.reset_state!"><code>GXBeam.reset_state!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_state!(system)</code></pre><p>Sets the state variables in <code>system</code> to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L376-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_state!" href="#GXBeam.set_state!"><code>GXBeam.set_state!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_state!([x,] system::StaticSystem, prescribed_conditions; kwargs...)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) to the provided values.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>u</code>: Vector containing the linear displacement of each point.</li><li><code>theta</code>: Vector containing the angular displacement of each point.</li><li><code>F</code>: Vector containing the externally applied forces acting on each point</li><li><code>M</code>: Vector containing the externally applied moments acting on each point</li><li><code>Fi</code>: Vector containing internal forces for each beam element</li><li><code>Mi</code>: Vector containing internal moments for each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L1-L13">source</a></section><section><div><pre><code class="nohighlight hljs">set_state!([x,] system::DynamicSystem, prescribed_conditions; kwargs...)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) to the provided values.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>u</code>: Vector containing the linear displacement of each point.</li><li><code>theta</code>: Vector containing the angular displacement of each point.</li><li><code>V</code>: Vector containing the linear velocity of each point.</li><li><code>Omega</code> Vector containing the angular velocity of each point</li><li><code>F</code>: Vector containing the externally applied forces acting on each point</li><li><code>M</code>: Vector containing the externally applied moments acting on each point</li><li><code>Fi</code>: Vector containing internal forces for each beam element (in the deformed      element frame)</li><li><code>Mi</code>: Vector containing internal moments for each beam element (in the deformed      element frame)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L16-L32">source</a></section><section><div><pre><code class="nohighlight hljs">set_state!([x,] system::ExpandedSystem, prescribed_conditions; kwargs...)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) to the provided values.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>u</code>: Vector containing the linear displacement of each point.</li><li><code>theta</code>: Vector containing the angular displacement of each point.</li><li><code>V</code>: Vector containing the linear velocity of each point in the deformed point frame</li><li><code>Omega</code> Vector containing the angular velocity of each point in the deformed point frame</li><li><code>F</code>: Vector containing the externally applied forces acting on each point</li><li><code>M</code>: Vector containing the externally applied moments acting on each point</li><li><code>F1</code>: Vector containing resultant forces at the start of each beam element (in the  deformed element frame)</li><li><code>M1</code>: Vector containing resultant moments at the start of each beam element (in the  deformed element frame)</li><li><code>F2</code>: Vector containing resultant forces at the end of each beam element (in the  deformed element frame)</li><li><code>M2</code>: Vector containing resultant moments at the end of each beam element (in the  deformed element frame)</li><li><code>V_e</code>: Vector containing the linear velocity of each beam element in the deformed  beam element reference frame.</li><li><code>Omega_e</code> Vector containing the angular velocity of each beam element in the deformed  beam element reference frame.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L35-L59">source</a></section><section><div><pre><code class="nohighlight hljs">set_state!([x=system.x,] system, assembly, state; kwargs...)</code></pre><p>Set the state variables in <code>x</code> to the values in <code>state</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/output.jl#L502-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_rate!" href="#GXBeam.set_rate!"><code>GXBeam.set_rate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_rate!([x=system.dx,] system, assembly, state::AssemblyState; kwargs...)</code></pre><p>Set the state variable rates in <code>dx</code> to the values in <code>state</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/output.jl#L637-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_linear_displacement!" href="#GXBeam.set_linear_displacement!"><code>GXBeam.set_linear_displacement!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_linear_displacement!([x,] system, prescribed_conditions, u, ipoint)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the linear deflection of point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_angular_displacement!" href="#GXBeam.set_angular_displacement!"><code>GXBeam.set_angular_displacement!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_angular_displacement!([x,] system, prescribed_conditions, theta, ipoint)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the angular deflection of point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L265-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_external_forces!" href="#GXBeam.set_external_forces!"><code>GXBeam.set_external_forces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_external_forces!([x,] system, prescribed_conditions, F, ipoint)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the external forces applied at point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L487-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_external_moments!" href="#GXBeam.set_external_moments!"><code>GXBeam.set_external_moments!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_external_moments!([x,] system, prescribed_conditions, M, ipoint)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the external moments applied at point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L522-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_linear_velocity!" href="#GXBeam.set_linear_velocity!"><code>GXBeam.set_linear_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_linear_velocity!([x,] system, V, ipoint)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the linear velocity of point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L359-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_angular_velocity!" href="#GXBeam.set_angular_velocity!"><code>GXBeam.set_angular_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_angular_velocity!([x,] system, Omega, ipoint)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the angular velocity of point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L423-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_internal_forces!" href="#GXBeam.set_internal_forces!"><code>GXBeam.set_internal_forces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_internal_forces!([x,] system::Union{StaticSystem,DynamicSystem}, Fi, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the internal forces of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L557-L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_internal_moments!" href="#GXBeam.set_internal_moments!"><code>GXBeam.set_internal_moments!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_internal_moments!([x,] system::Union{StaticSystem, DynamicSystem}, Mi, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the internal moments of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L588-L593">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_start_forces!" href="#GXBeam.set_start_forces!"><code>GXBeam.set_start_forces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_start_forces!([x,] system, F1, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the resultant forces at the start of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L677-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_start_moments!" href="#GXBeam.set_start_moments!"><code>GXBeam.set_start_moments!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_start_moments!([x,] system, M1, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the resultant moments at the start of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L708-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_end_forces!" href="#GXBeam.set_end_forces!"><code>GXBeam.set_end_forces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_end_forces!([x,] system, F2, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the resultant forces at the end of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L739-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_end_moments!" href="#GXBeam.set_end_moments!"><code>GXBeam.set_end_moments!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_end_moments!([x,] system, M2, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the resultant moments at the end of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L770-L775">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_point_linear_velocity!" href="#GXBeam.set_point_linear_velocity!"><code>GXBeam.set_point_linear_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_point_linear_velocity!([x,] system::ExpandedSystem, V, ipoint)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the linear velocity of point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L619-L624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_point_angular_velocity!" href="#GXBeam.set_point_angular_velocity!"><code>GXBeam.set_point_angular_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_point_angular_velocity!([x,] system::ExpandedSystem, Omega, ipoint)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the angular velocity of point <code>ipoint</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L648-L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_element_linear_velocity!" href="#GXBeam.set_element_linear_velocity!"><code>GXBeam.set_element_linear_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_element_linear_velocity!([x,] system::ExpandedSystem, V, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the linear velocity of beam element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L801-L806">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.set_element_angular_velocity!" href="#GXBeam.set_element_angular_velocity!"><code>GXBeam.set_element_angular_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_element_angular_velocity!([x,] system::ExpandedSystem, Omega, ielem)</code></pre><p>Set the state variables in <code>system</code> (or in the vector <code>x</code>) corresponding to the angular velocity of element <code>ielem</code> to the provided values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/input.jl#L832-L837">source</a></section></article><h3 id="Performing-an-Analysis"><a class="docs-heading-anchor" href="#Performing-an-Analysis">Performing an Analysis</a><a id="Performing-an-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-an-Analysis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_analysis" href="#GXBeam.static_analysis"><code>GXBeam.static_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_analysis(assembly; kwargs...)</code></pre><p>Perform a static analysis for the system of nonlinear beams contained in <code>assembly</code>. Return the resulting system, the post-processed solution, and a convergence flag indicating whether the iteration procedure converged.</p><p><strong>General Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>:      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      <a href="#GXBeam.PrescribedConditions"><code>PrescribedConditions</code></a> which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.</li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type <a href="#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.</li><li><code>point_masses = Dict{Int,PointMass{Float64}}()</code>: A dictionary with keys      corresponding to the points to which point masses are attached and values      of type <a href="#GXBeam.PointMass"><code>PointMass</code></a> which contain the properties of the attached      point masses.  If time varying, this input may be provided as a function of time.</li><li><code>gravity = [0,0,0]</code>: Gravity vector.  If time varying, this input may be provided as a      function of time.</li><li><code>time = 0.0</code>: Current time or vector of times corresponding to each step. May be used      in conjunction with time varying prescribed conditions, distributed loads, and      body frame motion to gradually increase displacements and loads.</li></ul><p><strong>Control Flag Keyword Arguments</strong></p><ul><li><code>reset_state = true</code>: Flag indicating whether the system state variables should be      set to zero prior to performing this analysis.</li><li><code>initial_state = nothing</code>: Object of type <a href="#GXBeam.AssemblyState"><code>AssemblyState</code></a> which contains the      initial state variables.  If not provided (or set to <code>nothing</code>), then the state      variables stored in <code>system</code> (which default to zeros) will be used as the initial      state variables.</li><li><code>linear = false</code>: Flag indicating whether a linear analysis should be performed.</li><li><code>two_dimensional = false</code>: Flag indicating whether to constrain results to the x-y plane</li><li><code>show_trace = false</code>: Flag indicating whether to display the solution progress.</li></ul><p><strong>Linear Analysis Keyword Arguments</strong></p><ul><li><code>update_linearization = false</code>: Flag indicating whether to update the linearization state      variables for a linear analysis with the instantaneous state variables. If <code>false</code>,      then the initial set of state variables will be used for the linearization.</li></ul><p><strong>Nonlinear Analysis Keyword Arguments (see <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a>)</strong></p><ul><li><code>method = :newton</code>: Solution method for nonlinear systems of equations</li><li><code>linesearch = LineSearches.BackTracking(maxstep=1e6)</code>: Line search for solving nonlinear      systems of equations</li><li><code>ftol = 1e-9</code>: Tolerance for solving the nonlinear system of equations</li><li><code>iterations = 1000</code>: Iteration limit when solving nonlinear systems of equations</li></ul><p><strong>Sensitivity Analysis Keyword Arguments</strong></p><ul><li><code>xpfunc = (x, p, t) -&gt; (;)</code>: Similar to <code>pfunc</code>, except that parameters can also be      defined as a function of GXBeam&#39;s state variables.  Using this function forces      the system jacobian to be computed using automatic differentiation and switches      the nonlinear solver to a Newton-Krylov solver (with linesearch).</li><li><code>pfunc = (p, t) -&gt; (;)</code>: Function which returns a named tuple with fields corresponding      to updated versions of the arguments <code>assembly</code>, <code>prescribed_conditions</code>,      <code>distributed_loads</code>, <code>point_masses</code>, and <code>gravity</code>. Only fields contained in the      resulting named tuple will be overwritten.</li><li><code>p</code>: Sensitivity parameters, as defined in conjunction with the keyword argument <code>pfunc</code>.      While not necessary, using <code>pfunc</code> and <code>p</code> to define the arguments to this function      allows automatic differentiation sensitivities to be computed more efficiently</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L1-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_analysis!" href="#GXBeam.static_analysis!"><code>GXBeam.static_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <a href="#GXBeam.static_analysis"><code>static_analysis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_analysis" href="#GXBeam.steady_state_analysis"><code>GXBeam.steady_state_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_state_analysis(assembly; kwargs...)</code></pre><p>Perform a steady-state analysis for the system of nonlinear beams contained in <code>assembly</code>.  Return the resulting system and a flag indicating whether the iteration procedure converged.</p><p><strong>General Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>:      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      <a href="#GXBeam.PrescribedConditions"><code>PrescribedConditions</code></a> which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.</li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type <a href="#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.</li><li><code>point_masses = Dict{Int,PointMass{Float64}}()</code>: A dictionary with keys      corresponding to the points to which point masses are attached and values      of type <a href="#GXBeam.PointMass"><code>PointMass</code></a> which contain the properties of the attached      point masses.  If time varying, this input may be provided as a function of time.</li><li><code>linear_velocity = zeros(3)</code>: Prescribed linear velocity of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>angular_velocity = zeros(3)</code>: Prescribed angular velocity of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>linear_acceleration = zeros(3)</code>: Prescribed linear acceleration of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>angular_acceleration = zeros(3)</code>: Prescribed angular acceleration of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>gravity = [0,0,0]</code>: Gravity vector in the body frame.  If time varying, this input      may be provided as a function of time.</li><li><code>time = 0.0</code>: Current time or vector of times corresponding to each step. May be used      in conjunction with time varying prescribed conditions, distributed loads, and      body frame motion to gradually increase displacements and loads.</li></ul><p><strong>Control Flag Keyword Arguments</strong></p><ul><li><code>reset_state = true</code>: Flag indicating whether the system state variables should be      set to zero prior to performing this analysis.</li><li><code>initial_state = nothing</code>: Object of type <a href="#GXBeam.AssemblyState"><code>AssemblyState</code></a> which contains the      initial state variables.  If not provided (or set to <code>nothing</code>), then the state      variables stored in <code>system</code> (which default to zeros) will be used as the initial      state variables.</li><li><code>structural_damping = false</code>: Indicates whether to enable structural damping</li><li><code>linear = false</code>: Flag indicating whether a linear analysis should be performed.</li><li><code>two_dimensional = false</code>: Flag indicating whether to constrain results to the x-y plane</li><li><code>show_trace = false</code>: Flag indicating whether to display the solution progress.</li></ul><p><strong>Linear Analysis Keyword Arguments</strong></p><ul><li><code>update_linearization = false</code>: Flag indicating whether to update the linearization state      variables for a linear analysis with the instantaneous state variables. If <code>false</code>,      then the initial set of state variables will be used for the linearization.</li></ul><p><strong>Nonlinear Analysis Keyword Arguments</strong></p><ul><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve the      nonlinear system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving the nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations=</li></ul><p><strong>Sensitivity Analysis Keyword Arguments</strong></p><ul><li><code>xpfunc = (x, p, t) -&gt; (;)</code>: Similar to <code>pfunc</code>, except that parameters can also be      defined as a function of GXBeam&#39;s state variables.  Using this function forces      the system jacobian to be computed using automatic differentiation and switches      the nonlinear solver to a Newton-Krylov solver (with linesearch).</li><li><code>pfunc = (p, t) -&gt; (;)</code>: Function which returns a named tuple with fields corresponding      to updated versions of the arguments <code>assembly</code>, <code>prescribed_conditions</code>,      <code>distributed_loads</code>, <code>point_masses</code>, <code>linear_velocity</code>, <code>angular_velocity</code>,      <code>linear_acceleration</code>, <code>angular_acceleration</code>, and <code>gravity</code>. Only fields contained      in the resulting named tuple will be overwritten.</li><li><code>p</code>: Sensitivity parameters, as defined in conjunction with the keyword argument <code>pfunc</code>.      While not necessary, using <code>pfunc</code> and <code>p</code> to define the arguments to this function      allows automatic differentiation sensitivities to be computed more efficiently</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L292-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_analysis!" href="#GXBeam.steady_state_analysis!"><code>GXBeam.steady_state_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_state_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <a href="#GXBeam.steady_state_analysis"><code>steady_state_analysis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L378-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.eigenvalue_analysis" href="#GXBeam.eigenvalue_analysis"><code>GXBeam.eigenvalue_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigenvalue_analysis(assembly; kwargs...)</code></pre><p>Compute the eigenvalues and eigenvectors of the system of nonlinear beams contained in <code>assembly</code>.  Return the modified system, eigenvalues, eigenvectors, and a convergence flag indicating whether the corresponding steady-state analysis converged.</p><p><strong>General Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>:      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      <a href="#GXBeam.PrescribedConditions"><code>PrescribedConditions</code></a> which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.</li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type <a href="#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.</li><li><code>point_masses = Dict{Int,PointMass{Float64}}()</code>: A dictionary with keys      corresponding to the points to which point masses are attached and values      of type <a href="#GXBeam.PointMass"><code>PointMass</code></a> which contain the properties of the attached      point masses.  If time varying, this input may be provided as a function of time.</li><li><code>linear_velocity = zeros(3)</code>: Prescribed linear velocity of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>angular_velocity = zeros(3)</code>: Prescribed angular velocity of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>linear_acceleration = zeros(3)</code>: Prescribed linear acceleration of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>angular_acceleration = zeros(3)</code>: Prescribed angular acceleration of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>gravity = [0,0,0]</code>: Gravity vector in the inertial frame.  If time varying, this input      may be provided as a function of time.</li><li><code>time = 0.0</code>: Current time or vector of times corresponding to each step. May be used      in conjunction with time varying prescribed conditions, distributed loads, and      body frame motion to gradually increase displacements and loads.</li></ul><p><strong>Control Flag Keyword Arguments</strong></p><ul><li><code>reset_state = true</code>: Flag indicating whether the system state variables should be      set to zero prior to performing this analysis.</li><li><code>initial_state = nothing</code>: Object of type <a href="#GXBeam.AssemblyState"><code>AssemblyState</code></a> which contains the      initial state variables.  If not provided (or set to <code>nothing</code>), then the state      variables stored in <code>system</code> (which default to zeros) will be used as the initial      state variables.</li><li><code>structural_damping = false</code>: Indicates whether to enable structural damping</li><li><code>linear = false</code>: Flag indicating whether a linear analysis should be performed.</li><li><code>two_dimensional = false</code>: Flag indicating whether to constrain results to the x-y plane</li><li><code>show_trace = false</code>: Flag indicating whether to display the solution progress.</li></ul><p><strong>Linear Analysis Keyword Arguments</strong></p><ul><li><code>update_linearization = false</code>: Flag indicating whether to update the linearization state      variables for a linear analysis with the instantaneous state variables. If <code>false</code>,      then the initial set of state variables will be used for the linearization.</li></ul><p><strong>Nonlinear Analysis Keyword Arguments</strong></p><ul><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to      solve the nonlinear system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving the nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li></ul><p><strong>Sensitivity Analysis Keyword Arguments</strong></p><ul><li><code>xpfunc = (x, p, t) -&gt; (;)</code>: Similar to <code>pfunc</code>, except that parameters can also be      defined as a function of GXBeam&#39;s state variables.  Using this function forces      the system jacobian to be computed using automatic differentiation and switches      the nonlinear solver to a Newton-Krylov solver (with linesearch).</li><li><code>pfunc = (p, t) -&gt; (;)</code>: Function which returns a named tuple with fields corresponding      to updated versions of the arguments <code>assembly</code>, <code>prescribed_conditions</code>,      <code>distributed_loads</code>, <code>point_masses</code>, <code>linear_velocity</code>, <code>angular_velocity</code>,      <code>linear_acceleration</code>, <code>angular_acceleration</code>, and <code>gravity</code>. Only fields contained      in the resulting named tuple will be overwritten.</li><li><code>p</code>: Sensitivity parameters, as defined in conjunction with the keyword argument <code>pfunc</code>.      While not necessary, using <code>pfunc</code> and <code>p</code> to define the arguments to this function      allows automatic differentiation sensitivities to be computed more efficiently</li></ul><p><strong>Eigenvalue Analysis Keyword Arguments</strong></p><ul><li><code>nev = 6</code>: Number of eigenvalues to compute</li><li><code>steady = reset_state &amp;&amp; !linear</code>: Flag indicating whether the steady state      solution should be found prior to performing the eigenvalue analysis.</li><li><code>left = false</code>: Flag indicating whether to return left and right eigenvectors rather      than just right eigenvectors.</li><li><code>Uprev = nothing</code>: Previous left eigenvector matrix.  May be provided in order to      reorder eigenvalues based on results from a previous iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L1142-L1226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.eigenvalue_analysis!" href="#GXBeam.eigenvalue_analysis!"><code>GXBeam.eigenvalue_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigenvalue_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <code>eigenvalue_analysis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L1238-L1242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_condition_analysis" href="#GXBeam.initial_condition_analysis"><code>GXBeam.initial_condition_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_condition_analysis(assembly, t0; kwargs...)</code></pre><p>Perform an analysis to obtain a consistent set of initial conditions.  Return the resulting system and a flag indicating whether the iteration procedure converged.</p><p><strong>General Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>:      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      <a href="#GXBeam.PrescribedConditions"><code>PrescribedConditions</code></a> which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.</li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type <a href="#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.</li><li><code>point_masses = Dict{Int,PointMass{Float64}}()</code>: A dictionary with keys      corresponding to the points to which point masses are attached and values      of type <a href="#GXBeam.PointMass"><code>PointMass</code></a> which contain the properties of the attached      point masses.  If time varying, this input may be provided as a function of time.</li><li><code>linear_velocity = zeros(3)</code>: Initial linear velocity of the body frame.</li><li><code>angular_velocity = zeros(3)</code>: Initial angular velocity of the body frame.</li><li><code>linear_acceleration = zeros(3)</code>: Initial linear acceleration of the body frame.</li><li><code>angular_acceleration = zeros(3)</code>: Initial angular acceleration of the body frame.</li><li><code>gravity = [0,0,0]</code>: Gravity vector in the inertial frame.</li></ul><p><strong>Control Flag Keyword Arguments</strong></p><ul><li><code>reset_state = true</code>: Flag indicating whether the system state variables should be      set to zero prior to performing this analysis.</li><li><code>initial_state = nothing</code>: Object of type <a href="#GXBeam.AssemblyState"><code>AssemblyState</code></a> which contains the      initial state variables.  If not provided (or set to <code>nothing</code>), then the state      variables stored in <code>system</code> (which default to zeros) will be used as the initial      state variables.</li><li><code>structural_damping = true</code>: Indicates whether to enable structural damping</li><li><code>linear = false</code>: Flag indicating whether a linear analysis should be performed.</li><li><code>two_dimensional = false</code>: Flag indicating whether to constrain results to the x-y plane</li><li><code>steady_state=false</code>: Flag indicating whether to initialize by performing a steady state      analysis.</li><li><code>show_trace = false</code>: Flag indicating whether to display the solution progress.</li></ul><p><strong>Initial Condition Analysis Keyword Arguments</strong></p><ul><li><code>u0 = fill(zeros(3), length(assembly.points))</code>: Initial linear displacement of      each point <strong>relative to the body frame</strong></li><li><code>theta0 = fill(zeros(3), length(assembly.points))</code>: Initial angular displacement of      each point <strong>relative to the body frame</strong> (using Wiener-Milenkovic Parameters)</li><li><code>V0 = fill(zeros(3), length(assembly.points))</code>: Initial linear velocity of      each point <strong>relative to the body frame</strong></li><li><code>Omega0 = fill(zeros(3), length(assembly.points))</code>: Initial angular velocity of      each point <strong>relative to the body frame</strong></li><li><code>Vdot0 = fill(zeros(3), length(assembly.points))</code>: Initial linear acceleration of      each point <strong>relative to the body frame</strong></li><li><code>Omegadot0 = fill(zeros(3), length(assembly.points))</code>: Initial angular acceleration of      each point <strong>relative to the body frame</strong></li></ul><p><strong>Linear Analysis Keyword Arguments</strong></p><ul><li><code>update_linearization = false</code>: Flag indicating whether to update the linearization state      variables for a linear analysis with the instantaneous state variables. If <code>false</code>,      then the initial set of state variables will be used for the linearization.</li></ul><p><strong>Nonlinear Analysis Keyword Arguments</strong></p><ul><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve the      nonlinear system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving the nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li></ul><p><strong>Sensitivity Analysis Keyword Arguments</strong></p><ul><li><code>xpfunc = (x, p, t) -&gt; (;)</code>: Similar to <code>pfunc</code>, except that parameters can also be      defined as a function of GXBeam&#39;s state variables.  Using this function forces      the system jacobian to be computed using automatic differentiation and switches      the nonlinear solver to a Newton-Krylov solver (with linesearch).</li><li><code>pfunc = (p, t) -&gt; (;)</code>: Function which returns a named tuple with fields corresponding      to updated versions of the arguments <code>assembly</code>, <code>prescribed_conditions</code>,      <code>distributed_loads</code>, <code>point_masses</code>, <code>linear_velocity</code>, <code>angular_velocity</code>,      <code>linear_acceleration</code>, <code>angular_acceleration</code>, <code>gravity</code>, <code>u0</code>, <code>theta0</code>, <code>V0</code>,      <code>Omega0</code>, <code>Vdot0</code>, and <code>Omegadot0</code>. Only fields contained in the resulting named      tuple will be overwritten.</li><li><code>p</code>: Sensitivity parameters, as defined in conjunction with the keyword argument <code>pfunc</code>.      While not necessary, using <code>pfunc</code> and <code>p</code> to define the arguments to this function      allows automatic differentiation sensitivities to be computed more efficiently</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L1594-L1676">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_condition_analysis!" href="#GXBeam.initial_condition_analysis!"><code>GXBeam.initial_condition_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_condition_analysis!(system, assembly, t0; kwargs...)</code></pre><p>Pre-allocated version of <code>initial_condition_analysis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L1688-L1692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.time_domain_analysis" href="#GXBeam.time_domain_analysis"><code>GXBeam.time_domain_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_domain_analysis(assembly, tvec; kwargs...)</code></pre><p>Perform a time-domain analysis for the system of nonlinear beams contained in <code>assembly</code> using the time vector <code>tvec</code>.  Return the final system, a post-processed solution history, and a convergence flag indicating whether the iteration procedure converged for every time step.</p><p><strong>General Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>:      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      <a href="#GXBeam.PrescribedConditions"><code>PrescribedConditions</code></a> which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.</li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type <a href="#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.</li><li><code>point_masses = Dict{Int,PointMass{Float64}}()</code>: A dictionary with keys      corresponding to the points to which point masses are attached and values      of type <a href="#GXBeam.PointMass"><code>PointMass</code></a> which contain the properties of the attached      point masses.  If time varying, this input may be provided as a function of time.</li><li><code>linear_velocity = zeros(3)</code>: Prescribed linear velocity of the body frame.</li><li><code>angular_velocity = zeros(3)</code>: Prescribed angular velocity of the body frame.</li><li><code>linear_acceleration = zeros(3)</code>: Initial linear acceleration of the body frame.</li><li><code>angular_acceleration = zeros(3)</code>: Initial angular acceleration of the body frame.</li><li><code>gravity = [0,0,0]</code>: Gravity vector in the body frame.  If time varying, this input      may be provided as a function of time.</li></ul><p><strong>Control Flag Keyword Arguments</strong></p><ul><li><code>reset_state = true</code>: Flag indicating whether the system state variables should be      set to zero prior to performing this analysis.</li><li><code>initial_state = nothing</code>: Object of type <code>AssemblyState</code>, which defines the initial      states and state rates corresponding to the analysis.  By default, this input is      calculated using either <code>steady_state_analysis</code> or <code>initial_condition_analysis</code>.</li><li><code>steady_state = false</code>: Flag indicating whether to compute the state variables      corresponding to the keyword argument <code>initial_state</code> using <code>steady_state_analysis</code>      (rather than <code>initial_condition_analysis</code>).</li><li><code>structural_damping = true</code>: Flag indicating whether to enable structural damping</li><li><code>linear = false</code>: Flag indicating whether a linear analysis should be performed.</li><li><code>two_dimensional = false</code>: Flag indicating whether to constrain results to the x-y plane</li><li><code>show_trace = false</code>: Flag indicating whether to display the solution progress.</li><li><code>save = eachindex(tvec)</code>: Steps at which to save the time history</li></ul><p><strong>Initial Condition Analysis Arguments</strong></p><ul><li><code>u0 = fill(zeros(3), length(assembly.points))</code>: Initial linear displacement of      each point in the body frame</li><li><code>theta0 = fill(zeros(3), length(assembly.points))</code>: Initial angular displacement of      each point in the body frame (using Wiener-Milenkovic Parameters)</li><li><code>V0 = fill(zeros(3), length(assembly.points))</code>: Initial linear velocity of      each point in the body frame <strong>excluding contributions from body frame motion</strong></li><li><code>Omega0 = fill(zeros(3), length(assembly.points))</code>: Initial angular velocity of      each point in the body frame <strong>excluding contributions from body frame motion</strong></li><li><code>Vdot0 = fill(zeros(3), length(assembly.points))</code>: Initial linear acceleration of      each point in the body frame <strong>excluding contributions from body frame motion</strong></li><li><code>Omegadot0 = fill(zeros(3), length(assembly.points))</code>: Initial angular acceleration of      each point in the body frame <strong>excluding contributions from body frame motion</strong></li></ul><p><strong>Linear Analysis Keyword Arguments</strong></p><ul><li><code>update_linearization = false</code>: Flag indicating whether to update the linearization state      variables for a linear analysis with the instantaneous state variables. If <code>false</code>,      then the initial set of state variables will be used for the linearization.</li></ul><p><strong>Nonlinear Analysis Keyword Arguments</strong></p><ul><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve      nonlinear systems of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving the nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li></ul><p><strong>Sensitivity Analysis Keyword Arguments</strong></p><ul><li><code>xpfunc = (x, p, t) -&gt; (;)</code>: Similar to <code>pfunc</code>, except that parameters can also be      defined as a function of GXBeam&#39;s state variables.  Using this function forces      the system jacobian to be computed using automatic differentiation and switches      the nonlinear solver to a Newton-Krylov solver (with linesearch).</li><li><code>pfunc = (p, t) -&gt; (;)</code>: Function which returns a named tuple with fields corresponding      to updated versions of the arguments <code>assembly</code>, <code>prescribed_conditions</code>,      <code>distributed_loads</code>, <code>point_masses</code>, <code>linear_velocity</code>, <code>angular_velocity</code>,      <code>linear_acceleration</code>, <code>angular_acceleration</code>, <code>gravity</code>, <code>u0</code>, <code>theta0</code>, <code>V0</code>,      <code>Omega0</code>, <code>Vdot0</code>, and <code>Omegadot0</code>. Only fields contained in the resulting named      tuple will be overwritten.</li><li><code>p</code>: Sensitivity parameters, as defined in conjunction with the keyword argument <code>pfunc</code>.      While not necessary, using <code>pfunc</code> and <code>p</code> to define the arguments to this function      allows automatic differentiation sensitivities to be computed more efficiently</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L2128-L2214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.time_domain_analysis!" href="#GXBeam.time_domain_analysis!"><code>GXBeam.time_domain_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_domain_analysis!(system, assembly, tvec; kwargs...)</code></pre><p>Pre-allocated version of <a href="#GXBeam.time_domain_analysis"><code>time_domain_analysis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L2222-L2226">source</a></section></article><h3 id="Post-Processing"><a class="docs-heading-anchor" href="#Post-Processing">Post-Processing</a><a id="Post-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Processing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.AssemblyState" href="#GXBeam.AssemblyState"><code>GXBeam.AssemblyState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AssemblyState{TF, TP&lt;:AbstractVector{PointState{TF}}, TE&lt;:AbstractVector{ElementState{TF}}}</code></pre><p>Struct for storing state variables for the points and elements in an assembly.</p><p><strong>Fields:</strong></p><ul><li><code>points::TP</code>: Array of <a href="#GXBeam.PointState"><code>PointState</code></a> for each point in the assembly</li><li><code>elements::TE</code>: Array of <a href="#GXBeam.ElementState"><code>ElementState</code></a> for each element in the assembly</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/output.jl#L73-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PointState" href="#GXBeam.PointState"><code>GXBeam.PointState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PointState</code></pre><p>Holds the state variables for a point</p><p><strong>Fields:</strong></p><ul><li><code>u</code>: Linear displacement</li><li><code>udot</code>: Linear displacement rate</li><li><code>theta</code>: Angular displacement (Wiener-Milenkovic parameters)</li><li><code>thetadot</code>: Angular displacement rate</li><li><code>V</code>: Linear velocity</li><li><code>Vdot</code>: Linear velocity rate</li><li><code>Omega</code>: Angular velocity</li><li><code>Omegadot</code>: Angular velocity rate</li><li><code>F</code>: External forces</li><li><code>M</code>: External moments</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/output.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.ElementState" href="#GXBeam.ElementState"><code>GXBeam.ElementState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementState</code></pre><p>Holds the state variables for an element</p><p><strong>Fields:</strong></p><ul><li><code>u</code>: Linear displacement</li><li><code>udot</code>: Linear displacement rate</li><li><code>theta</code>: Angular displacement (Wiener-Milenkovic parameters)</li><li><code>thetadot</code>: Angular displacement rate</li><li><code>V</code>: Linear velocity</li><li><code>Vdot</code>: Linear velocity rate</li><li><code>Omega</code>: Angular velocity</li><li><code>Omegadot</code>: Angular velocity rate</li><li><code>Fi</code>: Internal forces</li><li><code>Mi</code>: Internal moments</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/output.jl#L37-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.AssemblyState-Tuple{Any, Any}" href="#GXBeam.AssemblyState-Tuple{Any, Any}"><code>GXBeam.AssemblyState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AssemblyState(system, assembly; prescribed_conditions = Dict())
AssemblyState(x, system, assembly; prescribed_conditions = Dict())
AssemblyState(dx, x, system, assembly; prescribed_conditions = Dict())</code></pre><p>Post-process the system state given the state vector <code>x</code> and rate vector <code>dx</code>.  Return an object of type <code>AssemblyState</code> that defines the state of the assembly for the time step.</p><p>If <code>prescribed_conditions</code> is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/output.jl#L94-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.extract_element_state" href="#GXBeam.extract_element_state"><code>GXBeam.extract_element_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_element_state(system, assembly, ielem; prescribed_conditions = Dict())
extract_element_state(x, system, assembly, ielem; prescribed_conditions = Dict())
extract_element_state(dx, x, system, assembly, ielem; prescribed_conditions = Dict())</code></pre><p>Return the state variables corresponding to element <code>ielem</code> (see <a href="#GXBeam.ElementState"><code>ElementState</code></a>) given the state vector <code>x</code> and rate vector <code>dx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/output.jl#L290-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.extract_element_states" href="#GXBeam.extract_element_states"><code>GXBeam.extract_element_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_element_states(system, assembly, x = system.x, dx = system.dx;
    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())</code></pre><p>Return the state variables corresponding to each element (see <a href="#GXBeam.ElementState"><code>ElementState</code></a>) given the solution vector <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/output.jl#L466-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.extract_point_state" href="#GXBeam.extract_point_state"><code>GXBeam.extract_point_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_point_state(system, assembly, ipoint; prescribed_conditions = Dict())
extract_point_state(x, system, assembly, ipoint; prescribed_conditions = Dict())
extract_point_state(dx, x, system, assembly, ipoint; prescribed_conditions = Dict())</code></pre><p>Return the state variables corresponding to point <code>ipoint</code> (see <a href="#GXBeam.PointState"><code>PointState</code></a>) given the state vector <code>x</code> and rate vector <code>dx</code>.</p><p>If <code>prescribed_conditions</code> is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/output.jl#L115-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.extract_point_states" href="#GXBeam.extract_point_states"><code>GXBeam.extract_point_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_point_states(system, assembly; prescribed_conditions = Dict())
extract_point_states(x, system, assembly; prescribed_conditions = Dict())
extract_point_states(dx, x, system, assembly; prescribed_conditions = Dict())</code></pre><p>Return the state variables corresponding to each point (see <a href="#GXBeam.PointState"><code>PointState</code></a>) given the state vector <code>x</code> and rate vector <code>dx</code>.</p><p>If <code>prescribed_conditions</code> is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/output.jl#L249-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.linearize!" href="#GXBeam.linearize!"><code>GXBeam.linearize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linearize!(system, assembly; kwargs...)</code></pre><p>Return the state variables, jacobian matrix, and mass matrix of a linearized system using the current system state vector.</p><p><strong>General Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>:      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      <a href="#GXBeam.PrescribedConditions"><code>PrescribedConditions</code></a> which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.</li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type <a href="#GXBeam.DistributedLoads"><code>DistributedLoads</code></a> which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.</li><li><code>point_masses = Dict{Int,PointMass{Float64}}()</code>: A dictionary with keys      corresponding to the points to which point masses are attached and values      of type <a href="#GXBeam.PointMass"><code>PointMass</code></a> which contain the properties of the attached      point masses.  If time varying, this input may be provided as a function of time.</li><li><code>linear_velocity = zeros(3)</code>: Prescribed linear velocity of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>angular_velocity = zeros(3)</code>: Prescribed angular velocity of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>linear_acceleration = zeros(3)</code>: Prescribed linear acceleration of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>angular_acceleration = zeros(3)</code>: Prescribed angular acceleration of the body frame.      If time varying, this input may be provided as a function of time.</li><li><code>gravity = [0,0,0]</code>: Gravity vector in the inertial frame.  If time varying, this input      may be provided as a function of time.</li><li><code>time = 0.0</code>: Current time or vector of times corresponding to each step. May be used      in conjunction with time varying prescribed conditions, distributed loads, and      body frame motion to gradually increase displacements and loads.</li></ul><p><strong>Control Flag Keyword Arguments</strong></p><ul><li><code>reset_state = true</code>: Flag indicating whether the system state variables should be       set to zero prior to performing this analysis.</li><li><code>initial_state = nothing</code>: Object of type <a href="#GXBeam.AssemblyState"><code>AssemblyState</code></a> which contains the       initial state variables.  If not provided (or set to <code>nothing</code>), then the state       variables stored in <code>system</code> (which default to zeros) will be used as the initial       state variables.</li><li><code>structural_damping = false</code>: Indicates whether to enable structural damping</li><li><code>linear = false</code>: Flag indicating whether a linear analysis should be performed.</li><li><code>two_dimensional = false</code>: Flag indicating whether to constrain results to the x-y plane</li><li><code>show_trace = false</code>: Flag indicating whether to display the solution progress.</li></ul><p><strong>Sensitivity Analysis Keyword Arguments</strong></p><ul><li><code>xpfunc = (x, p, t) -&gt; (;)</code>: Similar to <code>pfunc</code>, except that parameters can also be     defined as a function of GXBeam&#39;s state variables.  Using this function forces     the system jacobian to be computed using automatic differentiation and switches     the nonlinear solver to a Newton-Krylov solver (with linesearch).</li><li><code>pfunc = (p, t) -&gt; (;)</code>: Function which returns a named tuple with fields corresponding     to updated versions of the arguments <code>assembly</code>, <code>prescribed_conditions</code>,     <code>distributed_loads</code>, <code>point_masses</code>, <code>linear_velocity</code>, <code>angular_velocity</code>,     <code>linear_acceleration</code>, <code>angular_acceleration</code>, and <code>gravity</code>. Only fields contained     in the resulting named tuple will be overwritten.</li><li><code>p</code>: Sensitivity parameters, as defined in conjunction with the keyword argument <code>pfunc</code>.     While not necessary, using <code>pfunc</code> and <code>p</code> to define the arguments to this function     allows automatic differentiation sensitivities to be computed more efficiently</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L775-L836">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.solve_eigensystem" href="#GXBeam.solve_eigensystem"><code>GXBeam.solve_eigensystem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve_eigensystem(x, K, M, nev)</code></pre><p>Return the eigenvalues and eigenvectors of a linearized system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L939-L943">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.left_eigenvectors" href="#GXBeam.left_eigenvectors"><code>GXBeam.left_eigenvectors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">left_eigenvectors(system, λ, V)
left_eigenvectors(K, M, λ, V)</code></pre><p>Compute the left eigenvector matrix <code>U</code> for the <code>system</code> using inverse power iteration given the eigenvalues <code>λ</code> and the corresponding right eigenvector matrix <code>V</code>.</p><p>The complex conjugate of each left eigenvector is stored in each row of the matrix <code>U</code></p><p>Left and right eigenvectors satisfy the following M-orthogonality condition:</p><ul><li>u&#39;<em>M</em>v = 1 if u and v correspond to the same eigenvalue</li><li>u&#39;<em>M</em>v = 0 if u and v correspond to different eigenvalues</li></ul><p>This means that U<em>M</em>V = I</p><p>This function assumes that <code>system</code> has not been modified since the eigenvalues and right eigenvectors were computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L968-L986">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.correlate_eigenmodes" href="#GXBeam.correlate_eigenmodes"><code>GXBeam.correlate_eigenmodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">correlate_eigenmodes(C)</code></pre><p>Return the permutation and the associated corruption index vector which associates eigenmodes from the current iteration with those of the previous iteration given the correlation matrix <code>C</code>.</p><p>The correlation matrix can take one of the following forms (in order of preference):</p><ul><li><code>C = U_p*M*V</code></li><li><code>C = U*M_p*V_p</code></li><li><code>C = V_p&#39;*V</code></li><li><code>C = V&#39;*V_p</code></li></ul><p>where <code>U</code> is a matrix of conjugated left eigenvectors, <code>M</code> is the system mass matrix, <code>V</code> is a matrix of right eigenvectors, and <code>()_p</code> indicates a variable from the previous iteration.</p><p>Note that the following two forms of the correlation matrix seem to be significantly inferior to their counterparts listed above: <code>C = U*M*V_p</code> and <code>C = U_p*M_p*V</code>. This is likely due to the way in which the left eigenvector matrix is calculated.</p><p>The corruption index is the largest magnitude in a given row of <code>C</code> that was not chosen divided by the magnitude of the chosen eigenmode.  It is most meaningful when using one of the forms of the correlation matrix that uses left eigenvectors since correct eigenmodes will have magnitudes close to 1 and incorrect eigenmodes will have magnitudes close to 0.</p><p>If the new mode number is already assigned, the next highest unassigned mode number is used.  In this case a corruption index higher than 1 will be returned, otherwise the values of the corruption index will always be bounded by 0 and 1.</p><p>See &quot;New Mode Tracking Methods in Aeroelastic Analysis&quot; by Eldred, Vankayya, and Anderson.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/analyses.jl#L1082-L1114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.wiener_milenkovic" href="#GXBeam.wiener_milenkovic"><code>GXBeam.wiener_milenkovic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wiener_milenkovic(c)</code></pre><p>Construct a Wiener-Milenkovic transformation matrix, given the three Wiener-Milenkovic parameters in <code>c</code>.</p><p>Note that the corresponding rotation matrix is the transpose of this transformation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L15-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.rotate" href="#GXBeam.rotate"><code>GXBeam.rotate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotate(xyz, r, theta)</code></pre><p>Rotate the vectors in <code>xyz</code> about point <code>r</code> using the Wiener-Milenkovic parameters in <code>theta</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L345-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.rotate!" href="#GXBeam.rotate!"><code>GXBeam.rotate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotate!(xyz, r, theta)</code></pre><p>Pre-allocated version of <a href="#GXBeam.rotate"><code>rotate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L353-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.translate" href="#GXBeam.translate"><code>GXBeam.translate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">translate(xyz, u)</code></pre><p>Translate the points in <code>xyz</code> by the displacements in <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L375-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.translate!" href="#GXBeam.translate!"><code>GXBeam.translate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">translate!(xyz, u)</code></pre><p>Pre-allocated version of <a href="#GXBeam.translate"><code>translate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L382-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.deform_cross_section" href="#GXBeam.deform_cross_section"><code>GXBeam.deform_cross_section</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deform_cross_section(xyz, r, u, theta)</code></pre><p>Rotate the points in <code>xyz</code> (of shape (3, :)) about point <code>r</code> using the Wiener-Milenkovic parameters in <code>theta</code>, then translate the points by the displacements in <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L401-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.deform_cross_section!" href="#GXBeam.deform_cross_section!"><code>GXBeam.deform_cross_section!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deform_cross_section!(xyz, r, u, theta)</code></pre><p>Pre-allocated version of <a href="#GXBeam.deform_cross_section"><code>deform_cross_section</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L410-L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.write_vtk" href="#GXBeam.write_vtk"><code>GXBeam.write_vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_vtk(name, assembly::Assembly; kwargs...)
write_vtk(name, assembly::Assembly, state::AssemblyState; kwargs...)
write_vtk(name, assembly::Assembly, history::Vector{&lt;:AssemblyState}], dt;
    kwargs...)</code></pre><p>Write the deformed geometry (and associated data) to a VTK file for visualization using ParaView.</p><p>The <code>state</code> argument may be omitted to write the original geometry to a VTK file without any associated data.</p><p>If the solution time <code>history</code> is provided, the time step must also be provided</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sections = nothing</code>: Cross section geometry corresponding to each point,  defined in a frame aligned with the body frame but centered around the  corresponding point. Defined as an array with shape <code>(3, ncross, np)</code> where <code>ncross</code>  is the number of points in each cross section and <code>np</code> is the number of points.</li><li><code>scaling=1.0</code>: Parameter to scale the deflections (only valid if state is provided)</li><li><code>metadata=Dict()</code>: Dictionary of metadata for the file(s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/interfaces/writevtk.jl#L1-L22">source</a></section><section><div><pre><code class="nohighlight hljs">write_vtk(name, assembly::Assembly, [state::AssemblyState, ]λ::Number,
    eigenstate::AssemblyState; scaling=1.0, mode_scaling=1.0, cycles=1,
    steps=100)</code></pre><p>Write a series of files corresponding to the elastic motion of the <code>assembly</code> about the deformed state encoded in <code>state</code> defined by the eigenvalue <code>λ</code> and the eigenvector encoded in <code>eigenstate</code> over the time period specified by <code>time</code>.</p><p>The steady-state deflections can be scaled with <code>scaling</code> and the eigenmode deflections can be scaled using <code>mode_scaling</code>.</p><p>The current time is encoded in the metadata tag &quot;time&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/interfaces/writevtk.jl#L317-L330">source</a></section></article><h2 id="Private-API"><a class="docs-heading-anchor" href="#Private-API">Private API</a><a id="Private-API-1"></a><a class="docs-heading-anchor-permalink" href="#Private-API" title="Permalink"></a></h2><h3 id="Math"><a class="docs-heading-anchor" href="#Math">Math</a><a id="Math-1"></a><a class="docs-heading-anchor-permalink" href="#Math" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.tilde" href="#GXBeam.tilde"><code>GXBeam.tilde</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tilde(x)</code></pre><p>Construct the cross product operator matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.transform_properties" href="#GXBeam.transform_properties"><code>GXBeam.transform_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_properties(K, T)</code></pre><p>Applies the transformation <code>T</code> to the stiffness or mass matrix <code>K</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.rotation_parameter_scaling" href="#GXBeam.rotation_parameter_scaling"><code>GXBeam.rotation_parameter_scaling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_parameter_scaling(θ)</code></pre><p>Extract a scaling parameter which may be multiplied by the angular parameters to yield the Wiener-Milenkovic rotation parameters.  Use of this scaling parameter allows deflections greater than 360 degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_C" href="#GXBeam.get_C"><code>GXBeam.get_C</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_C(θ)</code></pre><p>Returns the transformation matrix <code>C</code> given the three angular parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_C_θ" href="#GXBeam.get_C_θ"><code>GXBeam.get_C_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_C_θ([C, ] θ)</code></pre><p>Calculate the derivative of the Wiener-Milenkovic transformation matrix <code>C</code> with respect to each of the rotation parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Q" href="#GXBeam.get_Q"><code>GXBeam.get_Q</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Q(θ)</code></pre><p>Calculate the matrix Q as defined in the paper &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu given the rotational parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L153-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Q_θ" href="#GXBeam.get_Q_θ"><code>GXBeam.get_Q_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Q_θ(θ)
get_Q_θ(Q, θ)</code></pre><p>Calculate the derivative of the matrix <code>Q</code> with respect to each of the rotation parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L171-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Qinv" href="#GXBeam.get_Qinv"><code>GXBeam.get_Qinv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Qinv(θ)</code></pre><p>Calculate the matrix inverse <code>Qinv</code> as defined in the paper &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu given the rotational parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L282-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Qinv_θ" href="#GXBeam.get_Qinv_θ"><code>GXBeam.get_Qinv_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Qinv_θ(θ)</code></pre><p>Calculate the derivative of the matrix inverse <code>Qinv</code> with respect to each of the rotation parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L300-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_ΔQ" href="#GXBeam.get_ΔQ"><code>GXBeam.get_ΔQ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_ΔQ(θ, Δθ [, Q])</code></pre><p>Calculate the matrix <code>ΔQ</code> for structural damping calculations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_ΔQ_θ" href="#GXBeam.get_ΔQ_θ"><code>GXBeam.get_ΔQ_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_ΔQ_θ(θ, Δθ, [Q, Q_θ1, Q_θ2, Q_θ3])</code></pre><p>Calculate the derivative of the matrix <code>ΔQ</code> with respect to each of the rotation parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L233-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.mul3" href="#GXBeam.mul3"><code>GXBeam.mul3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul3(A_1, A_2, A_3, b)</code></pre><p>Return the product of a 3x3x3 tensor represented by <code>A_1</code>, <code>A_2</code>, and <code>A_3</code> with the vector <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L325-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.gauss_quadrature" href="#GXBeam.gauss_quadrature"><code>GXBeam.gauss_quadrature</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gauss_quadrature(f, a, b)</code></pre><p>Default gauss-quadrature function used for integrating distributed loads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/math.jl#L333-L337">source</a></section></article><h3 id="Body-Frame"><a class="docs-heading-anchor" href="#Body-Frame">Body Frame</a><a id="Body-Frame-1"></a><a class="docs-heading-anchor-permalink" href="#Body-Frame" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.update_body_acceleration_indices!" href="#GXBeam.update_body_acceleration_indices!"><code>GXBeam.update_body_acceleration_indices!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_body_acceleration_indices!(system, prescribed_conditions)
update_body_acceleration_indices!(indices, prescribed_conditions)</code></pre><p>Updates the state variable indices corresponding to the body frame accelerations to correspond to the provided prescribed conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L124-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.body_accelerations" href="#GXBeam.body_accelerations"><code>GXBeam.body_accelerations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">body_accelerations(system, x=system.x; linear_acceleration=zeros(3), angular_acceleration=zeros(3))</code></pre><p>Extract the linear and angular acceleration of the body frame from the state vector, if applicable.  Otherwise return the provided linear and angular acceleration.  This function is applicable only for steady state and initial condition analyses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L152-L158">source</a></section></article><h3 id="Points"><a class="docs-heading-anchor" href="#Points">Points</a><a id="Points-1"></a><a class="docs-heading-anchor-permalink" href="#Points" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_loads" href="#GXBeam.point_loads"><code>GXBeam.point_loads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_loads(x, ipoint, icol, force_scaling, prescribed_conditions)</code></pre><p>Extract the loads <code>F</code> and <code>M</code> of point <code>ipoint</code> from the state variable vector or prescribed conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_load_jacobians" href="#GXBeam.point_load_jacobians"><code>GXBeam.point_load_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_load_jacobians(x, ipoint, icol, force_scaling, prescribed_conditions)</code></pre><p>Calculate the load jacobians <code>F_θ</code>, <code>F_F</code>, <code>M_θ</code>, and <code>M_M</code> of point <code>ipoint</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_displacement" href="#GXBeam.point_displacement"><code>GXBeam.point_displacement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_displacement(x, ipoint, icol_point, prescribed_conditions)</code></pre><p>Extract the displacements <code>u</code> and <code>θ</code> of point <code>ipoint</code> from the state variable vector or prescribed conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_displacement_jacobians" href="#GXBeam.point_displacement_jacobians"><code>GXBeam.point_displacement_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_displacement_jacobians(ipoint, prescribed_conditions)</code></pre><p>Calculate the displacement jacobians <code>u_u</code> and <code>θ_θ</code> of point <code>ipoint</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_displacement_rates" href="#GXBeam.point_displacement_rates"><code>GXBeam.point_displacement_rates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_displacement_rates(dx, ipoint, icol, prescribed_conditions)</code></pre><p>Extract the displacement rates <code>udot</code> and <code>θdot</code> of point <code>ipoint</code> from the rate variable vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_velocities" href="#GXBeam.point_velocities"><code>GXBeam.point_velocities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_velocities(x, ipoint, icol_point)</code></pre><p>Extract the velocities <code>V</code> and <code>Ω</code> of point <code>ipoint</code> from the state variable vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_point_displacement" href="#GXBeam.initial_point_displacement"><code>GXBeam.initial_point_displacement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_point_displacement(x, ipoint, icol_point, prescribed_conditions,
    rate_vars)</code></pre><p>Extract the displacements <code>u</code> and <code>θ</code> of point <code>ipoint</code> from the state variable vector or prescribed conditions for an initial condition analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L298-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_point_velocity_rates" href="#GXBeam.initial_point_velocity_rates"><code>GXBeam.initial_point_velocity_rates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_point_velocity_rates(x, ipoint, icol_point, prescribed_conditions,
    Vdot0, Ωdot0, rate_vars)</code></pre><p>Extract the velocity rates <code>Vdot</code> and <code>Ωdot</code> of point <code>ipoint</code> from the state variable vector or provided initial conditions.  Note that <code>Vdot</code> and <code>Ωdot</code> in this case do not include any contributions resulting from body frame motion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L440-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_point_displacement_jacobian" href="#GXBeam.initial_point_displacement_jacobian"><code>GXBeam.initial_point_displacement_jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_point_displacement_jacobian(ipoint, icol_point, prescribed_conditions,
    rate_vars)</code></pre><p>Extract the displacement jacobians <code>u_u</code> and <code>θ_θ</code> of point <code>ipoint</code> from the state variable vector or prescribed conditions for an initial condition analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L367-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_point_velocity_rate_jacobian" href="#GXBeam.initial_point_velocity_rate_jacobian"><code>GXBeam.initial_point_velocity_rate_jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_point_velocity_rate_jacobian(ipoint, icol_point, prescribed_conditions,
    rate_vars)</code></pre><p>Return the velocity rate jacobians <code>Vdot_Vdot</code> and <code>Ωdot_Ωdot</code> of point <code>ipoint</code>.  Note that <code>Vdot</code> and <code>Ωdot</code> in this case do not include any contributions resulting from body frame motion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L514-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_point_properties" href="#GXBeam.static_point_properties"><code>GXBeam.static_point_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_point_properties(x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity)</code></pre><p>Calculate/extract the point properties needed to construct the residual for a static analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L588-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_point_properties" href="#GXBeam.steady_point_properties"><code>GXBeam.steady_point_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_point_properties(x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity,
    linear_acceleration=(@SVector zeros(3)), angular_acceleration=(@SVector zeros(3)))</code></pre><p>Calculate/extract the point properties needed to construct the residual for a steady state analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L622-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_point_properties" href="#GXBeam.initial_point_properties"><code>GXBeam.initial_point_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_point_properties(x, indices, rate_vars, force_scaling,
    assembly, ipoint, prescribed_conditions, point_masses, gravity,
    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration,
    u0, θ0, V0, Ω0, Vdot0, Ωdot0)</code></pre><p>Calculate/extract the point properties needed to construct the residual for a time domain analysis initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L674-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_point_properties" href="#GXBeam.newmark_point_properties"><code>GXBeam.newmark_point_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_point_properties(x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity,
    udot_init, θdot_init, Vdot_init, Ωdot_init, dt)</code></pre><p>Calculate/extract the point properties needed to construct the residual for a newmark-scheme time stepping analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L758-L765">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_point_properties" href="#GXBeam.dynamic_point_properties"><code>GXBeam.dynamic_point_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_point_properties(dx, x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity)</code></pre><p>Calculate/extract the point properties needed to construct the residual for a dynamic analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L797-L803">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_point_properties" href="#GXBeam.expanded_steady_point_properties"><code>GXBeam.expanded_steady_point_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_steady_point_properties(x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity,
    linear_acceleration=(@SVector zeros(3)), angular_acceleration=(@SVector zeros(3)))</code></pre><p>Calculate/extract the point properties needed to construct the residual for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L832-L839">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_point_properties" href="#GXBeam.expanded_dynamic_point_properties"><code>GXBeam.expanded_dynamic_point_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_point_properties(dx, x, indices, force_scaling, assembly,
    ipoint, prescribed_conditions, point_masses, gravity, linear_velocity,
    angular_velocity)</code></pre><p>Calculate/extract the point properties needed to construct the residual for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L902-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_velocity_residuals" href="#GXBeam.point_velocity_residuals"><code>GXBeam.point_velocity_residuals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_velocity_residuals(properties)</code></pre><p>Calculate the velocity residuals <code>rV</code> and <code>rΩ</code> for a point for a steady state analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1652-L1656">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_point_velocity_residuals" href="#GXBeam.expanded_point_velocity_residuals"><code>GXBeam.expanded_point_velocity_residuals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_point_velocity_residuals(properties)</code></pre><p>Calculate the velocity residuals <code>rV</code> and <code>rΩ</code> for a point for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1667-L1672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_point_resultants" href="#GXBeam.static_point_resultants"><code>GXBeam.static_point_resultants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_point_resultants(properties)</code></pre><p>Calculate the net loads <code>F</code> and <code>M</code> applied at a point for a static analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1417-L1421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_point_resultants" href="#GXBeam.dynamic_point_resultants"><code>GXBeam.dynamic_point_resultants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_point_resultants(properties)</code></pre><p>Calculate the net loads <code>F</code> and <code>M</code> applied at a point for a steady analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1433-L1437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_point_resultants" href="#GXBeam.expanded_point_resultants"><code>GXBeam.expanded_point_resultants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_point_resultants(properties)</code></pre><p>Calculate the net loads <code>F</code> and <code>M</code> applied at a point for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1451-L1455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_point_residual!" href="#GXBeam.static_point_residual!"><code>GXBeam.static_point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_point_residual!(resid, x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity)</code></pre><p>Calculate and insert the residual entries corresponding to a point for a static analysis into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2105-L2111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_point_residual!" href="#GXBeam.steady_point_residual!"><code>GXBeam.steady_point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_point_residual!(resid, x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity,
    linear_acceleration, angular_acceleration)</code></pre><p>Calculate and insert the residual entries corresponding to a point for a steady state analysis into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2128-L2135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_point_residual!" href="#GXBeam.initial_point_residual!"><code>GXBeam.initial_point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_point_residual!(resid, x, indices, rate_vars,
    force_scaling, assembly, ipoint, prescribed_conditions, point_masses, gravity,
    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration,
    u0, θ0, V0, Ω0, Vdot0, Ωdot0)</code></pre><p>Calculate and insert the residual entries corresponding to a point for the initialization of a time domain analysis into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2158-L2166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_point_residual!" href="#GXBeam.newmark_point_residual!"><code>GXBeam.newmark_point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_point_residual!(resid, x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity,
    udot_init, θdot_init, Vdot_init, Ωdot_init, dt)</code></pre><p>Calculate and insert the residual entries corresponding to a point for a newmark-scheme time marching analysis into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2191-L2198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_point_residual!" href="#GXBeam.dynamic_point_residual!"><code>GXBeam.dynamic_point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_point_residual!(resid, dx, x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity)</code></pre><p>Calculate and insert the residual entries corresponding to a point for a dynamic analysis into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2221-L2227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_point_residual!" href="#GXBeam.expanded_steady_point_residual!"><code>GXBeam.expanded_steady_point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_steady_point_residual!(resid, x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity,
    linear_acceleration, angular_acceleration)</code></pre><p>Calculate and insert the residual entries corresponding to a point into the system residual vector for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2248-L2255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_point_residual!" href="#GXBeam.expanded_dynamic_point_residual!"><code>GXBeam.expanded_dynamic_point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_point_residual!(resid, dx, x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity)</code></pre><p>Calculate and insert the residual entries corresponding to a point into the system residual vector for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2282-L2288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_point_jacobian_properties" href="#GXBeam.static_point_jacobian_properties"><code>GXBeam.static_point_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_point_jacobian_properties(properties, x, indices, force_scaling, assembly,
    ipoint, prescribed_conditions, point_masses, gravity)</code></pre><p>Calculate/extract the point properties needed to calculate the jacobian entries corresponding to a point for a static analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L931-L937">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_point_jacobian_properties" href="#GXBeam.steady_point_jacobian_properties"><code>GXBeam.steady_point_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_point_jacobian_properties(properties, x, indices, force_scaling,
    assembly, ipoint, prescribed_conditions, point_masses, gravity,
    ub_ub, θb_θb, vb_vb, ωb_ωb, ab_ab, αb_αb)</code></pre><p>Calculate/extract the point properties needed to calculate the jacobian entries corresponding to a point for a steady state analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L956-L963">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_point_jacobian_properties" href="#GXBeam.initial_point_jacobian_properties"><code>GXBeam.initial_point_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_point_jacobian_properties(properties, x, indices, rate_vars,
    force_scaling, assembly, ipoint, prescribed_conditions, point_masses, gravity,
    u0, θ0, V0, Ω0, Vdot0, Ωdot0)</code></pre><p>Calculate/extract the point properties needed to calculate the jacobian entries corresponding to a point for a Newmark scheme time marching analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1025-L1032">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_point_jacobian_properties" href="#GXBeam.newmark_point_jacobian_properties"><code>GXBeam.newmark_point_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_point_jacobian_properties(properties, x, indices, force_scaling,
    assembly, ipoint, prescribed_conditions, point_masses, gravity,
    udot_init, θdot_init, Vdot_init, Ωdot_init, dt)</code></pre><p>Calculate/extract the point properties needed to calculate the jacobian entries corresponding to a point for a Newmark scheme time marching analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1126-L1133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_point_jacobian_properties" href="#GXBeam.dynamic_point_jacobian_properties"><code>GXBeam.dynamic_point_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_point_jacobian_properties(properties, dx, x, indices, force_scaling,
    assembly, ipoint, prescribed_conditions, point_masses, gravity)</code></pre><p>Calculate/extract the point properties needed to calculate the jacobian entries corresponding to a point for a dynamic analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1202-L1208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_point_jacobian_properties" href="#GXBeam.expanded_steady_point_jacobian_properties"><code>GXBeam.expanded_steady_point_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_steady_point_jacobian_properties(properties, x, indices, force_scaling,
    assembly, ipoint, prescribed_conditions, point_masses, gravity)</code></pre><p>Calculate/extract the point properties needed to calculate the jacobian entries corresponding to a point for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1263-L1269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_point_jacobian_properties" href="#GXBeam.expanded_dynamic_point_jacobian_properties"><code>GXBeam.expanded_dynamic_point_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_point_jacobian_properties(properties, dx, x, indices, force_scaling,
    assembly, ipoint, prescribed_conditions, point_masses, gravity)</code></pre><p>Calculate/extract the point properties needed to calculate the jacobian entries corresponding to a point for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1328-L1334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.mass_matrix_point_jacobian_properties" href="#GXBeam.mass_matrix_point_jacobian_properties"><code>GXBeam.mass_matrix_point_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mass_matrix_point_jacobian_properties(x, indices, force_scaling,
    assembly, ipoint, prescribed_conditions, point_masses)</code></pre><p>Calculate/extract the point properties needed to calculate the mass matrix jacobian entries corresponding to a point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1349-L1355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_mass_matrix_point_jacobian_properties" href="#GXBeam.expanded_mass_matrix_point_jacobian_properties"><code>GXBeam.expanded_mass_matrix_point_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_mass_matrix_point_jacobian_properties(assembly, ipoint, prescribed_conditions, point_masses)</code></pre><p>Calculate/extract the point properties needed to calculate the mass matrix jacobian entries corresponding to a point for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1386-L1391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_point_resultant_jacobians" href="#GXBeam.static_point_resultant_jacobians"><code>GXBeam.static_point_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_point_resultant_jacobians(properties)</code></pre><p>Calculate the jacobians for the net loads <code>F</code> and <code>M</code> applied at a point for a static analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1471-L1475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_point_resultant_jacobians" href="#GXBeam.steady_point_resultant_jacobians"><code>GXBeam.steady_point_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_point_resultant_jacobians(properties)</code></pre><p>Calculate the jacobians for the net loads <code>F</code> and <code>M</code> applied at a point for a steady state analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1489-L1494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_point_resultant_jacobians" href="#GXBeam.initial_point_resultant_jacobians"><code>GXBeam.initial_point_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_point_resultant_jacobians(properties)</code></pre><p>Calculate the jacobians for the net loads <code>F</code> and <code>M</code> applied at a point for the initialization of a time domain analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1542-L1547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_point_resultant_jacobians" href="#GXBeam.dynamic_point_resultant_jacobians"><code>GXBeam.dynamic_point_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_point_resultant_jacobians(properties)</code></pre><p>Calculate the jacobians for the net loads <code>F</code> and <code>M</code> applied at a point for a dynamic analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1511-L1516">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_point_resultant_jacobians" href="#GXBeam.expanded_steady_point_resultant_jacobians"><code>GXBeam.expanded_steady_point_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_steady_point_resultant_jacobians(properties)</code></pre><p>Calculate the jacobians for the net loads <code>F</code> and <code>M</code> applied at a point for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1598-L1603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_point_resultant_jacobians" href="#GXBeam.expanded_dynamic_point_resultant_jacobians"><code>GXBeam.expanded_dynamic_point_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_point_resultant_jacobians(properties)</code></pre><p>Calculate the jacobians for the net loads <code>F</code> and <code>M</code> applied at a point for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1619-L1624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.mass_matrix_point_resultant_jacobians" href="#GXBeam.mass_matrix_point_resultant_jacobians"><code>GXBeam.mass_matrix_point_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mass_matrix_point_resultant_jacobians(properties)</code></pre><p>Calculate the mass matrix jacobians for the net loads <code>F</code> and <code>M</code> applied at a point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1580-L1584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_point_velocity_jacobians" href="#GXBeam.initial_point_velocity_jacobians"><code>GXBeam.initial_point_velocity_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_point_velocity_jacobians(properties)</code></pre><p>Calculate the jacobians of the velocity residuals <code>rV</code> and <code>rΩ</code> of a point for the initialization of a time domain analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1683-L1688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_point_velocity_jacobians" href="#GXBeam.newmark_point_velocity_jacobians"><code>GXBeam.newmark_point_velocity_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_point_velocity_jacobians(properties)</code></pre><p>Calculate the jacobians of the velocity residuals <code>rV</code> and <code>rΩ</code> of a point for a Newmark scheme time-marching analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1701-L1706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_point_velocity_jacobians" href="#GXBeam.dynamic_point_velocity_jacobians"><code>GXBeam.dynamic_point_velocity_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_point_velocity_jacobians(properties)</code></pre><p>Calculate the jacobians of the velocity residuals <code>rV</code> and <code>rΩ</code> of a point for a dynamic state analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1721-L1726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_point_velocity_jacobians" href="#GXBeam.expanded_point_velocity_jacobians"><code>GXBeam.expanded_point_velocity_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_point_velocity_jacobians(properties)</code></pre><p>Calculate the jacobians of the velocity residuals <code>rV</code> and <code>rΩ</code> of a point for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1755-L1760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.mass_matrix_point_velocity_jacobians" href="#GXBeam.mass_matrix_point_velocity_jacobians"><code>GXBeam.mass_matrix_point_velocity_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mass_matrix_point_velocity_jacobians(properties)</code></pre><p>Calculate the mass matrix jacobians of the velocity residuals <code>rV</code> and <code>rΩ</code> of a point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1740-L1744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_static_point_jacobians!" href="#GXBeam.insert_static_point_jacobians!"><code>GXBeam.insert_static_point_jacobians!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_static_point_jacobians!(jacob, indices, force_scaling, ipoint, properties,
    resultants)</code></pre><p>Insert the jacobian entries corresponding to a point for a static analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1777-L1783">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_initial_point_jacobians!" href="#GXBeam.insert_initial_point_jacobians!"><code>GXBeam.insert_initial_point_jacobians!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_initial_point_jacobians!(jacob, indices, force_scaling, ipoint, properties,
    resultants, velocities)</code></pre><p>Insert the jacobian entries corresponding to a point for the initialization of a time domain analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1845-L1851">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_dynamic_point_jacobians!" href="#GXBeam.insert_dynamic_point_jacobians!"><code>GXBeam.insert_dynamic_point_jacobians!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_dynamic_point_jacobians!(jacob, indices, force_scaling, ipoint,
    properties, resultants, velocities)</code></pre><p>Insert the jacobian entries corresponding to a point for a steady state analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1899-L1905">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_expanded_steady_point_jacobians!" href="#GXBeam.insert_expanded_steady_point_jacobians!"><code>GXBeam.insert_expanded_steady_point_jacobians!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_expanded_steady_point_jacobians!(jacob, indices, force_scaling, ipoint, properties,
    resultants, velocities)</code></pre><p>Insert the jacobian entries corresponding to a point for a constant mass matrix system into the system jacobian matrix for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1936-L1942">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_expanded_dynamic_point_jacobians!" href="#GXBeam.insert_expanded_dynamic_point_jacobians!"><code>GXBeam.insert_expanded_dynamic_point_jacobians!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_expanded_dynamic_point_jacobians!(jacob, indices, force_scaling, ipoint, properties,
    resultants, velocities)</code></pre><p>Insert the jacobian entries corresponding to a point for a constant mass matrix system into the system jacobian matrix for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L1984-L1990">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_mass_matrix_point_jacobians!" href="#GXBeam.insert_mass_matrix_point_jacobians!"><code>GXBeam.insert_mass_matrix_point_jacobians!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_mass_matrix_point_jacobians!(jacob, gamma, indices, two_dimensional, force_scaling, ipoint,
    properties, resultants, velocities)</code></pre><p>Insert the mass matrix jacobian entries corresponding to a point into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2025-L2031">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_point_jacobian!" href="#GXBeam.static_point_jacobian!"><code>GXBeam.static_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_point_jacobian!(jacob, x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity)</code></pre><p>Calculate and insert the jacobian entries corresponding to a point for a static analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2313-L2319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_point_jacobian!" href="#GXBeam.steady_point_jacobian!"><code>GXBeam.steady_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_point_jacobian!(jacob, x, indices, force_scaling, assembly,
    ipoint, prescribed_conditions, point_masses, gravity,
    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)</code></pre><p>Calculate and insert the jacobian entries corresponding to a point for a steady state analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2337-L2344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_point_jacobian!" href="#GXBeam.initial_point_jacobian!"><code>GXBeam.initial_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_point_jacobian!(jacob, x, indices, rate_vars,
    force_scaling, assembly, ipoint, prescribed_conditions, point_masses, gravity,
    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration,
    u0, θ0, V0, Ω0, Vdot0, Ωdot0)</code></pre><p>Calculate and insert the jacobian entries corresponding to a point for the initialization of a time domain analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2366-L2374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_point_jacobian!" href="#GXBeam.newmark_point_jacobian!"><code>GXBeam.newmark_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_point_jacobian!(jacob, x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity,
    udot_init, θdot_init, Vdot_init, Ωdot_init, dt))</code></pre><p>Calculate and insert the jacobian entries corresponding to a point for a Newmark scheme time marching analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2399-L2406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_point_jacobian!" href="#GXBeam.dynamic_point_jacobian!"><code>GXBeam.dynamic_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_point_jacobian!(jacob, dx, x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity)</code></pre><p>Calculate and insert the jacobian entries corresponding to a point for a dynamic analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2429-L2435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_point_jacobian!" href="#GXBeam.expanded_steady_point_jacobian!"><code>GXBeam.expanded_steady_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_steady_point_jacobian!(jacob, x, indices, force_scaling,
    assembly, ipoint, prescribed_conditions, point_masses, gravity,
    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)</code></pre><p>Calculate and insert the jacobian entries corresponding to a point for a constant mass matrix system into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2455-L2462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_point_jacobian!" href="#GXBeam.expanded_dynamic_point_jacobian!"><code>GXBeam.expanded_dynamic_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_point_jacobian!(jacob, dx, x, indices, force_scaling, assembly, ipoint,
    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity)</code></pre><p>Calculate and insert the jacobian entries corresponding to a point for a constant mass matrix system into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2484-L2490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.mass_matrix_point_jacobian!" href="#GXBeam.mass_matrix_point_jacobian!"><code>GXBeam.mass_matrix_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mass_matrix_point_jacobian!(jacob, gamma, x, indices, two_dimensional, force_scaling, assembly,
    ipoint, prescribed_conditions)</code></pre><p>Calculate and insert the mass_matrix jacobian entries corresponding to a point into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2512-L2518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_mass_matrix_point_jacobian!" href="#GXBeam.expanded_mass_matrix_point_jacobian!"><code>GXBeam.expanded_mass_matrix_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_mass_matrix_point_jacobian!(jacob, gamma, indices, two_dimensional, force_scaling, assembly,
    ipoint, prescribed_conditions, point_masses)</code></pre><p>Calculate and insert the mass_matrix jacobian entries corresponding to a point into the system jacobian matrix for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/point.jl#L2534-L2540">source</a></section></article><h3 id="Elements"><a class="docs-heading-anchor" href="#Elements">Elements</a><a id="Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Elements" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.Element" href="#GXBeam.Element"><code>GXBeam.Element</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Element{TF}</code></pre><p>Composite type that defines a beam element&#39;s properties</p><p><strong>Fields</strong></p><ul><li><code>L</code>: Beam element length</li><li><code>x</code>: Beam element location</li><li><code>compliance</code>: Beam element compliance matrix</li><li><code>mass</code>: Beam element mass matrix</li><li><code>Cab</code>: Transformation matrix from the undeformed beam element frame to the body frame</li><li><code>mu</code>: Beam element damping coefficients</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/assembly.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_loads" href="#GXBeam.element_loads"><code>GXBeam.element_loads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_loads(x, ielem, icol_elem, force_scaling)</code></pre><p>Extract the internal loads (<code>F</code>, <code>M</code>) for a beam element from the state variable vector. These loads are expressed in the deformed element frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_element_loads" href="#GXBeam.expanded_element_loads"><code>GXBeam.expanded_element_loads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_element_loads(x, ielem, icol_elem, force_scaling)</code></pre><p>Extract the internal loads of a beam element at its endpoints (<code>F1</code>, <code>M1</code>, <code>F2</code>, <code>M2</code>) from the state variable vector for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_element_velocities" href="#GXBeam.expanded_element_velocities"><code>GXBeam.expanded_element_velocities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_element_velocities(x, ielem, icol_elem)</code></pre><p>Extract the velocities of a beam element from the state variable vector for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_element_properties" href="#GXBeam.static_element_properties"><code>GXBeam.static_element_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_element_properties(x, indices, force_scaling, assembly, ielem,
    prescribed_conditions, gravity)</code></pre><p>Calculate/extract the element properties needed to construct the residual for a static analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_element_properties" href="#GXBeam.steady_element_properties"><code>GXBeam.steady_element_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_element_properties(x, indices, force_scaling, structural_damping,
    assembly, ielem, prescribed_conditions, gravity, linear_velocity, angular_velocity,
    linear_acceleration=(@SVector zeros(3)), angular_acceleration=(@SVector zeros(3)))</code></pre><p>Calculate/extract the element properties needed to construct the residual for a steady state analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L109-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_element_properties" href="#GXBeam.initial_element_properties"><code>GXBeam.initial_element_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_element_properties(x, indices, rate_vars, force_scaling,
    structural_damping, assembly, ielem, prescribed_conditions, gravity,
    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration, u0, θ0, V0, Ω0, Vdot0, Ωdot0)</code></pre><p>Calculate/extract the element properties needed to construct the residual for a time-domain analysis initialization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L222-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_element_properties" href="#GXBeam.newmark_element_properties"><code>GXBeam.newmark_element_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_element_properties(x, indices, force_scaling, structural_damping,
    assembly, ielem, prescribed_conditions, gravity, linear_velocity, angular_velocity,
    Vdot_init, Ωdot_init, dt)</code></pre><p>Calculate/extract the element properties needed to construct the residual for a newmark- scheme time stepping analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L373-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_properties" href="#GXBeam.dynamic_element_properties"><code>GXBeam.dynamic_element_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_element_properties(dx, x, indices, force_scaling, structural_damping,
    assembly, ielem, prescribed_conditions, gravity, linear_velocity, angular_velocity)</code></pre><p>Calculate/extract the element properties needed to construct the residual for a dynamic analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L414-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_element_properties" href="#GXBeam.expanded_steady_element_properties"><code>GXBeam.expanded_steady_element_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_steady_element_properties(x, indices, force_scaling, structural_damping,
    assembly, ielem, prescribed_conditions, gravity, linear_velocity, angular_velocity,
    linear_acceleration=(@SVector zeros(3)), angular_acceleration=(@SVector zeros(3)))</code></pre><p>Calculate/extract the element properties needed to construct the residual for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L449-L456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_element_properties" href="#GXBeam.expanded_dynamic_element_properties"><code>GXBeam.expanded_dynamic_element_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_element_properties(dx, x, indices, force_scaling, structural_damping,
    assembly, ielem, prescribed_conditions, gravity, linear_velocity, angular_velocity)</code></pre><p>Calculate/extract the element properties needed to construct the residual for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L588-L594">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>GXBeam.compatability_residuals</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>GXBeam.expanded_element_steady_velocity_residuals</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>GXBeam.expanded_element_dynamic_velocity_residuals</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_element_equilibrium_residuals" href="#GXBeam.expanded_element_equilibrium_residuals"><code>GXBeam.expanded_element_equilibrium_residuals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_element_equilibrium_residuals(properties, distributed_loads, ielem)</code></pre><p>Calculate the equilibrium residuals of a beam element for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1686-L1690">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_element_resultants" href="#GXBeam.static_element_resultants"><code>GXBeam.static_element_resultants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_element_resultants(properties, distributed_loads, ielem)</code></pre><p>Calculate the resultant loads applied at each end of a beam element for a static analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1855-L1859">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_resultants" href="#GXBeam.dynamic_element_resultants"><code>GXBeam.dynamic_element_resultants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_element_resultants(properties, distributed_loads, ielem)</code></pre><p>Calculate the resultant loads applied at each end of a beam element for a steady state analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1895-L1900">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_element_resultants" href="#GXBeam.expanded_element_resultants"><code>GXBeam.expanded_element_resultants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_element_resultants(properties)</code></pre><p>Calculate the resultant loads applied at each end of a beam element for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1921-L1926">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_element_residuals!" href="#GXBeam.insert_element_residuals!"><code>GXBeam.insert_element_residuals!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_element_residuals!(resid, indices, force_scaling, assembly, ielem,
    compatibility, resultants)</code></pre><p>Insert the residual entries corresponding to a beam element into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L2415-L2420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_expanded_element_residuals!" href="#GXBeam.insert_expanded_element_residuals!"><code>GXBeam.insert_expanded_element_residuals!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_expanded_element_residuals!(resid, indices, force_scaling, assembly, ielem,
    compatibility, velocities, equilibrium, resultants)</code></pre><p>Insert the residual entries corresponding to a beam element into the system residual vector for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L2445-L2451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_element_residual!" href="#GXBeam.static_element_residual!"><code>GXBeam.static_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_element_residual!(resid, x, indices, force_scaling, assembly, ielem,
    prescribed_conditions, distributed_loads, gravity)</code></pre><p>Calculate and insert the residual entries corresponding to a beam element for a static analysis into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L2988-L2994">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_element_residual!" href="#GXBeam.steady_element_residual!"><code>GXBeam.steady_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_element_residual!(resid, x, indices, force_scaling, structural_damping,
    assembly, ielem, prescribed_conditions, distributed_loads, gravity,
    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)</code></pre><p>Calculate and insert the residual entries corresponding to a beam element for a steady state analysis into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3011-L3018">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_element_residual!" href="#GXBeam.initial_element_residual!"><code>GXBeam.initial_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_element_residual!(resid, x, indices, rate_vars,
    force_scaling, structural_damping, assembly, ielem, prescribed_conditions,
    distributed_loads, gravity, linear_velocity, angular_velocity,
    linear_acceleration, angular_acceleration, u0, θ0, V0, Ω0, Vdot0, Ωdot0)</code></pre><p>Calculate and insert the residual entries corresponding to a beam element for the initialization of a time domain simulation into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3037-L3045">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_element_residual!" href="#GXBeam.newmark_element_residual!"><code>GXBeam.newmark_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_element_residual!(resid, x, indices, force_scaling, structural_damping,
    assembly, ielem, prescribed_conditions, distributed_loads, gravity,
    linear_velocity, angular_velocity, Vdot_init, Ωdot_init, dt)</code></pre><p>Calculate and insert the residual entries corresponding to a beam element for a newmark-scheme time marching analysis into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3066-L3073">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_residual!" href="#GXBeam.dynamic_element_residual!"><code>GXBeam.dynamic_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_element_residual!(resid, dx, x, indices, force_scaling, structural_damping,
    assembly, ielem, prescribed_conditions, distributed_loads, gravity,
    linear_velocity, angular_velocity)</code></pre><p>Calculate and insert the residual entries corresponding to a beam element for a dynamic analysis into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3092-L3099">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_element_residual!" href="#GXBeam.expanded_steady_element_residual!"><code>GXBeam.expanded_steady_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_steady_element_residual!(resid, x, indices, force_scaling, structural_damping,
    assembly, ielem, prescribed_conditions, distributed_loads, gravity,
    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)</code></pre><p>Calculate and insert the residual entries corresponding to a beam element for a constant mass matrix system into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3116-L3123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_element_residual!" href="#GXBeam.expanded_dynamic_element_residual!"><code>GXBeam.expanded_dynamic_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_element_residual!(resid, dx, x, indices, force_scaling,
    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads,
    gravity, linear_velocity, angular_velocity)</code></pre><p>Calculate and insert the residual entries corresponding to a beam element for a constant mass matrix system into the system residual vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3146-L3153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_element_jacobian_properties" href="#GXBeam.static_element_jacobian_properties"><code>GXBeam.static_element_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_element_jacobian_properties(properties, x, indices, force_scaling,
    assembly, ielem, prescribed_conditions, gravity)</code></pre><p>Calculate/extract the element properties needed to calculate the jacobian entries corresponding to a beam element for a static analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L614-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_element_jacobian_properties" href="#GXBeam.steady_element_jacobian_properties"><code>GXBeam.steady_element_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_element_jacobian_properties(properties, x, indices,
    force_scaling, structural_damping, assembly, ielem, prescribed_conditions,
    gravity)</code></pre><p>Calculate/extract the element properties needed to calculate the jacobian entries corresponding to a element for a steady state analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L641-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_element_jacobian_properties" href="#GXBeam.initial_element_jacobian_properties"><code>GXBeam.initial_element_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_element_jacobian_properties(properties, x, indices, rate_vars,
    force_scaling, structural_damping, assembly, ielem, prescribed_conditions, gravity,
    u0, θ0, V0, Ω0, Vdot0, Ωdot0)</code></pre><p>Calculate/extract the element properties needed to calculate the jacobian entries corresponding to a element for a Newmark scheme time marching analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L842-L849">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_element_jacobian_properties" href="#GXBeam.newmark_element_jacobian_properties"><code>GXBeam.newmark_element_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_element_jacobian_properties(properties, x, indices, force_scaling,
    structural_damping, assembly, ielem, prescribed_conditions, gravity,
    Vdot_init, Ωdot_init, dt)</code></pre><p>Calculate/extract the element properties needed to calculate the jacobian entries corresponding to a element for a Newmark scheme time marching analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1041-L1048">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_jacobian_properties" href="#GXBeam.dynamic_element_jacobian_properties"><code>GXBeam.dynamic_element_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_element_jacobian_properties(properties, dx, x, indices,
    force_scaling, assembly, ielem, prescribed_conditions, gravity)</code></pre><p>Calculate/extract the element properties needed to calculate the jacobian entries corresponding to a element for a dynamic analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1114-L1120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_element_jacobian_properties" href="#GXBeam.expanded_steady_element_jacobian_properties"><code>GXBeam.expanded_steady_element_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_element_jacobian_properties(properties, x, indices, force_scaling,
    structural_damping, assembly, ielem, prescribed_conditions, gravity)</code></pre><p>Calculate/extract the element properties needed to calculate the jacobian entries corresponding to a element for a steady state analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1177-L1182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_element_jacobian_properties" href="#GXBeam.expanded_dynamic_element_jacobian_properties"><code>GXBeam.expanded_dynamic_element_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_element_jacobian_properties(properties, dx, x, indices, force_scaling,
    structural_damping, assembly, ielem, prescribed_conditions, gravity)</code></pre><p>Calculate/extract the element properties needed to calculate the jacobian entries corresponding to a element for a dynamic analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1380-L1386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.mass_matrix_element_jacobian_properties" href="#GXBeam.mass_matrix_element_jacobian_properties"><code>GXBeam.mass_matrix_element_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mass_matrix_element_jacobian_properties(x, indices, force_scaling,
assembly, ielem, prescribed_conditions)</code></pre><p>Calculate/extract the element properties needed to calculate the mass matrix jacobian entries corresponding to a beam element</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1401-L1407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_mass_matrix_element_jacobian_properties" href="#GXBeam.expanded_mass_matrix_element_jacobian_properties"><code>GXBeam.expanded_mass_matrix_element_jacobian_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_mass_matrix_element_jacobian_properties(assembly, ielem, prescribed_conditions)</code></pre><p>Calculate/extract the element properties needed to calculate the mass matrix jacobian entries corresponding to a beam element for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1443-L1447">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>GXBeam.expanded_element_steady_velocity_jacobians</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>GXBeam.expanded_element_dynamic_velocity_jacobians</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_element_equilibrium_jacobians" href="#GXBeam.expanded_steady_element_equilibrium_jacobians"><code>GXBeam.expanded_steady_element_equilibrium_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_steady_element_equilibrium_jacobians(properties)</code></pre><p>Calculate the jacobians of the element equilibrium residuals for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1725-L1729">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_element_equilibrium_jacobians" href="#GXBeam.expanded_dynamic_element_equilibrium_jacobians"><code>GXBeam.expanded_dynamic_element_equilibrium_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_element_equilibrium_jacobians(properties)</code></pre><p>Calculate the jacobians of the element equilibrium residuals for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1746-L1750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_mass_matrix_element_equilibrium_jacobians" href="#GXBeam.expanded_mass_matrix_element_equilibrium_jacobians"><code>GXBeam.expanded_mass_matrix_element_equilibrium_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_mass_matrix_element_equilibrium_jacobians(properties)</code></pre><p>Calculate the mass matrix jacobians for the resultant loads applied at each end of a beam element for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1835-L1840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_element_resultant_jacobians" href="#GXBeam.static_element_resultant_jacobians"><code>GXBeam.static_element_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_element_resultant_jacobians(properties, distributed_loads, ielem)</code></pre><p>Calculate the jacobians for the resultant loads applied at each end of a beam element for a static analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L1939-L1944">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_element_resultant_jacobians" href="#GXBeam.steady_element_resultant_jacobians"><code>GXBeam.steady_element_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_element_resultant_jacobians(properties, distributed_loads, ielem)</code></pre><p>Calculate the jacobians for the resultant loads applied at each end of a beam element for a steady state analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L2029-L2034">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_element_resultant_jacobians" href="#GXBeam.initial_element_resultant_jacobians"><code>GXBeam.initial_element_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_element_resultant_jacobians(properties, distributed_loads, ielem)</code></pre><p>Calculate the jacobians for the resultant loads applied at each end of V beam element for the initialization of a time domain analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L2066-L2071">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_resultant_jacobians" href="#GXBeam.dynamic_element_resultant_jacobians"><code>GXBeam.dynamic_element_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_element_resultant_jacobians(properties, distributed_loads, ielem)</code></pre><p>Calculate the jacobians for the resultant loads applied at each end of a beam element for a dynamic analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L2213-L2218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_element_resultant_jacobians" href="#GXBeam.expanded_element_resultant_jacobians"><code>GXBeam.expanded_element_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_element_resultant_jacobians(properties)</code></pre><p>Calculate the jacobians for the resultant loads applied at each end of a beam element for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L2330-L2335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.mass_matrix_element_resultant_jacobians" href="#GXBeam.mass_matrix_element_resultant_jacobians"><code>GXBeam.mass_matrix_element_resultant_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mass_matrix_element_resultant_jacobians(properties)</code></pre><p>Calculate the mass matrix jacobians for the resultant loads applied at each end of a beam element</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L2365-L2369">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>GXBeam.expanded_mass_matrix_element_velocity_jacobians</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_element_jacobian!" href="#GXBeam.static_element_jacobian!"><code>GXBeam.static_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_element_jacobian!(jacob, x, indices, force_scaling,
    assembly, ielem, prescribed_conditions, distributed_loads, gravity)</code></pre><p>Calculate and insert the jacobian entries corresponding to a beam element for a static analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3175-L3181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_element_jacobian!" href="#GXBeam.steady_element_jacobian!"><code>GXBeam.steady_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_element_jacobian!(jacob, x, indices, force_scaling,
    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads,
    gravity, linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)</code></pre><p>Calculate and insert the jacobian entries corresponding to a beam element for a steady state analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3201-L3208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_element_jacobian!" href="#GXBeam.initial_element_jacobian!"><code>GXBeam.initial_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_element_jacobian!(jacob, x, indices, rate_vars, force_scaling,
    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads,
    gravity, ub, θb, vb, ωb, ab, αb, u0, θ0, V0, Ω0, Vdot0, Ωdot0)</code></pre><p>Calculate and insert the jacobian entries corresponding to a beam element for the initialization of a time domain analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3231-L3238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_element_jacobian!" href="#GXBeam.newmark_element_jacobian!"><code>GXBeam.newmark_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_element_jacobian!(jacob, x, indices, force_scaling,
    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads,
    gravity, linear_velocity, angular_velocity, Vdot_init, Ωdot_init, dt)</code></pre><p>Calculate and insert the jacobian entries corresponding to a beam element for a Newmark-scheme time marching analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3263-L3270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_jacobian!" href="#GXBeam.dynamic_element_jacobian!"><code>GXBeam.dynamic_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_element_jacobian!(jacob, dx, x, indices, force_scaling,
    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads,
    gravity, linear_velocity, angular_velocity)</code></pre><p>Calculate and insert the jacobian entries corresponding to a beam element for a dynamic analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3294-L3301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_element_jacobian!" href="#GXBeam.expanded_steady_element_jacobian!"><code>GXBeam.expanded_steady_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_steady_element_jacobian!(jacob, x, indices, force_scaling,
    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads,
    gravity, linear_velocity, angular_velocity, linear_acceleration,
    angular_acceleration)</code></pre><p>Calculate and insert the jacobian entries corresponding to a beam element for a dynamic analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3323-L3331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_element_jacobian!" href="#GXBeam.expanded_dynamic_element_jacobian!"><code>GXBeam.expanded_dynamic_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_element_jacobian!(jacob, dx, x, indices, force_scaling,
    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads,
    gravity, linear_velocity, angular_velocity)</code></pre><p>Calculate and insert the jacobian entries corresponding to a beam element for a dynamic analysis into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3357-L3364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.mass_matrix_element_jacobian!" href="#GXBeam.mass_matrix_element_jacobian!"><code>GXBeam.mass_matrix_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mass_matrix_element_jacobian!(jacob, gamma, x, indices, two_dimensional, force_scaling, assembly,
    ielem, prescribed_conditions)</code></pre><p>Calculate and insert the mass_matrix jacobian entries corresponding to a beam element into the system jacobian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3388-L3394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_mass_matrix_element_jacobian!" href="#GXBeam.expanded_mass_matrix_element_jacobian!"><code>GXBeam.expanded_mass_matrix_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_mass_matrix_element_jacobian!(jacob, gamma, indices, two_dimensional, force_scaling, assembly,
    ielem, prescribed_conditions)</code></pre><p>Calculate and insert the mass_matrix jacobian entries corresponding to a beam element into the system jacobian matrix for a constant mass matrix system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/element.jl#L3409-L3415">source</a></section></article><h3 id="System"><a class="docs-heading-anchor" href="#System">System</a><a id="System-1"></a><a class="docs-heading-anchor-permalink" href="#System" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.SystemIndices" href="#GXBeam.SystemIndices"><code>GXBeam.SystemIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SystemIndices</code></pre><p>Structure for holding indices for accessing the state variables and equations associated with each point and beam element in a system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.default_force_scaling" href="#GXBeam.default_force_scaling"><code>GXBeam.default_force_scaling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_force_scaling(assembly)</code></pre><p>Defines a suitable default force scaling factor based on the nonzero elements of the compliance matrices in <code>assembly</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.curve_triad" href="#GXBeam.curve_triad"><code>GXBeam.curve_triad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">curve_triad(Cab, k, s)
curve_triad(Cab, kkt, ktilde, kn, s)</code></pre><p>Return the transformation matrix at <code>s</code> along the length of the beam given the curvature vector <code>k</code> and the initial transformation matrix <code>Cab</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/assembly.jl#L324-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.curve_coordinates" href="#GXBeam.curve_coordinates"><code>GXBeam.curve_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">curve_coordiantes(r, Cab, k, s)
curve_coordinates(r, Cab, kkt, ktilde, kn, s)</code></pre><p>Return the coordinates at <code>s</code> along the length of the beam given the starting point <code>r</code>, initial transformation matrix <code>Cab</code>, and curvature vector <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/assembly.jl#L335-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_system_residual!" href="#GXBeam.static_system_residual!"><code>GXBeam.static_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_system_residual!(resid, x, indices, two_dimensional, force_scaling,
    assembly, prescribed_conditions, distributed_loads, point_masses, gravity)</code></pre><p>Populate the system residual vector <code>resid</code> for a static analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L394-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_system_residual!" href="#GXBeam.initial_system_residual!"><code>GXBeam.initial_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_system_residual!(resid, x, indices, rate_vars1, rate_vars2,
    two_dimensional, force_scaling, structural_damping, assembly, prescribed_conditions,
    distributed_loads, point_masses, gravity, linear_velocity, angular_velocity,
    linear_acceleration, angular_acceleration, u0, θ0, V0, Ω0, Vdot0, Ωdot0)</code></pre><p>Populate the system residual vector <code>resid</code> for the initialization of a time domain simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L457-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_system_residual!" href="#GXBeam.steady_system_residual!"><code>GXBeam.steady_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_system_residual!(resid, x, indices, two_dimensional, force_scaling,
    structural_damping, assembly, prescribed_conditions, distributed_loads,
    point_masses, gravity, vb, ωb, ab, αb)</code></pre><p>Populate the system residual vector <code>resid</code> for a steady state analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L420-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_system_residual!" href="#GXBeam.newmark_system_residual!"><code>GXBeam.newmark_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_system_residual!(resid, x, indices, two_dimensional, force_scaling, structural_damping,
    assembly, prescribed_conditions, distributed_loads, point_masses, gravity,
    linear_velocity, angular_velocity, udot_init, θdot_init, Vdot_init, Ωdot_init, dt)</code></pre><p>Populate the system residual vector <code>resid</code> for a Newmark scheme time marching analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L523-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_system_residual!" href="#GXBeam.dynamic_system_residual!"><code>GXBeam.dynamic_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_system_residual!(resid, dx, x, indices, two_dimensional, force_scaling,
    structural_damping, assembly, prescribed_conditions, distributed_loads,
    point_masses, gravity, linear_velocity, angular_velocity)</code></pre><p>Populate the system residual vector <code>resid</code> for a general dynamic analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L556-L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_system_residual!" href="#GXBeam.expanded_steady_system_residual!"><code>GXBeam.expanded_steady_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_steady_system_residual!(resid, x, indices, two_dimensional, force_scaling, structural_damping,
    assembly, prescribed_conditions, distributed_loads, point_masses, gravity,
    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)</code></pre><p>Populate the system residual vector <code>resid</code> for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L588-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_system_residual!" href="#GXBeam.expanded_dynamic_system_residual!"><code>GXBeam.expanded_dynamic_system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_system_residual!(resid, dx, x, indices, two_dimensional, force_scaling,
    structural_damping, assembly, prescribed_conditions, distributed_loads,
    point_masses, gravity, linear_velocity, angular_velocity)</code></pre><p>Populate the system residual vector <code>resid</code> for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L625-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_system_jacobian!" href="#GXBeam.static_system_jacobian!"><code>GXBeam.static_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_system_jacobian!(jacob, x, indices, two_dimensional, force_scaling,
    assembly, prescribed_conditions, distributed_loads, point_masses, gravity)</code></pre><p>Populate the system jacobian matrix <code>jacob</code> for a static analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L657-L662">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_system_jacobian!" href="#GXBeam.steady_system_jacobian!"><code>GXBeam.steady_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steady_system_jacobian!(jacob, x, indices, two_dimensional, force_scaling,
    structural_damping, assembly, prescribed_conditions, distributed_loads,
    point_masses, gravity, linear_velocity, angular_velocity, linear_acceleration,
    angular_acceleration)</code></pre><p>Populate the system jacobian matrix <code>jacob</code> for a steady-state analysis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L685-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.initial_system_jacobian!" href="#GXBeam.initial_system_jacobian!"><code>GXBeam.initial_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_system_jacobian!(jacob, x, indices, rate_vars1, rate_vars2, two_dimensional, force_scaling,
    structural_damping, assembly, prescribed_conditions, distributed_loads,
    point_masses, gravity, linear_velocity, angular_velocity, linear_acceleration,
    angular_acceleration, u0, θ0, V0, Ω0, Vdot0, Ωdot0)</code></pre><p>Populate the system jacobian matrix <code>jacob</code> for the initialization of a time domain simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L722-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.newmark_system_jacobian!" href="#GXBeam.newmark_system_jacobian!"><code>GXBeam.newmark_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newmark_system_jacobian!(jacob, x, indices, two_dimensional, force_scaling, structural_damping,
    assembly, prescribed_conditions, distributed_loads, point_masses, gravity,
    linear_velocity, angular_velocity, udot_init, θdot_init, Vdot_init, Ωdot_init, dt)</code></pre><p>Populate the system jacobian matrix <code>jacob</code> for a Newmark scheme time marching analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L822-L828">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_system_jacobian!" href="#GXBeam.dynamic_system_jacobian!"><code>GXBeam.dynamic_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_system_jacobian!(jacob, dx, x, indices, two_dimensional, force_scaling,
    structural_damping, assembly, prescribed_conditions, distributed_loads,
    point_masses, gravity, linear_velocity, angular_velocity)</code></pre><p>Populate the system jacobian matrix <code>jacob</code> for a general dynamic analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L854-L860">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_steady_system_jacobian!" href="#GXBeam.expanded_steady_system_jacobian!"><code>GXBeam.expanded_steady_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_steady_system_jacobian!(jacob, x, indices, two_dimensional, force_scaling, structural_damping,
    assembly, prescribed_conditions, distributed_loads, point_masses, gravity,
    ub_p, θb_p, vb_p, ωb_p, ab_p, αb_p)</code></pre><p>Populate the system jacobian matrix <code>jacob</code> for a general dynamic analysis with a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L886-L893">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_dynamic_system_jacobian!" href="#GXBeam.expanded_dynamic_system_jacobian!"><code>GXBeam.expanded_dynamic_system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_dynamic_system_jacobian!(jacob, dx, x, indices, two_dimensional, force_scaling, structural_damping,
    assembly, prescribed_conditions, distributed_loads, point_masses, gravity,
    linear_velocity, angular_velocity)</code></pre><p>Populate the system jacobian matrix <code>jacob</code> for a general dynamic analysis with a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L923-L930">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.system_mass_matrix!" href="#GXBeam.system_mass_matrix!"><code>GXBeam.system_mass_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">system_mass_matrix!(jacob, x, indices, two_dimensional, force_scaling,  assembly,
    prescribed_conditions, point_masses)</code></pre><p>Calculate the jacobian of the residual expressions with respect to the state rates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L955-L960">source</a></section><section><div><pre><code class="nohighlight hljs">system_mass_matrix!(jacob, gamma, x, indices, two_dimensional, force_scaling, assembly,
    prescribed_conditions, point_masses)</code></pre><p>Calculate the jacobian of the residual expressions with respect to the state rates and add the result multiplied by <code>gamma</code> to <code>jacob</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L974-L980">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_system_mass_matrix" href="#GXBeam.expanded_system_mass_matrix"><code>GXBeam.expanded_system_mass_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_system_mass_matrix(system, assembly;
    two_dimensional = false,
    prescribed_conditions=Dict{Int, PrescribedConditions}(),
    point_masses=Dict{Int, PointMass}())</code></pre><p>Calculate the jacobian of the residual expressions with respect to the state rates for a constant mass matrix system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L997-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.expanded_system_mass_matrix!" href="#GXBeam.expanded_system_mass_matrix!"><code>GXBeam.expanded_system_mass_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_system_mass_matrix!(jacob, indices, two_dimensional, force_scaling,  assembly, prescribed_conditions,
    point_masses)</code></pre><p>Calculate the jacobian of the residual expressions with respect to the state rates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L1025-L1030">source</a></section><section><div><pre><code class="nohighlight hljs">expanded_system_mass_matrix!(jacob, gamma, indices, two_dimensional, force_scaling, assembly,
    prescribed_conditions, point_masses)</code></pre><p>Calculate the jacobian of the residual expressions with respect to the state rates and add the result multiplied by <code>gamma</code> to <code>jacob</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/37fe06558a5d5f80e71bd4c431d5d52cb351a5e8/src/system.jl#L1044-L1050">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#GXBeam.AbstractSystem"><code>GXBeam.AbstractSystem</code></a></li><li><a href="#GXBeam.Assembly"><code>GXBeam.Assembly</code></a></li><li><a href="#GXBeam.Assembly-Tuple{Any, Any, Any}"><code>GXBeam.Assembly</code></a></li><li><a href="#GXBeam.AssemblyState"><code>GXBeam.AssemblyState</code></a></li><li><a href="#GXBeam.AssemblyState-Tuple{Any, Any}"><code>GXBeam.AssemblyState</code></a></li><li><a href="#GXBeam.DistributedLoads-Tuple{Any, Any}"><code>GXBeam.DistributedLoads</code></a></li><li><a href="#GXBeam.DistributedLoads"><code>GXBeam.DistributedLoads</code></a></li><li><a href="#GXBeam.DynamicSystem-Tuple{Any}"><code>GXBeam.DynamicSystem</code></a></li><li><a href="#GXBeam.DynamicSystem"><code>GXBeam.DynamicSystem</code></a></li><li><a href="#GXBeam.Element"><code>GXBeam.Element</code></a></li><li><a href="#GXBeam.ElementState"><code>GXBeam.ElementState</code></a></li><li><a href="#GXBeam.ExpandedSystem-Tuple{Any}"><code>GXBeam.ExpandedSystem</code></a></li><li><a href="#GXBeam.ExpandedSystem"><code>GXBeam.ExpandedSystem</code></a></li><li><a href="#GXBeam.Layer"><code>GXBeam.Layer</code></a></li><li><a href="#GXBeam.Material"><code>GXBeam.Material</code></a></li><li><a href="#GXBeam.MeshElement"><code>GXBeam.MeshElement</code></a></li><li><a href="#GXBeam.Node"><code>GXBeam.Node</code></a></li><li><a href="#GXBeam.PointMass-Tuple{Any, Any, Any}"><code>GXBeam.PointMass</code></a></li><li><a href="#GXBeam.PointMass"><code>GXBeam.PointMass</code></a></li><li><a href="#GXBeam.PointState"><code>GXBeam.PointState</code></a></li><li><a href="#GXBeam.PrescribedConditions"><code>GXBeam.PrescribedConditions</code></a></li><li><a href="#GXBeam.PrescribedConditions-Tuple{}"><code>GXBeam.PrescribedConditions</code></a></li><li><a href="#GXBeam.StaticSystem-Tuple{Any}"><code>GXBeam.StaticSystem</code></a></li><li><a href="#GXBeam.StaticSystem"><code>GXBeam.StaticSystem</code></a></li><li><a href="#GXBeam.SystemIndices"><code>GXBeam.SystemIndices</code></a></li><li><a href="../../examples/diffeq/#SciMLBase.DAEFunction-Tuple{DynamicSystem, Any}"><code>SciMLBase.DAEFunction</code></a></li><li><a href="../../examples/diffeq/#SciMLBase.DAEProblem-Tuple{DynamicSystem, Any, Any}"><code>SciMLBase.DAEProblem</code></a></li><li><a href="../../examples/diffeq/#SciMLBase.ODEFunction-Tuple{AbstractSystem, Any}"><code>SciMLBase.ODEFunction</code></a></li><li><a href="../../examples/diffeq/#SciMLBase.ODEProblem-Tuple{AbstractSystem, Any, Any}"><code>SciMLBase.ODEProblem</code></a></li><li><a href="#GXBeam.afmesh"><code>GXBeam.afmesh</code></a></li><li><a href="#GXBeam.body_accelerations"><code>GXBeam.body_accelerations</code></a></li><li><a href="#GXBeam.combine_loads"><code>GXBeam.combine_loads</code></a></li><li><a href="#GXBeam.combine_masses"><code>GXBeam.combine_masses</code></a></li><li><a href="#GXBeam.compliance_matrix"><code>GXBeam.compliance_matrix</code></a></li><li><a href="#GXBeam.correlate_eigenmodes"><code>GXBeam.correlate_eigenmodes</code></a></li><li><a href="#GXBeam.curve_coordinates"><code>GXBeam.curve_coordinates</code></a></li><li><a href="#GXBeam.curve_length"><code>GXBeam.curve_length</code></a></li><li><a href="#GXBeam.curve_triad"><code>GXBeam.curve_triad</code></a></li><li><a href="#GXBeam.default_force_scaling"><code>GXBeam.default_force_scaling</code></a></li><li><a href="#GXBeam.deform_cross_section"><code>GXBeam.deform_cross_section</code></a></li><li><a href="#GXBeam.deform_cross_section!"><code>GXBeam.deform_cross_section!</code></a></li><li><a href="#GXBeam.discretize_beam"><code>GXBeam.discretize_beam</code></a></li><li><a href="#GXBeam.dynamic_element_jacobian!"><code>GXBeam.dynamic_element_jacobian!</code></a></li><li><a href="#GXBeam.dynamic_element_jacobian_properties"><code>GXBeam.dynamic_element_jacobian_properties</code></a></li><li><a href="#GXBeam.dynamic_element_properties"><code>GXBeam.dynamic_element_properties</code></a></li><li><a href="#GXBeam.dynamic_element_residual!"><code>GXBeam.dynamic_element_residual!</code></a></li><li><a href="#GXBeam.dynamic_element_resultant_jacobians"><code>GXBeam.dynamic_element_resultant_jacobians</code></a></li><li><a href="#GXBeam.dynamic_element_resultants"><code>GXBeam.dynamic_element_resultants</code></a></li><li><a href="#GXBeam.dynamic_point_jacobian!"><code>GXBeam.dynamic_point_jacobian!</code></a></li><li><a href="#GXBeam.dynamic_point_jacobian_properties"><code>GXBeam.dynamic_point_jacobian_properties</code></a></li><li><a href="#GXBeam.dynamic_point_properties"><code>GXBeam.dynamic_point_properties</code></a></li><li><a href="#GXBeam.dynamic_point_residual!"><code>GXBeam.dynamic_point_residual!</code></a></li><li><a href="#GXBeam.dynamic_point_resultant_jacobians"><code>GXBeam.dynamic_point_resultant_jacobians</code></a></li><li><a href="#GXBeam.dynamic_point_resultants"><code>GXBeam.dynamic_point_resultants</code></a></li><li><a href="#GXBeam.dynamic_point_velocity_jacobians"><code>GXBeam.dynamic_point_velocity_jacobians</code></a></li><li><a href="#GXBeam.dynamic_system_jacobian!"><code>GXBeam.dynamic_system_jacobian!</code></a></li><li><a href="#GXBeam.dynamic_system_residual!"><code>GXBeam.dynamic_system_residual!</code></a></li><li><a href="#GXBeam.eigenvalue_analysis"><code>GXBeam.eigenvalue_analysis</code></a></li><li><a href="#GXBeam.eigenvalue_analysis!"><code>GXBeam.eigenvalue_analysis!</code></a></li><li><a href="#GXBeam.element_loads"><code>GXBeam.element_loads</code></a></li><li><a href="#GXBeam.expanded_dynamic_element_equilibrium_jacobians"><code>GXBeam.expanded_dynamic_element_equilibrium_jacobians</code></a></li><li><a href="#GXBeam.expanded_dynamic_element_jacobian!"><code>GXBeam.expanded_dynamic_element_jacobian!</code></a></li><li><a href="#GXBeam.expanded_dynamic_element_jacobian_properties"><code>GXBeam.expanded_dynamic_element_jacobian_properties</code></a></li><li><a href="#GXBeam.expanded_dynamic_element_properties"><code>GXBeam.expanded_dynamic_element_properties</code></a></li><li><a href="#GXBeam.expanded_dynamic_element_residual!"><code>GXBeam.expanded_dynamic_element_residual!</code></a></li><li><a href="#GXBeam.expanded_dynamic_point_jacobian!"><code>GXBeam.expanded_dynamic_point_jacobian!</code></a></li><li><a href="#GXBeam.expanded_dynamic_point_jacobian_properties"><code>GXBeam.expanded_dynamic_point_jacobian_properties</code></a></li><li><a href="#GXBeam.expanded_dynamic_point_properties"><code>GXBeam.expanded_dynamic_point_properties</code></a></li><li><a href="#GXBeam.expanded_dynamic_point_residual!"><code>GXBeam.expanded_dynamic_point_residual!</code></a></li><li><a href="#GXBeam.expanded_dynamic_point_resultant_jacobians"><code>GXBeam.expanded_dynamic_point_resultant_jacobians</code></a></li><li><a href="#GXBeam.expanded_dynamic_system_jacobian!"><code>GXBeam.expanded_dynamic_system_jacobian!</code></a></li><li><a href="#GXBeam.expanded_dynamic_system_residual!"><code>GXBeam.expanded_dynamic_system_residual!</code></a></li><li><a href="#GXBeam.expanded_element_equilibrium_residuals"><code>GXBeam.expanded_element_equilibrium_residuals</code></a></li><li><a href="#GXBeam.expanded_element_loads"><code>GXBeam.expanded_element_loads</code></a></li><li><a href="#GXBeam.expanded_element_resultant_jacobians"><code>GXBeam.expanded_element_resultant_jacobians</code></a></li><li><a href="#GXBeam.expanded_element_resultants"><code>GXBeam.expanded_element_resultants</code></a></li><li><a href="#GXBeam.expanded_element_velocities"><code>GXBeam.expanded_element_velocities</code></a></li><li><a href="#GXBeam.expanded_mass_matrix_element_equilibrium_jacobians"><code>GXBeam.expanded_mass_matrix_element_equilibrium_jacobians</code></a></li><li><a href="#GXBeam.expanded_mass_matrix_element_jacobian!"><code>GXBeam.expanded_mass_matrix_element_jacobian!</code></a></li><li><a href="#GXBeam.expanded_mass_matrix_element_jacobian_properties"><code>GXBeam.expanded_mass_matrix_element_jacobian_properties</code></a></li><li><a href="#GXBeam.expanded_mass_matrix_point_jacobian!"><code>GXBeam.expanded_mass_matrix_point_jacobian!</code></a></li><li><a href="#GXBeam.expanded_mass_matrix_point_jacobian_properties"><code>GXBeam.expanded_mass_matrix_point_jacobian_properties</code></a></li><li><a href="#GXBeam.expanded_point_resultants"><code>GXBeam.expanded_point_resultants</code></a></li><li><a href="#GXBeam.expanded_point_velocity_jacobians"><code>GXBeam.expanded_point_velocity_jacobians</code></a></li><li><a href="#GXBeam.expanded_point_velocity_residuals"><code>GXBeam.expanded_point_velocity_residuals</code></a></li><li><a href="#GXBeam.expanded_steady_element_equilibrium_jacobians"><code>GXBeam.expanded_steady_element_equilibrium_jacobians</code></a></li><li><a href="#GXBeam.expanded_steady_element_jacobian!"><code>GXBeam.expanded_steady_element_jacobian!</code></a></li><li><a href="#GXBeam.expanded_steady_element_jacobian_properties"><code>GXBeam.expanded_steady_element_jacobian_properties</code></a></li><li><a href="#GXBeam.expanded_steady_element_properties"><code>GXBeam.expanded_steady_element_properties</code></a></li><li><a href="#GXBeam.expanded_steady_element_residual!"><code>GXBeam.expanded_steady_element_residual!</code></a></li><li><a href="#GXBeam.expanded_steady_point_jacobian!"><code>GXBeam.expanded_steady_point_jacobian!</code></a></li><li><a href="#GXBeam.expanded_steady_point_jacobian_properties"><code>GXBeam.expanded_steady_point_jacobian_properties</code></a></li><li><a href="#GXBeam.expanded_steady_point_properties"><code>GXBeam.expanded_steady_point_properties</code></a></li><li><a href="#GXBeam.expanded_steady_point_residual!"><code>GXBeam.expanded_steady_point_residual!</code></a></li><li><a href="#GXBeam.expanded_steady_point_resultant_jacobians"><code>GXBeam.expanded_steady_point_resultant_jacobians</code></a></li><li><a href="#GXBeam.expanded_steady_system_jacobian!"><code>GXBeam.expanded_steady_system_jacobian!</code></a></li><li><a href="#GXBeam.expanded_steady_system_residual!"><code>GXBeam.expanded_steady_system_residual!</code></a></li><li><a href="#GXBeam.expanded_system_mass_matrix"><code>GXBeam.expanded_system_mass_matrix</code></a></li><li><a href="#GXBeam.expanded_system_mass_matrix!"><code>GXBeam.expanded_system_mass_matrix!</code></a></li><li><a href="#GXBeam.extract_element_state"><code>GXBeam.extract_element_state</code></a></li><li><a href="#GXBeam.extract_element_states"><code>GXBeam.extract_element_states</code></a></li><li><a href="#GXBeam.extract_point_state"><code>GXBeam.extract_point_state</code></a></li><li><a href="#GXBeam.extract_point_states"><code>GXBeam.extract_point_states</code></a></li><li><a href="#GXBeam.gauss_quadrature"><code>GXBeam.gauss_quadrature</code></a></li><li><a href="#GXBeam.get_C"><code>GXBeam.get_C</code></a></li><li><a href="#GXBeam.get_C_θ"><code>GXBeam.get_C_θ</code></a></li><li><a href="#GXBeam.get_Q"><code>GXBeam.get_Q</code></a></li><li><a href="#GXBeam.get_Q_θ"><code>GXBeam.get_Q_θ</code></a></li><li><a href="#GXBeam.get_Qinv"><code>GXBeam.get_Qinv</code></a></li><li><a href="#GXBeam.get_Qinv_θ"><code>GXBeam.get_Qinv_θ</code></a></li><li><a href="#GXBeam.get_ΔQ"><code>GXBeam.get_ΔQ</code></a></li><li><a href="#GXBeam.get_ΔQ_θ"><code>GXBeam.get_ΔQ_θ</code></a></li><li><a href="#GXBeam.initial_condition_analysis"><code>GXBeam.initial_condition_analysis</code></a></li><li><a href="#GXBeam.initial_condition_analysis!"><code>GXBeam.initial_condition_analysis!</code></a></li><li><a href="#GXBeam.initial_element_jacobian!"><code>GXBeam.initial_element_jacobian!</code></a></li><li><a href="#GXBeam.initial_element_jacobian_properties"><code>GXBeam.initial_element_jacobian_properties</code></a></li><li><a href="#GXBeam.initial_element_properties"><code>GXBeam.initial_element_properties</code></a></li><li><a href="#GXBeam.initial_element_residual!"><code>GXBeam.initial_element_residual!</code></a></li><li><a href="#GXBeam.initial_element_resultant_jacobians"><code>GXBeam.initial_element_resultant_jacobians</code></a></li><li><a href="#GXBeam.initial_point_displacement"><code>GXBeam.initial_point_displacement</code></a></li><li><a href="#GXBeam.initial_point_displacement_jacobian"><code>GXBeam.initial_point_displacement_jacobian</code></a></li><li><a href="#GXBeam.initial_point_jacobian!"><code>GXBeam.initial_point_jacobian!</code></a></li><li><a href="#GXBeam.initial_point_jacobian_properties"><code>GXBeam.initial_point_jacobian_properties</code></a></li><li><a href="#GXBeam.initial_point_properties"><code>GXBeam.initial_point_properties</code></a></li><li><a href="#GXBeam.initial_point_residual!"><code>GXBeam.initial_point_residual!</code></a></li><li><a href="#GXBeam.initial_point_resultant_jacobians"><code>GXBeam.initial_point_resultant_jacobians</code></a></li><li><a href="#GXBeam.initial_point_velocity_jacobians"><code>GXBeam.initial_point_velocity_jacobians</code></a></li><li><a href="#GXBeam.initial_point_velocity_rate_jacobian"><code>GXBeam.initial_point_velocity_rate_jacobian</code></a></li><li><a href="#GXBeam.initial_point_velocity_rates"><code>GXBeam.initial_point_velocity_rates</code></a></li><li><a href="#GXBeam.initial_system_jacobian!"><code>GXBeam.initial_system_jacobian!</code></a></li><li><a href="#GXBeam.initial_system_residual!"><code>GXBeam.initial_system_residual!</code></a></li><li><a href="#GXBeam.initialize_cache"><code>GXBeam.initialize_cache</code></a></li><li><a href="#GXBeam.insert_dynamic_point_jacobians!"><code>GXBeam.insert_dynamic_point_jacobians!</code></a></li><li><a href="#GXBeam.insert_element_residuals!"><code>GXBeam.insert_element_residuals!</code></a></li><li><a href="#GXBeam.insert_expanded_dynamic_point_jacobians!"><code>GXBeam.insert_expanded_dynamic_point_jacobians!</code></a></li><li><a href="#GXBeam.insert_expanded_element_residuals!"><code>GXBeam.insert_expanded_element_residuals!</code></a></li><li><a href="#GXBeam.insert_expanded_steady_point_jacobians!"><code>GXBeam.insert_expanded_steady_point_jacobians!</code></a></li><li><a href="#GXBeam.insert_initial_point_jacobians!"><code>GXBeam.insert_initial_point_jacobians!</code></a></li><li><a href="#GXBeam.insert_mass_matrix_point_jacobians!"><code>GXBeam.insert_mass_matrix_point_jacobians!</code></a></li><li><a href="#GXBeam.insert_static_point_jacobians!"><code>GXBeam.insert_static_point_jacobians!</code></a></li><li><a href="#GXBeam.left_eigenvectors"><code>GXBeam.left_eigenvectors</code></a></li><li><a href="#GXBeam.linearize!"><code>GXBeam.linearize!</code></a></li><li><a href="#GXBeam.mass_matrix"><code>GXBeam.mass_matrix</code></a></li><li><a href="#GXBeam.mass_matrix_element_jacobian!"><code>GXBeam.mass_matrix_element_jacobian!</code></a></li><li><a href="#GXBeam.mass_matrix_element_jacobian_properties"><code>GXBeam.mass_matrix_element_jacobian_properties</code></a></li><li><a href="#GXBeam.mass_matrix_element_resultant_jacobians"><code>GXBeam.mass_matrix_element_resultant_jacobians</code></a></li><li><a href="#GXBeam.mass_matrix_point_jacobian!"><code>GXBeam.mass_matrix_point_jacobian!</code></a></li><li><a href="#GXBeam.mass_matrix_point_jacobian_properties"><code>GXBeam.mass_matrix_point_jacobian_properties</code></a></li><li><a href="#GXBeam.mass_matrix_point_resultant_jacobians"><code>GXBeam.mass_matrix_point_resultant_jacobians</code></a></li><li><a href="#GXBeam.mass_matrix_point_velocity_jacobians"><code>GXBeam.mass_matrix_point_velocity_jacobians</code></a></li><li><a href="#GXBeam.mul3"><code>GXBeam.mul3</code></a></li><li><a href="#GXBeam.newmark_element_jacobian!"><code>GXBeam.newmark_element_jacobian!</code></a></li><li><a href="#GXBeam.newmark_element_jacobian_properties"><code>GXBeam.newmark_element_jacobian_properties</code></a></li><li><a href="#GXBeam.newmark_element_properties"><code>GXBeam.newmark_element_properties</code></a></li><li><a href="#GXBeam.newmark_element_residual!"><code>GXBeam.newmark_element_residual!</code></a></li><li><a href="#GXBeam.newmark_point_jacobian!"><code>GXBeam.newmark_point_jacobian!</code></a></li><li><a href="#GXBeam.newmark_point_jacobian_properties"><code>GXBeam.newmark_point_jacobian_properties</code></a></li><li><a href="#GXBeam.newmark_point_properties"><code>GXBeam.newmark_point_properties</code></a></li><li><a href="#GXBeam.newmark_point_residual!"><code>GXBeam.newmark_point_residual!</code></a></li><li><a href="#GXBeam.newmark_point_velocity_jacobians"><code>GXBeam.newmark_point_velocity_jacobians</code></a></li><li><a href="#GXBeam.newmark_system_jacobian!"><code>GXBeam.newmark_system_jacobian!</code></a></li><li><a href="#GXBeam.newmark_system_residual!"><code>GXBeam.newmark_system_residual!</code></a></li><li><a href="#GXBeam.plotmesh"><code>GXBeam.plotmesh</code></a></li><li><a href="#GXBeam.plotsoln"><code>GXBeam.plotsoln</code></a></li><li><a href="#GXBeam.point_displacement"><code>GXBeam.point_displacement</code></a></li><li><a href="#GXBeam.point_displacement_jacobians"><code>GXBeam.point_displacement_jacobians</code></a></li><li><a href="#GXBeam.point_displacement_rates"><code>GXBeam.point_displacement_rates</code></a></li><li><a href="#GXBeam.point_load_jacobians"><code>GXBeam.point_load_jacobians</code></a></li><li><a href="#GXBeam.point_loads"><code>GXBeam.point_loads</code></a></li><li><a href="#GXBeam.point_velocities"><code>GXBeam.point_velocities</code></a></li><li><a href="#GXBeam.point_velocity_residuals"><code>GXBeam.point_velocity_residuals</code></a></li><li><a href="#GXBeam.reset_state!"><code>GXBeam.reset_state!</code></a></li><li><a href="#GXBeam.rotate"><code>GXBeam.rotate</code></a></li><li><a href="#GXBeam.rotate!"><code>GXBeam.rotate!</code></a></li><li><a href="#GXBeam.rotation_parameter_scaling"><code>GXBeam.rotation_parameter_scaling</code></a></li><li><a href="#GXBeam.set_angular_displacement!"><code>GXBeam.set_angular_displacement!</code></a></li><li><a href="#GXBeam.set_angular_velocity!"><code>GXBeam.set_angular_velocity!</code></a></li><li><a href="#GXBeam.set_element_angular_velocity!"><code>GXBeam.set_element_angular_velocity!</code></a></li><li><a href="#GXBeam.set_element_linear_velocity!"><code>GXBeam.set_element_linear_velocity!</code></a></li><li><a href="#GXBeam.set_end_forces!"><code>GXBeam.set_end_forces!</code></a></li><li><a href="#GXBeam.set_end_moments!"><code>GXBeam.set_end_moments!</code></a></li><li><a href="#GXBeam.set_external_forces!"><code>GXBeam.set_external_forces!</code></a></li><li><a href="#GXBeam.set_external_moments!"><code>GXBeam.set_external_moments!</code></a></li><li><a href="#GXBeam.set_internal_forces!"><code>GXBeam.set_internal_forces!</code></a></li><li><a href="#GXBeam.set_internal_moments!"><code>GXBeam.set_internal_moments!</code></a></li><li><a href="#GXBeam.set_linear_displacement!"><code>GXBeam.set_linear_displacement!</code></a></li><li><a href="#GXBeam.set_linear_velocity!"><code>GXBeam.set_linear_velocity!</code></a></li><li><a href="#GXBeam.set_point_angular_velocity!"><code>GXBeam.set_point_angular_velocity!</code></a></li><li><a href="#GXBeam.set_point_linear_velocity!"><code>GXBeam.set_point_linear_velocity!</code></a></li><li><a href="#GXBeam.set_rate!"><code>GXBeam.set_rate!</code></a></li><li><a href="#GXBeam.set_start_forces!"><code>GXBeam.set_start_forces!</code></a></li><li><a href="#GXBeam.set_start_moments!"><code>GXBeam.set_start_moments!</code></a></li><li><a href="#GXBeam.set_state!"><code>GXBeam.set_state!</code></a></li><li><a href="#GXBeam.solve_eigensystem"><code>GXBeam.solve_eigensystem</code></a></li><li><a href="#GXBeam.static_analysis"><code>GXBeam.static_analysis</code></a></li><li><a href="#GXBeam.static_analysis!"><code>GXBeam.static_analysis!</code></a></li><li><a href="#GXBeam.static_element_jacobian!"><code>GXBeam.static_element_jacobian!</code></a></li><li><a href="#GXBeam.static_element_jacobian_properties"><code>GXBeam.static_element_jacobian_properties</code></a></li><li><a href="#GXBeam.static_element_properties"><code>GXBeam.static_element_properties</code></a></li><li><a href="#GXBeam.static_element_residual!"><code>GXBeam.static_element_residual!</code></a></li><li><a href="#GXBeam.static_element_resultant_jacobians"><code>GXBeam.static_element_resultant_jacobians</code></a></li><li><a href="#GXBeam.static_element_resultants"><code>GXBeam.static_element_resultants</code></a></li><li><a href="#GXBeam.static_point_jacobian!"><code>GXBeam.static_point_jacobian!</code></a></li><li><a href="#GXBeam.static_point_jacobian_properties"><code>GXBeam.static_point_jacobian_properties</code></a></li><li><a href="#GXBeam.static_point_properties"><code>GXBeam.static_point_properties</code></a></li><li><a href="#GXBeam.static_point_residual!"><code>GXBeam.static_point_residual!</code></a></li><li><a href="#GXBeam.static_point_resultant_jacobians"><code>GXBeam.static_point_resultant_jacobians</code></a></li><li><a href="#GXBeam.static_point_resultants"><code>GXBeam.static_point_resultants</code></a></li><li><a href="#GXBeam.static_system_jacobian!"><code>GXBeam.static_system_jacobian!</code></a></li><li><a href="#GXBeam.static_system_residual!"><code>GXBeam.static_system_residual!</code></a></li><li><a href="#GXBeam.steady_element_jacobian!"><code>GXBeam.steady_element_jacobian!</code></a></li><li><a href="#GXBeam.steady_element_jacobian_properties"><code>GXBeam.steady_element_jacobian_properties</code></a></li><li><a href="#GXBeam.steady_element_properties"><code>GXBeam.steady_element_properties</code></a></li><li><a href="#GXBeam.steady_element_residual!"><code>GXBeam.steady_element_residual!</code></a></li><li><a href="#GXBeam.steady_element_resultant_jacobians"><code>GXBeam.steady_element_resultant_jacobians</code></a></li><li><a href="#GXBeam.steady_point_jacobian!"><code>GXBeam.steady_point_jacobian!</code></a></li><li><a href="#GXBeam.steady_point_jacobian_properties"><code>GXBeam.steady_point_jacobian_properties</code></a></li><li><a href="#GXBeam.steady_point_properties"><code>GXBeam.steady_point_properties</code></a></li><li><a href="#GXBeam.steady_point_residual!"><code>GXBeam.steady_point_residual!</code></a></li><li><a href="#GXBeam.steady_point_resultant_jacobians"><code>GXBeam.steady_point_resultant_jacobians</code></a></li><li><a href="#GXBeam.steady_state_analysis"><code>GXBeam.steady_state_analysis</code></a></li><li><a href="#GXBeam.steady_state_analysis!"><code>GXBeam.steady_state_analysis!</code></a></li><li><a href="#GXBeam.steady_system_jacobian!"><code>GXBeam.steady_system_jacobian!</code></a></li><li><a href="#GXBeam.steady_system_residual!"><code>GXBeam.steady_system_residual!</code></a></li><li><a href="#GXBeam.strain_recovery"><code>GXBeam.strain_recovery</code></a></li><li><a href="#GXBeam.system_mass_matrix!"><code>GXBeam.system_mass_matrix!</code></a></li><li><a href="#GXBeam.tilde"><code>GXBeam.tilde</code></a></li><li><a href="#GXBeam.time_domain_analysis"><code>GXBeam.time_domain_analysis</code></a></li><li><a href="#GXBeam.time_domain_analysis!"><code>GXBeam.time_domain_analysis!</code></a></li><li><a href="#GXBeam.transform_properties"><code>GXBeam.transform_properties</code></a></li><li><a href="#GXBeam.translate"><code>GXBeam.translate</code></a></li><li><a href="#GXBeam.translate!"><code>GXBeam.translate!</code></a></li><li><a href="#GXBeam.tsai_wu"><code>GXBeam.tsai_wu</code></a></li><li><a href="#GXBeam.update_body_acceleration_indices!"><code>GXBeam.update_body_acceleration_indices!</code></a></li><li><a href="#GXBeam.wiener_milenkovic"><code>GXBeam.wiener_milenkovic</code></a></li><li><a href="#GXBeam.write_vtk"><code>GXBeam.write_vtk</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/vertical-axis-wind-turbine/">« Sandia 34-Meter Vertical Axis Wind Turbine</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 14 March 2023 17:26">Tuesday 14 March 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
