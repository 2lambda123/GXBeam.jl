var documenterSearchIndex = {"docs":
[{"location":"examples/curved/","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/curved.jl\"","category":"page"},{"location":"examples/curved/#curved","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"","category":"section"},{"location":"examples/curved/","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"This example is a common benchmark problem for the geometrically exact bending of nonlinear beams.","category":"page"},{"location":"examples/curved/","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"(Image: )","category":"page"},{"location":"examples/curved/","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"tip: Tip\nThis example is also available as a Jupyter notebook: curved.ipynb.","category":"page"},{"location":"examples/curved/","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"using GXBeam, LinearAlgebra\n\n# problem constants\nR = 100\nL = R*pi/4 # inches\nh = w = 1 # inches\nE = 1e7 # psi Young's Modulus\nν = 0.0\nG = E/(2*(1+ν))\n\n# beam starting point, frame, and curvature\nstart = [0, 0, 0]\nframe = [0 -1 0; 1 0 0; 0 0 1]\ncurvature = [0, 0, -1/R]\n\n# cross section properties\nA = h*w\nAy = A\nAz = A\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\n# discretize the beam\nnelem = 16\nΔL, xp, xm, Cab = discretize_beam(L, start, nelem;\n    frame = frame,\n    curvature = curvature)\n\n# force\nP = 600 # lbs\n\n# index of left and right endpoints of each beam element\npt1 = 1:nelem\npt2 = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*J), 1/(E*Iyy),\n    1/(E*Izz)]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(xp, pt1, pt2, compliance=compliance, frames=Cab,\n    lengths=ΔL, midpoints=xm)\n\n# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # fixed left endpoint\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    # force on right endpoint\n    nelem+1 => PrescribedConditions(Fz = P)\n)\n\n# perform static analysis\nsystem, converged = static_analysis(assembly;\n    prescribed_conditions = prescribed_conditions)\n\n# post-process results\nstate = AssemblyState(system, assembly;\n    prescribed_conditions = prescribed_conditions)\n\nprintln(\"Tip Displacement: \", state.points[end].u)\nprintln(\"Tip Displacement (Bathe and Bolourch): [-13.4, -23.5, 53.4]\")","category":"page"},{"location":"examples/curved/","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"The calculated tip displacements match those reported by Bathe and Bolourch in \"Large Displacement Analysis of Three-Dimensional Beam Structures\" closely, thus verifying our implementation of geometrically exact beam theory.","category":"page"},{"location":"examples/curved/","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"We can visualize the deformed geometry and inspect the associated point and element data using ParaView.","category":"page"},{"location":"examples/curved/","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"mkpath(\"curved-visualization\")\nwrite_vtk(\"curved-visualization/curved-visualization\", assembly, state)\nrm(\"curved-visualization\"; recursive=true) #hide","category":"page"},{"location":"examples/curved/","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"(Image: )","category":"page"},{"location":"examples/curved/","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"","category":"page"},{"location":"examples/curved/","page":"Bending of an Initially Curved Beam","title":"Bending of an Initially Curved Beam","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/vertical-axis-wind-turbine.jl\"","category":"page"},{"location":"examples/vertical-axis-wind-turbine/#vawt","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"","category":"section"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"In this example, we examine the stability characteristics of the Sandia 34-Meter Vertical Axis Wind Turbine (VAWT).  Geometry for this VAWT is described in SAND-91-2228 and shown in the figure.  Sectional properties for this VAWT are derived from properties listed in SAND-88-1807","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"The original authors of this example requested that the following citation accompany it.","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"Moore, K. and Ennis, B., “Aeroelastic Validation of the Offshore Wind Energy Simulator for Vertical-Axis Wind Turbines”, forthcoming 2022","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"(Image: )","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"tip: Tip\nThis example is also available as a Jupyter notebook: vertical-axis-wind-turbine.ipynb.","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"using GXBeam, LinearAlgebra, FLOWMath\n\n# --- Tower Definition --- #\n\ntower_height = 41.9\ntower_stiffness = Diagonal([8.4404e9, 2.7053e9, 2.7053e9, 7.0428e9, 9.4072e9, 9.4072e9])\ntower_mass = Diagonal([330.755, 330.755, 330.755, 737.282, 368.641, 368.641])\n\n# --- Blade Definition --- #\n\n# geometry\nblade_xyz = [\n     0.0        0.0   0.0;\n     2.26837    0.0   1.257;\n     3.63183    0.0   2.095;\n     6.76113    0.0   4.19;\n     9.55882    0.0   6.285;\n    11.8976     0.0   8.38;\n    13.7306     0.0  10.475;\n    15.1409     0.0  12.57;\n    16.1228     0.0  14.665;\n    16.7334     0.0  16.76;\n    17.0133     0.0  18.855;\n    17.0987     0.0  20.95;\n    16.9615     0.0  23.045;\n    16.5139     0.0  25.14;\n    15.7435     0.0  27.235;\n    14.5458     0.0  29.33;\n    12.9287     0.0  31.425;\n    10.8901     0.0  33.52;\n     8.547      0.0  35.615;\n     5.93739    0.0  37.71;\n     3.05842    0.0  39.805;\n     1.87486    0.0  40.643;\n     0.0        0.0  41.9\n]\n\n# section boundaries (z-coordinate)\nblade_transition = [0.0, 5.8, 11.1, 29.0, 34.7, 41.9]\n\n# root section properties\n\nblade_stiffness1 = [\n    3.74563e9  0.0        0.0        0.0        0.0        1.14382e8;\n    0.0        1.20052e9  0.0        0.0        0.0        0.0;\n    0.0        0.0        1.20052e9  0.0        0.0        0.0;\n    0.0        0.0        0.0        1.87992e7  0.0        0.0;\n    0.0        0.0        0.0        0.0        2.24336e7  0.0;\n    1.14382e8  0.0        0.0        0.0        0.0        4.09242e8;\n]\n\nblade_mass1 = [\n    146.781     0.0       0.0      0.0     28.7783     0.0;\n      0.0     146.781     0.0    -28.7783   0.0        0.0;\n      0.0       0.0     146.781    0.0      0.0        0.0;\n      0.0     -28.7783    0.0     16.7793   0.0        0.0;\n     28.7783    0.0       0.0      0.0      0.879112  -0.0;\n      0.0       0.0       0.0      0.0     -0.0       15.9002;\n]\n\n# transition section properties\n\nblade_stiffness2 = [\n    2.22783e9  0.0        0.0        0.0        0.0        4.20422e7;\n    0.0        7.14048e8  0.0        0.0        0.0        0.0;\n    0.0        0.0        7.14048e8  0.0        0.0        0.0;\n    0.0        0.0        0.0        6.55493e6  0.0        0.0;\n    0.0        0.0        0.0        0.0        7.35548e6  0.0;\n    4.20422e7  0.0        0.0        0.0        0.0        1.84227e8;\n]\n\nblade_mass2 = [\n    87.3025    0.0      0.0       0.0      16.7316     0.0;\n     0.0      87.3025   0.0     -16.7316    0.0        0.0;\n     0.0       0.0     87.3025   -0.0       0.0        0.0;\n     0.0     -16.7316  -0.0       7.47649   0.0        0.0;\n    16.7316    0.0      0.0       0.0       0.288241  -0.0;\n     0.0       0.0      0.0       0.0      -0.0        7.18825;\n]\n\n# center section properties\n\nblade_stiffness3 = [\n    1.76888e9  0.0        0.0        0.0        0.0        2.34071e7;\n    0.0        5.66947e8  0.0        0.0        0.0        0.0;\n    0.0        0.0        5.66947e8  0.0        0.0        0.0;\n    0.0        0.0        0.0        4.00804e6  0.0        0.0;\n    0.0        0.0        0.0        0.0        4.34302e6  0.0;\n    2.34071e7  0.0        0.0        0.0        0.0        1.09341e8;\n]\n\nblade_mass3 = [\n    69.3173    0.0      0.0       0.0      11.5831     0.0;\n     0.0      69.3173   0.0     -11.5831    0.0        0.0;\n     0.0       0.0     69.3173   -0.0       0.0        0.0;\n     0.0     -11.5831  -0.0       4.44282   0.0        0.0;\n    11.5831    0.0      0.0       0.0       0.170191  -0.0;\n     0.0       0.0      0.0       0.0      -0.0        4.27263;\n]\n\n# --- Strut Definition --- #\n\nstrut_locations = [1.257, 40.643]\nstrut_stiffness = blade_stiffness1\nstrut_mass = blade_mass1\n\n# --- Define Assembly --- #\n\n# Tower\n\n# number of tower sections\nnt = 22\n\n# tower points\nx = zeros(nt+1)\ny = zeros(nt+1)\nz = vcat(0, range(strut_locations[1], strut_locations[2]; length=nt-1), tower_height)\npt_t = [[x[i],y[i],z[i]] for i = 1:nt+1]\n\n# tower frame of reference\nframe_t = fill([0 0 1; 0 1 0; -1 0 0], nt)\n\n# tower stiffness\nstiff_t = fill(tower_stiffness, nt)\n\n# tower mass\nmass_t = fill(tower_mass, nt)\n\n# Blades\n\n# number of blade sections\nnbr = 4 # root\nnbt = 3 # transition\nnbc = 8 # center\nnb = 2*nbr + 2*nbt + nbc # total number of blade sections\n\n# interpolation parameter coordinates\nnew_z = vcat(0.0,\n    range(strut_locations[1], 5.8, length=nbr)[1:end-1],\n    range(5.8, 11.1, length=nbt+1)[1:end-1],\n    range(11.1, 29.0, length=nbc+1)[1:end-1],\n    range(29.0, 34.7, length=nbt+1)[1:end-1],\n    range(34.7, strut_locations[2], length=nbr),\n    tower_height)\n\n# blade points\nx = FLOWMath.akima(blade_xyz[:,3], blade_xyz[:,1], new_z)\ny = zero(new_z)\nz = new_z\npt_bl = [[-x[i],y[i],z[i]] for i = 1:nb+1] # left blade\npt_br = [[x[i],y[i],z[i]] for i = 1:nb+1] # right blade\n\n# left blade frame of reference\nframe_bl = Vector{Matrix{Float64}}(undef, nb)\nfor i = 1:nb\n    r = pt_bl[i+1] - pt_bl[i]\n    n = norm(r)\n    s = r[3]/n\n    c = r[1]/n\n    frame_bl[i] = [c 0 -s; 0 1 0; s 0 c]\nend\n\n# right blade frame of reference\nframe_br = Vector{Matrix{Float64}}(undef, nb)\nfor i = 1:nb\n    r = pt_br[i+1] - pt_br[i]\n    n = norm(r)\n    s = r[3]/n\n    c = r[1]/n\n    frame_br[i] = [c 0 -s; 0 1 0; s 0 c]\nend\n\n# blade stiffness\nstiff_b = vcat(\n    fill(blade_stiffness1, nbr),\n    fill(blade_stiffness2, nbt),\n    fill(blade_stiffness3, nbc),\n    fill(blade_stiffness2, nbt),\n    fill(blade_stiffness1, nbr)\n)\n\n# blade mass\nmass_b = vcat(\n    fill(blade_mass1, nbr),\n    fill(blade_mass2, nbt),\n    fill(blade_mass3, nbc),\n    fill(blade_mass2, nbt),\n    fill(blade_mass1, nbr)\n)\n\n# Struts\n\n# number of strut sections per strut\nns = 3\n\n# lower left strut points\nx = range(0.0, pt_bl[2][1]; length=ns+1)\ny = zeros(ns+1)\nz = fill(strut_locations[1], ns+1)\npt_s1 = [[x[i],y[i],z[i]] for i = 1:ns+1]\n\n# lower right strut points\nx = range(0.0, pt_br[2][1]; length=ns+1)\ny = zeros(ns+1)\nz = fill(strut_locations[1], ns+1)\npt_s2 = [[x[i],y[i],z[i]] for i = 1:ns+1]\n\n# upper left strut points\nx = range(0.0, pt_bl[end-1][1]; length=ns+1)\ny = zeros(ns+1)\nz = fill(strut_locations[2], ns+1)\npt_s3 = [[x[i],y[i],z[i]] for i = 1:ns+1]\n\n# upper right strut points\nx = range(0.0, pt_br[end-1][1]; length=ns+1)\ny = zeros(ns+1)\nz = fill(strut_locations[2], ns+1)\npt_s4 = [[x[i],y[i],z[i]] for i = 1:ns+1]\n\n# strut frame of reference\nframe_s = fill([1 0 0; 0 1 0; 0 0 1], ns)\n\n# strut stiffness\nstiff_s = fill(strut_stiffness, ns)\n\n# strut mass\nmass_s = fill(strut_mass, ns)\n\n# Combine Tower, Blades, and Struts\n\n# combine points\npoints = vcat(pt_t, pt_bl, pt_br, pt_s1, pt_s2, pt_s3, pt_s4)\n\n# define element connectivity\nistart = cumsum([1, nt+1, nb+1, nb+1, ns+1, ns+1, ns+1])\nistop = cumsum([nt+1, nb+1, nb+1, ns+1, ns+1, ns+1, ns+1])\nstart = vcat([istart[i]:istop[i]-1 for i = 1:length(istart)]...)\nstop = vcat([istart[i]+1:istop[i] for i = 1:length(istart)]...)\n\n# use zero-length elements as joints\n\nnj = 12 # number of joints\n\njoints = [\n    istart[1]     istart[2]; # tower - bottom of left blade\n    istart[1]     istart[3]; # tower - bottom of right blade\n    istart[1]+1   istart[4]; # tower - lower left strut\n    istart[1]+1   istart[5]; # tower - lower right strut\n    istop[1]-1    istart[6]; # tower - upper left strut\n    istop[1]-1    istart[7]; # tower - upper right strut\n    istop[2]      istop[1]; # top of left blade - tower\n    istop[3]      istop[1]; # top of right blade - tower\n    istop[4]      istart[2]+1; # lower left strut - left blade\n    istop[5]      istart[3]+1; # lower right strut - right blade\n    istop[6]      istop[2]-1; # upper left strut - left blade\n    istop[7]      istop[3]-1; # upper right strut - right blade\n]\n\nframe_j = fill([1 0 0; 0 1 0; 0 0 1], nj)\n\nstiff_j = fill(zeros(6,6), nj) # will be modeled as infinitely stiff\n\nmass_j = fill(zeros(6,6), nj)\n\n# add joint connectivity\nstart = vcat(start, joints[:,1])\nstop = vcat(stop, joints[:,2])\n\n# combine frames\nframes = vcat(frame_t, frame_bl, frame_br, frame_s, frame_s, frame_s, frame_s, frame_j)\n\n# combine stiffness\nstiffness = vcat(stiff_t, stiff_b, stiff_b, stiff_s, stiff_s, stiff_s, stiff_s, stiff_j)\n\n# combine mass\nmass = vcat(mass_t, mass_b, mass_b, mass_s, mass_s, mass_s, mass_s, mass_j)\n\n# create assembly\nassembly = Assembly(points, start, stop;\n    frames=frames,\n    stiffness=stiffness,\n    mass=mass)\n\n# --- Define Prescribed Conditions --- #\n\n# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # fixed base\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    # fixed top, but free to rotate around z-axis\n    istop[1] => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0),\n)\n\n# --- Perform Analysis --- #\n\n# revolutions per minute\nrpm = 0:1:40\n\n# gravity vector\ngravity = [0, 0, -9.81]\n\n# number of modes\nnmode = 10\n\n# number of eigenvalues\nnev = 2*nmode\n\n# initialize system storage\nsystem = DynamicSystem(assembly)\n\n# storage for results\nfreq = zeros(length(rpm), nmode)\n\n# perform an analysis for each rotation rate\nfor (i,rpm) in enumerate(rpm)\n\n    global system, Up\n\n    # set turbine rotation\n    angular_velocity = [0, 0, rpm*(2*pi)/60]\n\n    # eigenvalues and (right) eigenvectors\n    system, λ, V, converged = eigenvalue_analysis!(system, assembly;\n        prescribed_conditions = prescribed_conditions,\n        angular_velocity = angular_velocity,\n        gravity = gravity,\n        nev = nev\n        )\n\n    # check convergence\n    @assert converged\n\n    if i > 1\n        # construct correlation matrix\n        C = Up*system.M*V\n\n        # correlate eigenmodes\n        perm, corruption = correlate_eigenmodes(C)\n\n        # re-arrange eigenvalues\n        λ = λ[perm]\n\n        # update left eigenvector matrix\n        Up = left_eigenvectors(system, λ, V)\n        Up = Up[perm,:]\n    else\n        # update left eigenvector matrix\n        Up = left_eigenvectors(system, λ, V)\n    end\n\n    # save frequencies\n    freq[i,:] = [imag(λ[k])/(2*pi) for k = 1:2:nev]\n\nend","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"We can compare the computed mode frequencies with experimental data taken from SAND-91-2228.","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"using Plots\nusing Suppressor #hide\npyplot()\n\n@suppress_err begin #hide\n\n# Experimental Data\nSNL34_flap = [\n    -0.11236  3.4778;\n    20.1124   4.08516;\n    20.1124   3.92961;\n    20.1124   3.72961;\n    20.2247   2.47403;\n    24.1573   2.4733;\n    28.2022   2.57256;\n    30.2247   2.5944;\n    31.9101   2.62742;\n    33.2584   2.63829;\n    34.1573   2.70479;\n    34.2697   2.57143;\n    34.2697   2.40476;\n    28.2022   2.46144;\n    20.1124   2.30739;\n    10.0      2.23148;\n    10.0      2.17593;\n    10.0      2.0537;\n    39.6629   1.38154;\n    37.3034   1.31531;\n    36.0674   1.25999;\n    36.1798   1.31552;\n    34.1573   1.24923;\n    32.0225   1.23851;\n    30.6742   1.20543;\n    28.2022   1.18367;\n    20.2247   1.08514;\n    20.2247   1.18514;\n    28.2022   1.27256;\n    32.0225   1.34963;\n    34.0449   1.38258;\n    15.1685   1.13052;\n    15.1685   1.04164;\n    10.0      1.03148;\n     0.0      1.06667;\n     0.0      2.13333;\n]\n\nSNL34_lead = [\n     0.0      3.57778;\n    -0.11236  2.51113;\n    -0.11236  1.80002;\n    10.0      1.78704;\n    15.1685   1.75275;\n    20.1124   1.67405;\n    30.2247   1.63885;\n    32.0225   1.50518;\n    35.0562   1.54906;\n    36.0674   1.55999;\n    39.5506   1.52601;\n    39.3258   2.04827;\n    36.9663   2.0376;\n    35.8427   2.04892;\n    34.9438   2.0602;\n    34.0449   2.08258;\n    32.0225   2.09407;\n    30.2247   2.10551;\n    24.4944   2.09546;\n    30.1124   2.42776;\n    24.1573   2.29553;\n    20.1124   2.22961;\n    20.0      2.37407;\n    10.0      2.48704;\n     9.88764  3.55372;\n    14.9438   3.54168;\n    10.0      3.86481;\n    20.1124   3.59628;\n    24.1573   3.58442;\n    24.2697   3.85106;\n    28.0899   3.63924;\n    30.0      3.66111;\n    32.0225   3.67185;\n    33.0337   3.69388;\n    34.1573   3.67145;\n    35.1685   3.68238;\n    35.1685   3.68238;\n    36.1798   3.6933;\n    37.0787   3.71536;\n    34.9438   4.0602;\n    35.9551   4.16001;\n]\n\nSNL34_1F = [\n     0.11236  1.06665;\n     7.19101  1.05422;\n    14.1573   1.05293;\n    20.2247   1.10737;\n    28.0899   1.18369;\n    34.1573   1.26034;\n    37.0787   1.31536;\n    39.7753   1.39263;\n]\n\nSNL34_1BE = [\n     0.0      1.81111;\n     6.85393  1.79873;\n    14.9438   1.75279;\n    20.2247   1.67403;\n    30.0      1.63889;\n    35.1685   1.57127;\n]\n\nSNL34_2FA = [\n    -0.11236  2.13335;\n     7.64045  2.13192;\n    10.0      2.10926;\n    19.5506   2.15194;\n    26.7416   2.38394;\n    30.5618   2.41656;\n    34.2697   2.59365;\n]\n\nSNL34_2FS = [\n    -0.11236  2.13335;\n    10.1124   2.23146;\n    15.3933   2.27493;\n    26.2921   2.52846;\n    34.1573   2.70479;\n]\n\nSNL34_1TO = [\n     0.0      2.5;\n     4.04494  2.49925;\n     9.77528  2.49819;\n    16.6292   2.43025;\n    20.2247   2.39625;\n    24.382    2.11771;\n    30.6742   2.09432;\n    35.0562   2.0824;\n]\n\nSNL34_3F = [\n    -0.11236  3.58891;\n     9.88764  3.55372;\n    15.1685   3.57497;\n    20.2247   3.59625;\n    25.5056   3.62861;\n    30.7865   3.66097;\n    34.0449   3.6937;\n    37.191    3.73756;\n]\n\n# Initialize Plot\nplot(\n    xlabel=\"Rotor Speed (RPM)\",\n    ylabel=\"Frequency (Hz)\",\n    xlim = (0, 40.0),\n    legend = :topleft,\n    grid=true)\n\n# Add computational results\nfor i=1:1:nmode\n    plot!(rpm, freq[:,i], color=:red, linestyle=:solid, label=\"\")\nend\n\n# Add experimental results\nscatter!(SNL34_flap[:,1],SNL34_flap[:,2], color=:black, markerstyle=:dot, label=\"Flatwise\")\nscatter!(SNL34_lead[:,1],SNL34_lead[:,2], color=:black, markershape=:x, label=\"Lead-Lag\")\nplot!(SNL34_1F[:,1], SNL34_1F[:,2], color=:black, linestyle=:dash, label=\"\")\nplot!(SNL34_1BE[:,1], SNL34_1BE[:,2], color=:black, linestyle=:solid, label=\"\")\nplot!(SNL34_2FA[:,1], SNL34_2FA[:,2], color=:black, linestyle=:solid, label=\"\")\nplot!(SNL34_2FS[:,1], SNL34_2FS[:,2], color=:black, linestyle=:solid, label=\"\")\nplot!(SNL34_1TO[:,1], SNL34_1TO[:,2], color=:black, linestyle=:dash, label=\"Tower Mode\")\nplot!(SNL34_3F[:,1], SNL34_3F[:,2], color=:black, linestyle=:solid, label=\"\")\n\n# Add per-revolution lines\nfor i = 1:6\n    lx = [rpm[1], rpm[end]+10]\n    ly = [rpm[1], rpm[end]+10].*i./60.0\n    plot!(lx, ly, color=:black, linestyle=:dash, linewidth=0.5, label=\"\")\n    annotate!(0.95*lx[2], ly[2]+.05+(i-1)*.01, text(\"$i P\", 10))\nend\n\n# Add legend entries\nplot!([0], [0], color=:black, label=\"Experimental\")\nplot!([0], [0], color=:red, label=\"GXBeam\")\n\nplot!(show=true)\nsavefig(\"../assets/vawt-stability.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"(Image: )","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"As can be seen, there is good agreement between the computational and experimental results.","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"state = AssemblyState(system, assembly; prescribed_conditions=prescribed_conditions)\n\nmkpath(\"vawt-simulation\")\nwrite_vtk(\"vawt-simulation/vawt-simulation\", assembly, state)\nrm(\"vawt-simulation\"; recursive=true) #hide","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"(Image: )","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"","category":"page"},{"location":"examples/vertical-axis-wind-turbine/","page":"Sandia 34-Meter Vertical Axis Wind Turbine","title":"Sandia 34-Meter Vertical Axis Wind Turbine","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/dynamic-joined-wing.jl\"","category":"page"},{"location":"examples/dynamic-joined-wing/#dynamic-joined-wing","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"","category":"section"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"In this example we use the same joined-wing model as used in the previous example, but with the following time varying loads applied at the wingtip:","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"A piecewise-linear load F_L in the x and y-directions defined as follows:","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"F_L(t) = begincases\n    t10^6 text N  0 leq t leq 001 \n    (002-t)10^6  001 leq t leq 002 \n    0  textotherwise\nendcases","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"A sinusoidal load F_S applied in the z-direction defined as follows:","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"F_S(t) = begincases\n    0  t lt 0 \n    5 times 10^3 (1-cos(pi t 002)) text N  0 leq t lt 002 \n    10^4 text N  002 leq t\nendcases","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"We will also use the same compliance and mass matrix for all beams, in order to simplify the problem definition.","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"(Image: )","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"tip: Tip\nThis example is also available as a Jupyter notebook: dynamic-joined-wing.ipynb.","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"using GXBeam, LinearAlgebra\n\n# Set endpoints of each beam\np1 = [0, 0, 0]\np2 = [-7.1726, -12, -3.21539]\np3 = [7.1726, -12,  3.21539]\n\nCab_1 = [\n0.5         0.866025  0.0\n0.836516    -0.482963  0.258819\n0.224144     -0.12941   -0.965926\n]\n\nCab_2 = [\n0.5         0.866025  0.0\n-0.836516    0.482963 0.258819\n0.224144    -0.12941   0.965926\n]\n\n# beam 1\nL_b1 = norm(p1-p2)\nr_b1 = p2\nnelem_b1 = 8\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1, frame=Cab_1)\n\n# beam 2\nL_b2 = norm(p3-p1)\nr_b2 = p1\nnelem_b2 = 8\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, frame=Cab_2)\n\n# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2\npoints = vcat(xp_b1, xp_b2[2:end])\nstart = 1:nelem\nstop = 2:nelem + 1\nlengths = vcat(lengths_b1, lengths_b2)\nmidpoints = vcat(xm_b1, xm_b2)\nCab = vcat(Cab_b1, Cab_b2)\n\n# assign all beams the same compliance and mass matrix\ncompliance = fill(Diagonal([2.93944738387698e-10, 8.42991725049126e-10,\n    3.38313996669689e-08, 4.69246721094557e-08, 6.79584100559513e-08,\n    1.37068861370898e-09]), nelem)\nmass = fill(Diagonal([4.86e-2, 4.86e-2, 4.86e-2, 1.0632465e-2, 2.10195e-4,\n    1.042227e-2]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop;\n    compliance = compliance,\n    mass = mass,\n    frames = Cab,\n    lengths = lengths,\n    midpoints = midpoints)\n\nF_L = (t) -> begin\n    if 0.0 <= t < 0.01\n        1e6*t\n    elseif 0.01 <= t < 0.02\n        -1e6*(t-0.02)\n    else\n        zero(t)\n    end\nend\n\nF_S = (t) -> begin\n    if t < 0.0\n        zero(t)\n    elseif 0.0 <= t < 0.02\n        5e3*(1-cos(pi*t/0.02))\n    else\n        1e4\n    end\nend\n\n# assign boundary conditions and point load\nprescribed_conditions = (t) -> begin\n    Dict(\n        # fixed endpoint on beam 1\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force applied on point 4\n        nelem_b1 + 1 => PrescribedConditions(Fx=F_L(t), Fy=F_L(t), Fz=F_S(t)),\n        # fixed endpoint on last beam\n        nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    )\nend\n\n# time\nt = range(0, 0.04, length=1001)\n\nsystem, history, converged = time_domain_analysis(assembly, t;\n    prescribed_conditions=prescribed_conditions,\n    structural_damping=false)\n\nnothing #hide","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"We can visualize tip displacements and the resultant forces accessing the post-processed results for each time step contained in the variable history.  Note that the fore-root and rear-root resultant forces for this case are equal to the external forces/moments, but with opposite sign.","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"using Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\npoint = vcat(fill(nelem_b1+1, 6), fill(1, 6))\nfield = [:u, :u, :u, :theta, :theta, :theta, :F, :F, :F, :M, :M, :M]\ndirection = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\nylabel = [\"\\$u_x\\$ (\\$m\\$)\", \"\\$u_y\\$ (\\$m\\$)\", \"\\$u_z\\$ (\\$m\\$)\",\n    \"Rodriguez Parameter \\$\\\\theta_x\\$\", \"Rodriguez Parameter \\$\\\\theta_y\\$\",\n    \"Rodriguez Parameter \\$\\\\theta_z\\$\", \"\\$F_x\\$ at the forewing root (\\$N\\$)\",\n    \"\\$F_y\\$ at the forewing root (\\$N\\$)\", \"\\$F_z\\$ at the forewing root (\\$N\\$)\",\n    \"\\$M_x\\$ at the forewing root (\\$Nm\\$)\", \"\\$M_y\\$ at the forewing root (\\$Nm\\$)\",\n    \"\\$M_z\\$ at the forewing root (\\$N\\$)\"]\n\nfor i = 1:12\n    plot(\n        xlim = (0, 0.04),\n        xticks = 0:0.01:0.04,\n        xlabel = \"Time (s)\",\n        ylabel = ylabel[i],\n        grid = false,\n        overwrite_figure=false\n        )\n    y = [getproperty(state.points[point[i]], field[i])[direction[i]] for state in history]\n\n    if field[i] == :theta\n        # convert to angle\n        @. y = 4*atan(y/4)\n    end\n\n    if field[i] == :F || field[i] == :M\n        y = -y\n    end\n\n    plot!(t, y, label=\"\")\n    plot!(show=true)\n    savefig(\"../assets/dynamic-joined-wing-\"*string(field[i])*string(direction[i])*\".svg\"); #hide\n    closeall() #hide\nend\n\n\nend #hide\nnothing #hide","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"These graphs are identical to those presented in \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and Maxwell Blair.","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"We can also visualize the time history of the system using ParaView.  In order to view the small deflections we'll scale all the deflections up by a couple orders of magnitude.  We'll also set the color gradient to match the magnitude of the deflections at each point.","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"airfoil  = [ #FX 60-100 airfoil\n    0.0000000 0.0000000;\n    0.0010700 0.0057400;\n    0.0042800 0.0114400;\n    0.0096100 0.0177500;\n    0.0170400 0.0236800;\n    0.0265300 0.0294800;\n    0.0380600 0.0352300;\n    0.0515600 0.0405600;\n    0.0669900 0.0460900;\n    0.0842700 0.0508600;\n    0.1033200 0.0556900;\n    0.1240800 0.0598900;\n    0.1464500 0.0640400;\n    0.1703300 0.0675400;\n    0.1956200 0.0708100;\n    0.2222100 0.0733900;\n    0.2500000 0.0756500;\n    0.2788600 0.0772000;\n    0.3086600 0.0783800;\n    0.3392800 0.0788800;\n    0.3705900 0.0789800;\n    0.4024500 0.0784500;\n    0.4347400 0.0775000;\n    0.4673000 0.0759600;\n    0.5000000 0.0740900;\n    0.5327000 0.0717400;\n    0.5652600 0.0691100;\n    0.5975500 0.0660800;\n    0.6294100 0.0627500;\n    0.6607200 0.0590500;\n    0.6913400 0.0551100;\n    0.7211400 0.0508900;\n    0.7500000 0.0465200;\n    0.7777900 0.0420000;\n    0.8043801 0.0374700;\n    0.8296700 0.0329800;\n    0.8535500 0.0286400;\n    0.8759201 0.0244700;\n    0.8966800 0.0205300;\n    0.9157300 0.0168100;\n    0.9330100 0.0134200;\n    0.9484400 0.0103500;\n    0.9619400 0.0076600;\n    0.9734700 0.0053400;\n    0.9829600 0.0034100;\n    0.9903900 0.0019300;\n    0.9957200 0.0008600;\n    0.9989300 0.0002300;\n    1.0000000 0.0000000;\n    0.9989300 0.0001500;\n    0.9957200 0.0007000;\n    0.9903900 0.0015100;\n    0.9829600 0.00251;\n    0.9734700 0.00377;\n    0.9619400 0.00515;\n    0.9484400 0.00659;\n    0.9330100 0.00802;\n    0.9157300 0.00941;\n    0.8966800 0.01072;\n    0.8759201 0.01186;\n    0.8535500 0.0128;\n    0.8296700 0.01347;\n    0.8043801 0.01381;\n    0.7777900 0.01373;\n    0.7500000 0.01329;\n    0.7211400 0.01241;\n    0.6913400 0.01118;\n    0.6607200 0.00951;\n    0.6294100 0.00748;\n    0.5975500 0.00496;\n    0.5652600 0.00217;\n    0.532700  -0.00092;\n    0.500000  -0.00405;\n    0.467300  -0.00731;\n    0.434740  -0.01045;\n    0.402450  -0.01357;\n    0.370590  -0.01637;\n    0.339280  -0.01895;\n    0.308660  -0.021;\n    0.278860  -0.02275;\n    0.250000  -0.02389;\n    0.222210  -0.02475;\n    0.195620  -0.025;\n    0.170330  -0.02503;\n    0.146450  -0.02447;\n    0.124080  -0.02377;\n    0.103320  -0.02246;\n    0.084270  -0.0211;\n    0.066990  -0.01913;\n    0.051560  -0.0173;\n    0.038060  -0.01481;\n    0.026530  -0.01247;\n    0.017040  -0.0097;\n    0.009610  -0.00691;\n    0.004280  -0.00436;\n    0.001070  -0.002;\n    0.0        0.0;\n]\n\nsection = zeros(3, size(airfoil, 1))\nfor ic = 1:size(airfoil, 1)\n    section[1,ic] = airfoil[ic,1] - 0.5\n    section[2,ic] = 0\n    section[3,ic] = airfoil[ic,2]\nend\n\nmkpath(\"dynamic-joined-wing-simulation\")\nwrite_vtk(\"dynamic-joined-wing-simulation/dynamic-joined-wing-simulation\", assembly, history, t, scaling=1e2;\n    sections = section)\nrm(\"dynamic-joined-wing-simulation\"; recursive=true) #hide","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"(Image: )","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"","category":"page"},{"location":"examples/dynamic-joined-wing/","page":"Time-Domain Simulation of a Joined-Wing","title":"Time-Domain Simulation of a Joined-Wing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/reference/#Library","page":"API Reference","title":"Library","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"reference/reference/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"reference/reference/#Creating-an-Assembly","page":"API Reference","title":"Creating an Assembly","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"curve_length\ndiscretize_beam\nAssembly\nAssembly(points, start, stop)","category":"page"},{"location":"reference/reference/#GXBeam.curve_length","page":"API Reference","title":"GXBeam.curve_length","text":"curve_length(start, stop, curvature)\n\nCalculate the length of a curve given its endpoints and its curvature vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.discretize_beam","page":"API Reference","title":"GXBeam.discretize_beam","text":"discretize_beam(L, start, discretization; frame, curvature)\n\nDiscretize a beam of length L located at start according to the discretization provided  in discretization\n\nReturn the lengths, endpoints, midpoints, and reference frame of the beam elements.\n\nArguments\n\nL: Beam length\nstart: Beam starting point\ndiscretization: Number of beam elements, or the normalized endpoints of each beam       element, with values ranging from 0 to 1.\n\nKeyword Arguments\n\nframe: Reference frame at the start of the beam element, represented by a 3x3       transformation matrix from the undeformed local frame to the body frame.\ncurvature: curvature vector\n\n\n\n\n\ndiscretize_beam(start, stop, discretization; frame, curvature)\n\nDiscretize a beam from start to stop according to the discretization provided in  discretization.\n\nReturn the lengths, endpoints, midpoints, and reference frame of the beam elements.\n\nArguments\n\nstart: Beam starting point\nstop: Beam ending point\ndiscretization: Number of beam elements, or the normalized endpoints of each beam       element, with values ranging from 0 to 1.\n\nKeyword Arguments\n\nframe: Reference frame at the start of the beam element, represented by a 3x3      transformation matrix from the undeformed local frame to the body frame.\ncurvature: curvature vector\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.Assembly","page":"API Reference","title":"GXBeam.Assembly","text":"Assembly{TF, TP<:AbstractVector{<:AbstractVector{TF}},\n    TC<:AbstractVector{<:Integer}, TE<:AbstractVector{Element{TF}}}\n\nComposite type that defines an assembly of connected nonlinear beam elements.\n\nFields\n\npoints: Array of all beam element endpoints\nstart: Array containing point index where each beam element starts\nstop: Array containing point index where each beam element stops\nelements: Array containing beam element definitions (see Element)\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.Assembly-Tuple{Any, Any, Any}","page":"API Reference","title":"GXBeam.Assembly","text":"Assembly(points, start, stop; kwargs...)\n\nConstruct an assembly of connected nonlinear beam elements.  Beam lengths and midpoints  may be manually specified in case beam elements are curved rather than straight.\n\nArguments\n\npoints: Array of all beam element endpoints\nstart: Array containing point indices where each beam element starts\nstop: Array containing point indices where each beam element stops\n\nKeyword Arguments\n\nstiffness: Array of (6 x 6) stiffness matrices for each beam element,       acts as an alternative to providing compliance\ncompliance: Array of (6 x 6) compliance matrices for each beam element,       defaults to zeros(6,6) for each beam element\nmass: Array of (6 x 6) mass matrices for each beam element,       defaults to zeros(6,6) for each beam element\nframes: Array of (3 x 3) tranformation matrices for each beam element.      Transforms from the local undeformed beam frame to the global frame) and defaults      to the identity matrix for each beam element\nlengths: Array containing the length of each beam, defaults to the distance between       beam endpoints\nmidpoints: Array containing the midpoint of each beam element, defaults to the average       of the beam element endpoints\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#Section-Properties","page":"API Reference","title":"Section Properties","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"Material\nNode\nMeshElement\nLayer\nafmesh\ninitialize_cache\ncompliance_matrix\nmass_matrix\nplotmesh","category":"page"},{"location":"reference/reference/#GXBeam.Material","page":"API Reference","title":"GXBeam.Material","text":"Material(E1, E2, E3, G12, G13, G23, nu12, nu13, nu23, rho, \n    S1t=1.0, S1c=1.0, S2t=1.0, S2c=1.0, S3t=1.0, S3c=1.0, S12=1.0, S13=1.0, S23=1.0)\n\nGeneral orthotropic material properties.  1 is along main ply axis. 2 is transverse. 3 is normal to ply. for a fiber orientation of zero, 1 is along the beam axis. strength properties are optional\n\nArguments\n\nEi:float: Young's modulus along 1st, 2nd and 3rd axes.\nGij::float: shear moduli\nnuij::float: Poisson's ratio.  nu_ij E_j = nu_ji E_i\nrho::float: density\nSit/c::float: strength in ith direction for tension and compression\nSij::float: strength in ij direction\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.Node","page":"API Reference","title":"GXBeam.Node","text":"Node(x, y)\n\nA node in the finite element mesh at location x, y.  If assembled in a vector, the vector index corresponds to the node number.\n\nArguments\n\nx::float: x location of node in global coordinate system\ny::float: y location of node in global coordinate system\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.MeshElement","page":"API Reference","title":"GXBeam.MeshElement","text":"MeshElement(nodenum, material, theta)\n\nAn element in the mesh, consisting of four ordered nodes, a material, and a fiber orientation.\n\nArguments\n\nnodenum::Vector{integer}: a vector of four node numbers corresponding the the four nodes defining this element (vector indices of the nodes).    Node order should be counterclockwise starting from the bottom left node using the local coordinate sytem (see figure).\nmaterial::Material: material properties of this element\ntheta::float: fiber orientation\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.Layer","page":"API Reference","title":"GXBeam.Layer","text":"Layer(material, t, theta)\n\nA layer (could be one ply or many plys of same material). A layup is a vector of layers.\n\nArguments\n\nmaterial::Material: material of layer\nt::float: thickness of layer\ntheta::float: fiber orientation (rad)\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.afmesh","page":"API Reference","title":"GXBeam.afmesh","text":"afmesh(xaf, yaf, chord, twist, paxis, xbreak, webloc, segments, webs; ds=nothing, dt=nothing, ns=nothing, nt=nothing, wns=4, wnt=nothing)\n\nCreate structural mesh for airfoil.  The airfoil coordinates define the meshing density tangential to the airfoil. Whereas the number of layers defines the resolution normal to the airfoil. All segments are meshed with the same resolution in the normal direction, using the number of grid points as defined by segment with the most layers.\n\nArguments\n\nxaf, yaf::Vector{float}: points defining airfoil start at trailing edge and traverse counterclockwise back to trailing edge (can be blunt or sharp T.E.)\nchord::float: chord length\ntwist::float: twist angle (rad)\npaxis::float: pitch axis (normalized by chord). e.g., 0.25 means twist about quarter chord.\nxbreak::Vector{float}: x-locations, normalized by chord, defining break points between segments. must start at 0 and end at 1. e.g., [0, 0.2, 0.4, 0.7, 1.0] defines 4 segments.\nwebloc::Vector{float}: x-locations, normalized by chord, defining web centers (and length of vector is number of webs).  e.g., [0.25, 0.55] means there is a web at 25% chord and a second web at 55% chord.\nsegments::Vector{Vector{Layer}}: A Layer defines a ply (or multiple plys with the same material/orientation).  At a given x location the ply stack (segment) is defined a vector of layers starting from outside surface towards inside. Segments then is a vector of these segments that defines properties between segments as defined by xbreak.\nwebs::Vector{Vector{Layer}}: same structure as segments, except each inner vector is from left to right (although this is usually symmetric), and each outer vector is for a separate web\nds::float: if provided, airfoil spacing will be resampling with approximately this spacing, normalized by chord.  e.g., 0.01 will have points on the airfoil roughly 1% chord apart.\ndt::float: if provided, thickness will be resampled with this maximum mesh size (thickness is absolute). Note that the total number of cells remains constant along airfoil, so most thicknesses will be much less.  e.g., 0.01 will target a maximum mesh thickness of 0.01 (absolute).\nns::vector{int}: if provided, rather than use a targert size ds, we specify the number of cells to use in each segment.  This is desirable for gradient-based optimization, if airfoil coordinates are changed, so that during resizing operations the  mesh stretch/shrinks rather than experiencing discrete jumps.  For example, ns=[15, 20, 40, 30] would use 15 elements between xbreak[1] and xbreak[2] and so on.  \nnt::vector{vector{int}}: if provided, defines how many elements to use across tangential direction.  Again, prefered over dt for gradient-based optimization, if the thicknesses are changed during optimization.  each entry defines how many cells to put in that layer following order of original layup.  for example, nt=[[1, 2, 1], [1, 3]] would use 1 element, 2 elements (subdivide), then 1 elements over first sector, and so on.\nwns::int: discretization level for number of elements vertically along web.\nwnt::vector{vector{int}}: same definition as nt but for the webs\n\nReturns\n\nnodes::Vector{Node{Float64}}: nodes for this mesh\nelements::Vector{MeshElement{Vector{Int},Float64}}: elements for this mesh\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initialize_cache","page":"API Reference","title":"GXBeam.initialize_cache","text":"initialize_cache(nodes, elements, etype=Float64)\n\ncreate cache.  set sizes of static matrices, and set sparsity patterns for those that are fixed.\n\nArguments\n\netype::Type: the element type (typically a float or a dual type)\nd::Int: the number of variables you are taking derivatives w.r.t (i.e., number of design variables)\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.compliance_matrix","page":"API Reference","title":"GXBeam.compliance_matrix","text":"compliance_matrix(nodes, elements; cache=initialize_cache(nodes, elements), gxbeam_order=true)\n\nCompute compliance matrix given the finite element mesh described by nodes and elements.\n\nArguments\n\nnodes::Vector{Node{TF}}: all the nodes in the mesh\nelements::Vector{MeshElement{VI, TF}}: all the elements in the mesh\ncache::SectionCache: if number of nodes, number of elements, and connectivity of mesh stays the same (and you will be repeating calls)   then you can should initialize cache yourself and pass in so you don't have to keep reconstructing it.\ngxbeam_order::Bool: true if output compliance matrix should be in GXBeam order or internal ordering\n\nReturns\n\nS::Matrix: compliance matrix (about the shear center as long as gxbeam_order = true)\nsc::Vector{float}: x, y location of shear center   (location where a transverse/shear force will not produce any torsion, i.e., beam will not twist)\ntc::Vector{float}: x, y location of tension center, aka elastic center, aka centroid    (location where an axial force will not produce any bending, i.e., beam will remain straight)\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.mass_matrix","page":"API Reference","title":"GXBeam.mass_matrix","text":"mass_matrix(nodes, elements)\n\nCompute mass matrix for the structure using GXBeam ordering.\n\nReturns\n\nM::Matrix: mass matrix\nmc::Vector{float}: x, y location of mass center\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.plotmesh","page":"API Reference","title":"GXBeam.plotmesh","text":"plotmesh(nodes, elements, pyplot; plotnumbers=false)\n\nplot nodes and elements for a quick visualization. Need to pass in a PyPlot object as PyPlot is not loaded by this package.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Defining-Point-Masses","page":"API Reference","title":"Defining Point Masses","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"PointMass\nPointMass(m, p, J)\ncombine_masses","category":"page"},{"location":"reference/reference/#GXBeam.PointMass","page":"API Reference","title":"GXBeam.PointMass","text":"PointMass{T}\n\nType which contains the aggregated inertial properties of one or more point masses which  are rigidly attached to the center of an element.\n\nFields:\n\nmass: Mass matrix corresponding to the point masses.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.PointMass-Tuple{Any, Any, Any}","page":"API Reference","title":"GXBeam.PointMass","text":"PointMass(m, p, I)\n\nDefine a point mass given its mass m, offset p, and inertia matrix I\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#GXBeam.combine_masses","page":"API Reference","title":"GXBeam.combine_masses","text":"combine_masses(masses)\n\nCombine the point masses in the iterable collection masses\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Defining-Distributed-Loads","page":"API Reference","title":"Defining Distributed Loads","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"DistributedLoads\nDistributedLoads(assembly, ibeam)\ncombine_loads","category":"page"},{"location":"reference/reference/#GXBeam.DistributedLoads","page":"API Reference","title":"GXBeam.DistributedLoads","text":"DistributedLoads{T}\n\nType which contains pre-integrated distributed forces and moments applied to a beam element.\n\nFields\n\nf1: Integrated non-follower distributed force corresponding to the start of the beam element.\nf2: Integrated non-follower distributed force corresponding to the end of the beam element.\nm1: Integrated non-follower distributed moment corresponding to the start of the beam element.\nm2: Integrated non-follower distributed moment corresponding to the end of the beam element.\nf1_follower: Integrated follower distributed force corresponding to the start of the beam element.\nf2_follower: Integrated follower distributed force corresponding to the end of the beam element.\nm1_follower: Integrated follower distributed moment corresponding to the start of the beam element.\nm2_follower: Integrated follower distributed moment corresponding to the end of the beam element.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.DistributedLoads-Tuple{Any, Any}","page":"API Reference","title":"GXBeam.DistributedLoads","text":"DistributedLoads(assembly, ielem; kwargs...)\n\nPre-integrate distributed loads on a beam element for use in an analysis.\n\nArguments\n\nassembly: Beam element assembly (of type Assembly)\nielem: Beam element index\n\nKeyword Arguments\n\ns1 = 0.0: Start of the beam element (used solely for integrating the distributed loads)\ns2 = 1.0: End of the beam element (used solely for integrating the distributed loads)\nmethod = (f, s1, s2) -> gauss_quadrature(f, s1, s2): Method which integrates function\n\nf from s1 to s2. Defaults to the Gauss-Legendre quadrature with 4 points  on each element.\n\nfx = (s) -> 0.0: Distributed x-direction force\nfy = (s) -> 0.0: Distributed y-direction force\nfz = (s) -> 0.0: Distributed z-direction force\nmx = (s) -> 0.0: Distributed x-direction moment\nmy = (s) -> 0.0: Distributed y-direction moment\nmz = (s) -> 0.0: Distributed z-direction moment\nfx_follower = (s) -> 0.0: Distributed x-direction follower force\nfy_follower = (s) -> 0.0: Distributed y-direction follower force\nfz_follower = (s) -> 0.0: Distributed z-direction follower force\nmx_follower = (s) -> 0.0: Distributed x-direction follower moment\nmy_follower = (s) -> 0.0: Distributed y-direction follower moment\nmz_follower = (s) -> 0.0: Distributed z-direction follower moment\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#GXBeam.combine_loads","page":"API Reference","title":"GXBeam.combine_loads","text":"combine_loads(loads)\n\nCombine the distributed loads in the iterable collection loads\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Defining-Prescribed-Conditions","page":"API Reference","title":"Defining Prescribed Conditions","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"PrescribedConditions\nPrescribedConditions()","category":"page"},{"location":"reference/reference/#GXBeam.PrescribedConditions","page":"API Reference","title":"GXBeam.PrescribedConditions","text":"PrescribedConditions{T}\n\nType which defines the prescribed displacements and loads at a point.\n\nFields:\n\npd: Flag for each degree of freedom indicating whether displacements are prescribed\npl: Flag for each degree of freedom indicating whether loads are prescribed\nu: Linear displacement\ntheta: Angular displacement\nF: External forces\nM: External moments\nFf: Follower forces\nMf: Follower moments\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.PrescribedConditions-Tuple{}","page":"API Reference","title":"GXBeam.PrescribedConditions","text":"PrescribedConditions(; kwargs...)\n\nDefine the prescribed conditions at a point.  Individual prescribed conditions  may be assigned as either a scalar parameter or as a function of time.\n\nPrescribed Wiener-Milenkovic parameters must satisfy the following inequality: sqrt(thetax^2 + thetay^2 + theta_z^2) <= 4.  Note that this restriction still allows all possible rotations to be represented.\n\nNote that if displacements and loads corresponding to the same degree of freedom are  prescribed at the same point, the global body-fixed acceleration corresponding to the  same degree of freedom will be modified to attempt to satisfy both conditions.\n\nKeyword Arguments\n\nux: Prescribed x-displacement (in the body frame)\nuy: Prescribed y-displacement (in the body frame)\nuz: Prescribed z-displacement (in the body frame)\ntheta_x: Prescribed first Wiener-Milenkovic parameter\ntheta_y: Prescribed second Wiener-Milenkovic parameter\ntheta_z: Prescribed third Wiener-Milenkovic parameter\nFx: Prescribed x-direction force\nFy: Prescribed y-direction force\nFz: Prescribed z-direction force\nMx: Prescribed x-direction moment\nMy: Prescribed y-direction moment\nMz: Prescribed z-direction moment\nFx_follower: Prescribed x-direction follower force\nFy_follower: Prescribed y-direction follower force\nFz_follower: Prescribed z-direction follower force\nMx_follower: Prescribed x-direction follower moment\nMy_follower: Prescribed y-direction follower moment\nMz_follower: Prescribed z-direction follower moment\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#Pre-Initializing-Memory-for-an-Analysis","page":"API Reference","title":"Pre-Initializing Memory for an Analysis","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"AbstractSystem\nStaticSystem\nStaticSystem(assembly)\nDynamicSystem\nDynamicSystem(assembly)\nExpandedSystem\nExpandedSystem(assembly)\nreset_state!\ncopy_state!\nset_state!\nset_linear_displacement!\nset_angular_displacement!\nset_external_forces!\nset_external_moments!\nset_linear_velocity!\nset_angular_velocity!\nset_internal_forces!\nset_internal_moments!\nset_start_forces!\nset_start_moments!\nset_end_forces!\nset_end_moments!\nset_point_linear_velocity!\nset_point_angular_velocity!\nset_element_linear_velocity!\nset_element_angular_velocity!","category":"page"},{"location":"reference/reference/#GXBeam.AbstractSystem","page":"API Reference","title":"GXBeam.AbstractSystem","text":"AbstractSystem\n\nSupertype for types which contain the system state, residual vector, and jacobian matrix. \n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.StaticSystem","page":"API Reference","title":"GXBeam.StaticSystem","text":"StaticSystem{TF, TV<:AbstractVector{TF}, TM<:AbstractMatrix{TF}} <: AbstractSystem\n\nContains the system state, residual vector, and jacobian matrix for a static system. \n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.StaticSystem-Tuple{Any}","page":"API Reference","title":"GXBeam.StaticSystem","text":"StaticSystem([TF=eltype(assembly),] assembly; kwargs...)\n\nInitialize an object of type StaticSystem.\n\nArguments:\n\nTF:(optional) Floating point type, defaults to the floating point type of assembly\nassembly: Assembly of rigidly connected nonlinear beam elements\n\nKeyword Arguments\n\nforce_scaling: Factor used to scale system forces/moments internally.  If  not specified, a suitable default will be chosen based on the entries of the  beam element compliance matrices.\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#GXBeam.DynamicSystem","page":"API Reference","title":"GXBeam.DynamicSystem","text":"DynamicSystem{TF, TV<:AbstractVector{TF}, TM<:AbstractMatrix{TF}} <: AbstractSystem\n\nContains the system state, residual vector, and jacobian matrix for a dynamic system. \n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.DynamicSystem-Tuple{Any}","page":"API Reference","title":"GXBeam.DynamicSystem","text":"DynamicSystem([TF=eltype(assembly),] assembly; kwargs...)\n\nInitialize an object of type DynamicSystem.\n\nArguments:\n\nTF:(optional) Floating point type, defaults to the floating point type of assembly\nassembly: Assembly of rigidly connected nonlinear beam elements\n\nKeyword Arguments\n\nforce_scaling: Factor used to scale system forces/moments internally.  If  not specified, a suitable default will be chosen based on the entries of the  beam element compliance matrices.\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#GXBeam.ExpandedSystem","page":"API Reference","title":"GXBeam.ExpandedSystem","text":"ExpandedSystem{TF, TV<:AbstractVector{TF}, TM<:AbstractMatrix{TF}} <: AbstractSystem\n\nContains the system state, residual vector, and jacobian matrix for a constant mass matrix  system. \n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.ExpandedSystem-Tuple{Any}","page":"API Reference","title":"GXBeam.ExpandedSystem","text":"ExpandedSystem([TF=eltype(assembly),] assembly; kwargs...)\n\nInitialize an object of type ExpandedSystem.\n\nArguments:\n\nTF:(optional) Floating point type, defaults to the floating point type of assembly\nassembly: Assembly of rigidly connected nonlinear beam elements\n\nKeyword Arguments\n\nforce_scaling: Factor used to scale system forces/moments internally.  If  not specified, a suitable default will be chosen based on the entries of the  beam element compliance matrices.\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#GXBeam.reset_state!","page":"API Reference","title":"GXBeam.reset_state!","text":"reset_state!(system)\n\nSets the state variables in system to zero.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.copy_state!","page":"API Reference","title":"GXBeam.copy_state!","text":"copy_state!(system1, system2, assembly; kwargs...)\n\nCopy the state variables from system2 into system1\n\nGeneral Keyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type DistributedLoads which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.\npoint_masses = Dict{Int,PointMass{Float64}}(): A dictionary with keys       corresponding to the points to which point masses are attached and values       of type PointMass which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.\nlinear_velocity = zeros(3): Prescribed body frame linear velocity vector.   This vector may also be provided as a function of time.\nangular_velocity = zeros(3): Prescribed body frame angular velocity vector.   This vector may also be provided as a function of time.\nlinear_acceleration = zeros(3): Prescribed body frame linear acceleration vector.   This vector may also be provided as a function of time.\nangular_acceleration = zeros(3): Prescribed body frame angular acceleration vector.   This vector may also be provided as a function of time.\ngravity = [0,0,0]: Gravity vector.  This vector may also be provided as a function   of time.\nt: Current time or time vector. Defaults to the current time stored in system2  \n\nControl Flag Keyword Arguments\n\nreset_state = true: Flag indicating whether the system state variables should be       set to zero prior to copying over the new state variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_state!","page":"API Reference","title":"GXBeam.set_state!","text":"set_state!([x,] system::StaticSystem, prescribed_conditions; kwargs...)\n\nSet the state variables in system (or in the vector x) to the provided values.\n\nKeyword Arguments\n\nu: Vector containing the linear displacement of each point.\ntheta: Vector containing the angular displacement of each point.\nF: Vector containing the externally applied forces acting on each point\nM: Vector containing the externally applied moments acting on each point\nFi: Vector containing internal forces for each beam element\nMi: Vector containing internal moments for each beam element\n\n\n\n\n\nset_state!([x,] system::DynamicSystem, prescribed_conditions; kwargs...)\n\nSet the state variables in system (or in the vector x) to the provided values.\n\nKeyword Arguments\n\nu: Vector containing the linear displacement of each point.\ntheta: Vector containing the angular displacement of each point.\nV: Vector containing the linear velocity of each point.\nOmega Vector containing the angular velocity of each point\nF: Vector containing the externally applied forces acting on each point\nM: Vector containing the externally applied moments acting on each point\nFi: Vector containing internal forces for each beam element (in the deformed       element frame)\nMi: Vector containing internal moments for each beam element (in the deformed       element frame)\n\n\n\n\n\nset_state!([x,] system::ExpandedSystem, prescribed_conditions; kwargs...)\n\nSet the state variables in system (or in the vector x) to the provided values.\n\nKeyword Arguments\n\nu: Vector containing the linear displacement of each point.\ntheta: Vector containing the angular displacement of each point.\nV: Vector containing the linear velocity of each point in the deformed point frame\nOmega Vector containing the angular velocity of each point in the deformed point frame\nF: Vector containing the externally applied forces acting on each point\nM: Vector containing the externally applied moments acting on each point\nF1: Vector containing resultant forces at the start of each beam element (in the   deformed element frame)\nM1: Vector containing resultant moments at the start of each beam element (in the   deformed element frame)\nF2: Vector containing resultant forces at the end of each beam element (in the   deformed element frame)\nM2: Vector containing resultant moments at the end of each beam element (in the   deformed element frame)\nV_e: Vector containing the linear velocity of each beam element in the deformed  beam element reference frame.\nOmega_e Vector containing the angular velocity of each beam element in the deformed  beam element reference frame.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_linear_displacement!","page":"API Reference","title":"GXBeam.set_linear_displacement!","text":"set_linear_displacement!([x,] system, prescribed_conditions, u, ipoint)\n\nSet the state variables in system (or in the vector x) corresponding to the linear deflection of point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_angular_displacement!","page":"API Reference","title":"GXBeam.set_angular_displacement!","text":"set_angular_displacement!([x,] system, prescribed_conditions, theta, ipoint)\n\nSet the state variables in system (or in the vector x) corresponding to the angular deflection of point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_external_forces!","page":"API Reference","title":"GXBeam.set_external_forces!","text":"set_external_forces!([x,] system, prescribed_conditions, F, ipoint)\n\nSet the state variables in system (or in the vector x) corresponding to the external forces applied at point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_external_moments!","page":"API Reference","title":"GXBeam.set_external_moments!","text":"set_external_moments!([x,] system, prescribed_conditions, M, ipoint)\n\nSet the state variables in system (or in the vector x) corresponding to the external moments applied at point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_linear_velocity!","page":"API Reference","title":"GXBeam.set_linear_velocity!","text":"set_linear_velocity!([x,] system, V, ipoint)\n\nSet the state variables in system (or in the vector x) corresponding to the linear velocity of point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_angular_velocity!","page":"API Reference","title":"GXBeam.set_angular_velocity!","text":"set_angular_velocity!([x,] system, Omega, ipoint)\n\nSet the state variables in system (or in the vector x) corresponding to the angular velocity of point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_internal_forces!","page":"API Reference","title":"GXBeam.set_internal_forces!","text":"set_internal_forces!([x,] system::Union{StaticSystem,DynamicSystem}, Fi, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the internal forces of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_internal_moments!","page":"API Reference","title":"GXBeam.set_internal_moments!","text":"set_internal_moments!([x,] system::Union{StaticSystem, DynamicSystem}, Mi, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the internal moments of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_start_forces!","page":"API Reference","title":"GXBeam.set_start_forces!","text":"set_start_forces!([x,] system, F1, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the resultant forces at the start of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_start_moments!","page":"API Reference","title":"GXBeam.set_start_moments!","text":"set_start_moments!([x,] system, M1, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the resultant moments at the start of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_end_forces!","page":"API Reference","title":"GXBeam.set_end_forces!","text":"set_end_forces!([x,] system, F2, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the resultant forces at the end of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_end_moments!","page":"API Reference","title":"GXBeam.set_end_moments!","text":"set_end_moments!([x,] system, M2, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the resultant moments at the end of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_point_linear_velocity!","page":"API Reference","title":"GXBeam.set_point_linear_velocity!","text":"set_point_linear_velocity!([x,] system::ExpandedSystem, V, ipoint)\n\nSet the state variables in system (or in the vector x) corresponding to the linear velocity of point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_point_angular_velocity!","page":"API Reference","title":"GXBeam.set_point_angular_velocity!","text":"set_point_angular_velocity!([x,] system::ExpandedSystem, Omega, ipoint)\n\nSet the state variables in system (or in the vector x) corresponding to the angular velocity of point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_element_linear_velocity!","page":"API Reference","title":"GXBeam.set_element_linear_velocity!","text":"set_element_linear_velocity!([x,] system::ExpandedSystem, V, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the linear velocity of beam element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.set_element_angular_velocity!","page":"API Reference","title":"GXBeam.set_element_angular_velocity!","text":"set_element_angular_velocity!([x,] system::ExpandedSystem, Omega, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the angular velocity of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Performing-an-Analysis","page":"API Reference","title":"Performing an Analysis","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"static_analysis\nstatic_analysis!\nsteady_state_analysis\nsteady_state_analysis!\neigenvalue_analysis\neigenvalue_analysis!\ninitial_condition_analysis\ninitial_condition_analysis!\ntime_domain_analysis\ntime_domain_analysis!","category":"page"},{"location":"reference/reference/#GXBeam.static_analysis","page":"API Reference","title":"GXBeam.static_analysis","text":"static_analysis(assembly; kwargs...)\n\nPerform a static analysis of the system of nonlinear beams contained in assembly. Return the resulting system and a flag indicating whether the iteration procedure converged.\n\nGeneral Keyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type DistributedLoads which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.\npoint_masses = Dict{Int,PointMass{Float64}}(): A dictionary with keys       corresponding to the points to which point masses are attached and values       of type PointMass which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.\ngravity = [0,0,0]: Gravity vector.  If time varying, this input may be provided as a       function of time.\ntime = 0.0: Current time or vector of times corresponding to each step. May be used       in conjunction with time varying prescribed conditions, distributed loads, and       body frame motion to gradually increase displacements and loads.     \n\nControl Flag Keyword Arguments\n\ntwo_dimensional = false: Flag indicating whether to constrain results to the x-y plane\nreset_state = true: Flag indicating whether the system state variables should be       set to zero prior to performing this analysis.\nlinear = false: Flag indicating whether a linear analysis should be performed.\nshow_trace = false: Flag indicating whether to display the solution progress.\n\nNonlinear Solver Keyword Arguments (see NLsolve.jl)\n\nmethod = :newton: Solution method for nonlinear systems of equations\nlinesearch = LineSearches.BackTracking(maxstep=1e6): Line search for solving nonlinear      systems of equations\nftol = 1e-9: Tolerance for solving the nonlinear system of equations\niterations = 1000: Iteration limit when solving the nonlinear systems of equations\n\nLinear Solver Keyword Arguments\n\nlinearization_state: Linearization state variables.  Defaults to zeros.\nupdate_linearization = false: Flag indicating whether to update the linearization state       variables for a linear analysis with the instantaneous state variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_analysis!","page":"API Reference","title":"GXBeam.static_analysis!","text":"static_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of static_analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_state_analysis","page":"API Reference","title":"GXBeam.steady_state_analysis","text":"steady_state_analysis(assembly; kwargs...)\n\nPerform a steady-state analysis for the system of nonlinear beams contained in assembly.  Return the resulting system and a flag indicating whether the iteration procedure converged.\n\nGeneral Keyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type DistributedLoads which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.\npoint_masses = Dict{Int,PointMass{Float64}}(): A dictionary with keys       corresponding to the points to which point masses are attached and values       of type PointMass which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.\nlinear_velocity = zeros(3): Prescribed linear velocity of the body frame.       If time varying, this input may be provided as a function of time.\nangular_velocity = zeros(3): Prescribed angular velocity of the body frame.       If time varying, this input may be provided as a function of time.\nlinear_acceleration = zeros(3): Prescribed linear acceleration of the body frame.      If time varying, this input may be provided as a function of time.\nangular_acceleration = zeros(3): Prescribed angular acceleration of the body frame.      If time varying, this input may be provided as a function of time.\ngravity = [0,0,0]: Gravity vector in the inertial frame.  If time varying, this input       may be provided as a function of time.\ntime = 0.0: Current time or vector of times corresponding to each step. May be used       in conjunction with time varying prescribed conditions, distributed loads, and       body frame motion to gradually increase displacements and loads.     \n\nControl Flag Keyword Arguments\n\ntwo_dimensional = false: Flag indicating whether to constrain results to the x-y plane\nstructural_damping = false: Indicates whether to enable structural damping\nconstant_mass_matrix = false: Indicates whether to use a constant mass matrix system\nreset_state = true: Flag indicating whether the system state variables should be       set to zero prior to performing this analysis.\nlinear = false: Flag indicating whether a linear analysis should be performed.\nshow_trace = false: Flag indicating whether to display the solution progress.\n\nNonlinear Solver Keyword Arguments\n\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.BackTracking(maxstep=1e6): Line search used to solve the      nonlinear system of equations\nftol = 1e-9: tolerance for solving the nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\n\nLinear Solver Keyword Arguments\n\nlinearization_state: Linearization state variables.  Defaults to zeros.\nupdate_linearization: Flag indicating whether to update the linearization state       variables for a linear analysis with the instantaneous state variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_state_analysis!","page":"API Reference","title":"GXBeam.steady_state_analysis!","text":"steady_state_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of steady_state_analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.eigenvalue_analysis","page":"API Reference","title":"GXBeam.eigenvalue_analysis","text":"eigenvalue_analysis(assembly; kwargs...)\n\nCompute the eigenvalues and eigenvectors of the system of nonlinear beams contained in assembly.  Return the modified system, eigenvalues, eigenvectors, and a convergence flag indicating whether the corresponding steady-state analysis converged.\n\nGeneral Keyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type DistributedLoads which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.\npoint_masses = Dict{Int,PointMass{Float64}}(): A dictionary with keys       corresponding to the points to which point masses are attached and values       of type PointMass which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.\nlinear_velocity = zeros(3): Prescribed linear velocity of the body frame.       If time varying, this input may be provided as a function of time.\nangular_velocity = zeros(3): Prescribed angular velocity of the body frame.       If time varying, this input may be provided as a function of time.\nlinear_acceleration = zeros(3): Prescribed linear acceleration of the body frame.      If time varying, this input may be provided as a function of time.\nangular_acceleration = zeros(3): Prescribed angular acceleration of the body frame.      If time varying, this input may be provided as a function of time.\ngravity = [0,0,0]: Gravity vector in the inertial frame.  If time varying, this input       may be provided as a function of time.\ntime = 0.0: Current time or vector of times corresponding to each step. May be used       in conjunction with time varying prescribed conditions, distributed loads, and       body frame motion to gradually increase displacements and loads.     \n\nControl Flag Keyword Arguments\n\ntwo_dimensional = false: Flag indicating whether to constrain results to the x-y plane\nstructural_damping = false: Indicates whether to enable structural damping\nconstant_mass_matrix = false: Indicates whether to use a constant mass matrix system\nreset_state = true: Flag indicating whether the system state variables should be      set to zero prior to performing this analysis.\nlinear = false: Flag indicating whether a linear analysis should be performed.\nshow_trace = false: Flag indicating whether to display the solution progress.\n\nNonlinear Solver Keyword Arguments\n\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6): Line search used to       solve the nonlinear system of equations\nftol = 1e-9: tolerance for solving the nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\n\nLinear Solver Keyword Arguments\n\nlinearization_state: Linearization state variables.  Defaults to zeros.\nupdate_linearization = false: Flag indicating whether to update the linearization state       variables for a linear analysis with the instantaneous state variables.\n\nEigenvalue Solution Keyword Arguments\n\nnev = 6: Number of eigenvalues to compute\nsteady = reset_state && !linear: Flag indicating whether the steady state       solution should be found prior to performing the eigenvalue analysis.\nleft = false: Flag indicating whether to return left and right eigenvectors rather       than just right eigenvectors.  \nUprev = nothing: Previous left eigenvector matrix.  May be provided in order to       reorder eigenvalues based on results from a previous iteration.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.eigenvalue_analysis!","page":"API Reference","title":"GXBeam.eigenvalue_analysis!","text":"eigenvalue_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of eigenvalue_analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_condition_analysis","page":"API Reference","title":"GXBeam.initial_condition_analysis","text":"initial_condition_analysis(assembly, t0; kwargs...)\n\nPerform an analysis to obtain a consistent set of initial conditions.  Return the resulting system and a flag indicating whether the iteration procedure converged.\n\nGeneral Keyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type DistributedLoads which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.\npoint_masses = Dict{Int,PointMass{Float64}}(): A dictionary with keys       corresponding to the points to which point masses are attached and values       of type PointMass which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.\nlinear_velocity = zeros(3): Initial linear velocity of the body frame. \nangular_velocity = zeros(3): Initial angular velocity of the body frame. \nlinear_acceleration = zeros(3): Initial linear acceleration of the body frame.\nangular_acceleration = zeros(3): Initial angular acceleration of the body frame.\ngravity = [0,0,0]: Gravity vector in the inertial frame.\n\nInitial Condition Keyword Arguments\n\nu0 = fill(zeros(3), length(assembly.points)): Initial linear displacement of       each point relative to the body frame\ntheta0 = fill(zeros(3), length(assembly.points)): Initial angular displacement of       each point relative to the body frame (using Wiener-Milenkovic Parameters) \nV0 = fill(zeros(3), length(assembly.points)): Initial linear velocity of       each point relative to the body frame\nOmega0 = fill(zeros(3), length(assembly.points)): Initial angular velocity of       each point relative to the body frame\nVdot0 = fill(zeros(3), length(assembly.points)): Initial linear acceleration of       each point relative to the body frame\nOmegadot0 = fill(zeros(3), length(assembly.points)): Initial angular acceleration of       each point relative to the body frame\n\nControl Flag Keyword Arguments\n\ntwo_dimensional = false: Flag indicating whether to constrain results to the x-y plane\nstructural_damping = true: Indicates whether to enable structural damping\nconstant_mass_matrix = false: Indicates whether to use a constant mass matrix system\nreset_state = true: Flag indicating whether the system state variables should be       set to zero prior to performing this analysis.\nsteady=false: Flag indicating whether to initialize by performing a steady state       analysis.\nlinear = false: Flag indicating whether a linear analysis should be performed.\nshow_trace = false: Flag indicating whether to display the solution progress.\n\nNonlinear Solver Keyword Arguments\n\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.BackTracking(maxstep=1e6): Line search used to solve the      nonlinear system of equations\nftol = 1e-9: tolerance for solving the nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\n\nLinear Solver Keyword Arguments\n\nlinearization_state: Linearization state variables.  Defaults to zeros.\nupdate_linearization = false: Flag indicating whether to update the linearization state       variables for a linear analysis with the instantaneous state variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_condition_analysis!","page":"API Reference","title":"GXBeam.initial_condition_analysis!","text":"initial_condition_analysis!(system, assembly, t0; kwargs...)\n\nPre-allocated version of initial_condition_analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.time_domain_analysis","page":"API Reference","title":"GXBeam.time_domain_analysis","text":"time_domain_analysis(assembly, tvec; kwargs...)\n\nPerform a time-domain analysis for the system of nonlinear beams contained in assembly using the time vector tvec.  Return the final system, a post-processed solution history, and a convergence flag indicating whether the iteration procedure converged for every time step.\n\nGeneral Keyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type DistributedLoads which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.\npoint_masses = Dict{Int,PointMass{Float64}}(): A dictionary with keys       corresponding to the points to which point masses are attached and values       of type PointMass which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.\nlinear_velocity = zeros(3): Initial linear velocity of the body frame. \nangular_velocity = zeros(3): Initial angular velocity of the body frame. \nlinear_acceleration = zeros(3): Prescribed linear acceleration of the body frame.\nangular_acceleration = zeros(3): Prescribed angular acceleration of the body frame.\ngravity = [0,0,0]: Gravity vector in the inertial frame.\nsave = eachindex(tvec): Steps at which to save the time history\n\nInitial Condition Keyword Arguments\n\nu0 = fill(zeros(3), length(assembly.points)): Initial linear displacement of       each point in the body frame\ntheta0 = fill(zeros(3), length(assembly.points)): Initial angular displacement of       each point in the body frame (using Wiener-Milenkovic Parameters) \nV0 = fill(zeros(3), length(assembly.points)): Initial linear velocity of       each point in the body frame excluding contributions from body frame motion\nOmega0 = fill(zeros(3), length(assembly.points)): Initial angular velocity of       each point in the body frame excluding contributions from body frame motion\nVdot0 = fill(zeros(3), length(assembly.points)): Initial linear acceleration of       each point in the body frame excluding contributions from body frame motion\nOmegadot0 = fill(zeros(3), length(assembly.points)): Initial angular acceleration of       each point in the body frame excluding contributions from body frame motion\n\nControl Flag Keyword Arguments\n\ntwo_dimensional = false: Flag indicating whether to constrain results to the x-y plane\nstructural_damping = true: Indicates whether to enable structural damping\nreset_state = true: Flag indicating whether the system state variables should be       set to zero prior to performing this analysis.\ninitialize = true: Flag indicating whether a consistent set of initial      conditions should be found using initial_condition_analysis.\nsteady=false: Flag indicating whether to initialize by performing a steady state       analysis.\nlinear = false: Flag indicating whether a linear analysis should be performed.\nshow_trace = false: Flag indicating whether to display the solution progress.\n\nNonlinear Solver Keyword Arguments\n\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.BackTracking(maxstep=1e6): Line search used to solve       nonlinear systems of equations\nftol = 1e-9: tolerance for solving the nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\n\nLinear Solver Keyword Arguments\n\nlinearization_state: Linearization state variables.  Defaults to zeros.\nupdate_linearization: Flag indicating whether to update the linearization state       variables for a linear analysis with the instantaneous state variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.time_domain_analysis!","page":"API Reference","title":"GXBeam.time_domain_analysis!","text":"time_domain_analysis!(system, assembly, tvec; kwargs...)\n\nPre-allocated version of time_domain_analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Post-Processing","page":"API Reference","title":"Post-Processing","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"AssemblyState\nPointState\nElementState\nAssemblyState(system, assembly)\nextract_element_state\nextract_element_states\nextract_element_states!\nextract_point_state\nextract_point_states\nextract_point_states!\nlinearize!\nsolve_eigensystem\nleft_eigenvectors\ncorrelate_eigenmodes\nwiener_milenkovic\nrotate\nrotate!\ntranslate\ntranslate!\ndeform_cross_section\ndeform_cross_section!\nwrite_vtk","category":"page"},{"location":"reference/reference/#GXBeam.AssemblyState","page":"API Reference","title":"GXBeam.AssemblyState","text":"AssemblyState{TF, TP<:AbstractVector{PointState{TF}}, TE<:AbstractVector{ElementState{TF}}}\n\nStruct for storing state variables for the points and elements in an assembly.\n\nFields:\n\npoints::TP: Array of PointState for each point in the assembly\nelements::TE: Array of ElementState for each element in the assembly\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.PointState","page":"API Reference","title":"GXBeam.PointState","text":"PointState\n\nHolds the state variables for a point\n\nFields:\n\nu: Linear deflection\ntheta: Angular deflection (Wiener-Milenkovic parameters)\nV: Linear velocity\nOmega: Angular velocity\nF: External forces\nM: External moments\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.ElementState","page":"API Reference","title":"GXBeam.ElementState","text":"ElementState\n\nHolds the state variables for an element\n\nFields:\n\nu: Linear deflection\ntheta: Angular deflection (Wiener-Milenkovic parameters)\nV: Linear velocity\nOmega: Angular velocity\nFi: Internal forces\nMi: Internal moments\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.AssemblyState-Tuple{Any, Any}","page":"API Reference","title":"GXBeam.AssemblyState","text":"AssemblyState(system, assembly, x = system.x; prescribed_conditions = Dict())\n\nPost-process the system state given the solution vector x.  Return an object of type AssemblyState that defines the state of the assembly for the time step.\n\nIf prescribed_conditions is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#GXBeam.extract_element_state","page":"API Reference","title":"GXBeam.extract_element_state","text":"extract_element_state(system, assembly, ielem, x = system.x;\n    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nReturn the state variables corresponding to element ielem (see ElementState) given the solution vector x.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.extract_element_states","page":"API Reference","title":"GXBeam.extract_element_states","text":"extract_element_states(system, assembly, x = system.x;\n    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nReturn the state variables corresponding to each element (see ElementState) given the solution vector x.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.extract_element_states!","page":"API Reference","title":"GXBeam.extract_element_states!","text":"extract_element_states!(elements, system, assembly, x = system.x;\n    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nPre-allocated version of extract_element_states\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.extract_point_state","page":"API Reference","title":"GXBeam.extract_point_state","text":"extract_point_state(system, assembly, ipoint, x = system.x;\n    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nReturn the state variables corresponding to point ipoint (see PointState) given the solution vector x.\n\nIf prescribed_conditions is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.extract_point_states","page":"API Reference","title":"GXBeam.extract_point_states","text":"extract_point_states(system, assembly, x = system.x;\n    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nReturn the state variables corresponding to each point (see PointState) given the solution vector x.\n\nIf prescribed_conditions is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.extract_point_states!","page":"API Reference","title":"GXBeam.extract_point_states!","text":"extract_point_states!(points, system, assembly, x = system.x;\n    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nPre-allocated version of extract_point_states\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.linearize!","page":"API Reference","title":"GXBeam.linearize!","text":"linearize!(system, assembly; kwargs...)\n\nReturn the state variables, jacobian matrix, and mass matrix of a linearized system using the current system state vector.  Note that the returned vectors and matrices are aliased  with variables in system so a copy should be made prior to modifying them.\n\nGeneral Keyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and values of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary      with keys corresponding to the elements to which distributed loads are      applied and values of type DistributedLoads which describe      the distributed loads on those elements.  If time varying, this input may      be provided as a function of time.\npoint_masses = Dict{Int,PointMass{Float64}}(): A dictionary with keys       corresponding to the points to which point masses are attached and values       of type PointMass which contain the properties of the attached       point masses.  If time varying, this input may be provided as a function of time.\nlinear_velocity = zeros(3): Prescribed linear velocity of the body frame.       If time varying, this input may be provided as a function of time.\nangular_velocity = zeros(3): Prescribed angular velocity of the body frame.       If time varying, this input may be provided as a function of time.\nlinear_acceleration = zeros(3): Prescribed linear acceleration of the body frame.      If time varying, this input may be provided as a function of time.\nangular_acceleration = zeros(3): Prescribed angular acceleration of the body frame.      If time varying, this input may be provided as a function of time.\ngravity = [0,0,0]: Gravity vector in the inertial frame.  If time varying, this input       may be provided as a function of time.\ntime = 0.0: Current time or vector of times corresponding to each step. May be used       in conjunction with time varying prescribed conditions, distributed loads, and       body frame motion to gradually increase displacements and loads.     \n\nControl Flag Keyword Arguments\n\ntwo_dimensional = false: Flag indicating whether to constrain results to the x-y plane\nstructural_damping = false: Indicates whether to enable structural damping\nconstant_mass_matrix = false: Indicates whether to use a constant mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.solve_eigensystem","page":"API Reference","title":"GXBeam.solve_eigensystem","text":"solve_eigensystem(x, K, M, nev)\n\nReturn the eigenvalues and eigenvectors of a linearized system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.left_eigenvectors","page":"API Reference","title":"GXBeam.left_eigenvectors","text":"left_eigenvectors(system, λ, V)\nleft_eigenvectors(K, M, λ, V)\n\nCompute the left eigenvector matrix U for the system using inverse power iteration given the eigenvalues λ and the corresponding right eigenvector matrix V.\n\nThe complex conjugate of each left eigenvector is stored in each row of the matrix U\n\nLeft and right eigenvectors satisfy the following M-orthogonality condition:\n\nu'Mv = 1 if u and v correspond to the same eigenvalue\nu'Mv = 0 if u and v correspond to different eigenvalues\n\nThis means that UMV = I\n\nThis function assumes that system has not been modified since the eigenvalues and right eigenvectors were computed.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.correlate_eigenmodes","page":"API Reference","title":"GXBeam.correlate_eigenmodes","text":"correlate_eigenmodes(C)\n\nReturn the permutation and the associated corruption index vector which associates eigenmodes from the current iteration with those of the previous iteration given the correlation matrix C.\n\nThe correlation matrix can take one of the following forms (in order of preference):\n\nC = U_p*M*V\nC = U*M_p*V_p\nC = V_p'*V\nC = V'*V_p\n\nwhere U is a matrix of conjugated left eigenvectors, M is the system mass matrix, V is a matrix of right eigenvectors, and ()_p indicates a variable from the previous iteration.\n\nNote that the following two forms of the correlation matrix seem to be significantly inferior to their counterparts listed above: C = U*M*V_p and C = U_p*M_p*V. This is likely due to the way in which the left eigenvector matrix is calculated.\n\nThe corruption index is the largest magnitude in a given row of C that was not chosen divided by the magnitude of the chosen eigenmode.  It is most meaningful when using one of the forms of the correlation matrix that uses left eigenvectors since correct eigenmodes will have magnitudes close to 1 and incorrect eigenmodes will have magnitudes close to 0.\n\nIf the new mode number is already assigned, the next highest unassigned mode number is used.  In this case a corruption index higher than 1 will be returned, otherwise the values of the corruption index will always be bounded by 0 and 1.\n\nSee \"New Mode Tracking Methods in Aeroelastic Analysis\" by Eldred, Vankayya, and Anderson.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.wiener_milenkovic","page":"API Reference","title":"GXBeam.wiener_milenkovic","text":"wiener_milenkovic(c)\n\nConstruct a Wiener-Milenkovic transformation matrix, given the three Wiener-Milenkovic parameters in c.\n\nNote that the corresponding rotation matrix is the transpose of this transformation matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.rotate","page":"API Reference","title":"GXBeam.rotate","text":"rotate(xyz, r, theta)\n\nRotate the vectors in xyz about point r using the Wiener-Milenkovic parameters in theta.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.rotate!","page":"API Reference","title":"GXBeam.rotate!","text":"rotate!(xyz, r, theta)\n\nPre-allocated version of rotate\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.translate","page":"API Reference","title":"GXBeam.translate","text":"translate(xyz, u)\n\nTranslate the points in xyz by the displacements in u.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.translate!","page":"API Reference","title":"GXBeam.translate!","text":"translate!(xyz, u)\n\nPre-allocated version of translate\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.deform_cross_section","page":"API Reference","title":"GXBeam.deform_cross_section","text":"deform_cross_section(xyz, r, u, theta)\n\nRotate the points in xyz (of shape (3, :)) about point r using the Wiener-Milenkovic parameters in theta, then translate the points by the displacements in u.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.deform_cross_section!","page":"API Reference","title":"GXBeam.deform_cross_section!","text":"deform_cross_section!(xyz, r, u, theta)\n\nPre-allocated version of deform_cross_section\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.write_vtk","page":"API Reference","title":"GXBeam.write_vtk","text":"write_vtk(name, assembly::Assembly; kwargs...)\nwrite_vtk(name, assembly::Assembly, state::AssemblyState; kwargs...)\nwrite_vtk(name, assembly::Assembly, history::Vector{<:AssemblyState}], dt;\n    kwargs...)\n\nWrite the deformed geometry (and associated data) to a VTK file for visualization using ParaView.\n\nThe state argument may be omitted to write the original geometry to a VTK file without any associated data.\n\nIf the solution time history is provided, the time step must also be provided\n\nKeyword Arguments\n\nsections = nothing: Cross section geometry corresponding to each point,  defined in a frame aligned with the body frame but centered around the  corresponding point. Defined as an array with shape (3, ncross, np) where ncross  is the number of points in each cross section and np is the number of points.\nscaling=1.0: Parameter to scale the deflections (only valid if state is provided)\nmetadata=Dict(): Dictionary of metadata for the file(s)\n\n\n\n\n\nwrite_vtk(name, assembly::Assembly, [state::AssemblyState, ]λ::Number,\n    eigenstate::AssemblyState; scaling=1.0, mode_scaling=1.0, cycles=1,\n    steps=100)\n\nWrite a series of files corresponding to the elastic motion of the assembly about the deformed state encoded in state defined by the eigenvalue λ and the eigenvector encoded in eigenstate over the time period specified by time.\n\nThe steady-state deflections can be scaled with scaling and the eigenmode deflections can be scaled using mode_scaling.\n\nThe current time is encoded in the metadata tag \"time\"\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Private-API","page":"API Reference","title":"Private API","text":"","category":"section"},{"location":"reference/reference/#Math","page":"API Reference","title":"Math","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"GXBeam.tilde\nGXBeam.transform_properties\nGXBeam.rotation_parameter_scaling\nGXBeam.get_C\nGXBeam.get_C_θ\nGXBeam.get_Q\nGXBeam.get_Q_θ\nGXBeam.get_Qinv\nGXBeam.get_Qinv_θ\nGXBeam.get_ΔQ\nGXBeam.get_ΔQ_θ\nGXBeam.mul3\nGXBeam.gauss_quadrature","category":"page"},{"location":"reference/reference/#GXBeam.tilde","page":"API Reference","title":"GXBeam.tilde","text":"tilde(x)\n\nConstruct the cross product operator matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.transform_properties","page":"API Reference","title":"GXBeam.transform_properties","text":"transform_properties(K, T)\n\nApplies the transformation T to the stiffness or mass matrix K\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.rotation_parameter_scaling","page":"API Reference","title":"GXBeam.rotation_parameter_scaling","text":"rotation_parameter_scaling(θ)\n\nExtract a scaling parameter which may be multiplied by the angular parameters to yield the Wiener-Milenkovic rotation parameters.  Use of this scaling parameter allows deflections greater than 360 degrees.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.get_C","page":"API Reference","title":"GXBeam.get_C","text":"get_C(θ)\n\nReturns the transformation matrix C given the three angular parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.get_C_θ","page":"API Reference","title":"GXBeam.get_C_θ","text":"get_C_θ([C, ] θ)\n\nCalculate the derivative of the Wiener-Milenkovic transformation matrix C with respect to each of the rotation parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.get_Q","page":"API Reference","title":"GXBeam.get_Q","text":"get_Q(θ)\n\nCalculate the matrix Q as defined in the paper \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu given the rotational parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.get_Q_θ","page":"API Reference","title":"GXBeam.get_Q_θ","text":"get_Q_θ(θ)\nget_Q_θ(Q, θ)\n\nCalculate the derivative of the matrix Q with respect to each of the rotation parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.get_Qinv","page":"API Reference","title":"GXBeam.get_Qinv","text":"get_Qinv(θ)\n\nCalculate the matrix inverse Qinv as defined in the paper \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu given the rotational parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.get_Qinv_θ","page":"API Reference","title":"GXBeam.get_Qinv_θ","text":"get_Qinv_θ(θ)\n\nCalculate the derivative of the matrix inverse Qinv with respect to each of the rotation parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.get_ΔQ","page":"API Reference","title":"GXBeam.get_ΔQ","text":"get_ΔQ(θ, Δθ [, Q])\n\nCalculate the matrix ΔQ for structural damping calculations\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.get_ΔQ_θ","page":"API Reference","title":"GXBeam.get_ΔQ_θ","text":"get_ΔQ_θ(θ, Δθ, [Q, Q_θ1, Q_θ2, Q_θ3])\n\nCalculate the derivative of the matrix ΔQ with respect to each of the rotation parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.mul3","page":"API Reference","title":"GXBeam.mul3","text":"mul3(A_1, A_2, A_3, b)\n\nReturn the product of a 3x3x3 tensor represented by A_1, A_2, and A_3 with the vector b.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.gauss_quadrature","page":"API Reference","title":"GXBeam.gauss_quadrature","text":"gauss_quadrature(f, a, b)\n\nDefault gauss-quadrature function used for integrating distributed loads.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Body-Frame","page":"API Reference","title":"Body Frame","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"GXBeam.update_body_acceleration_indices!\nGXBeam.body_accelerations","category":"page"},{"location":"reference/reference/#GXBeam.update_body_acceleration_indices!","page":"API Reference","title":"GXBeam.update_body_acceleration_indices!","text":"update_body_acceleration_indices!(system, prescribed_conditions)\n\nUpdates the state variable indices corresponding to the body frame accelerations to  correspond to the provided prescribed conditions.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.body_accelerations","page":"API Reference","title":"GXBeam.body_accelerations","text":"body_accelerations(system, x=system.x; linear_acceleration=zeros(3), angular_acceleration=zeros(3))\n\nExtract the linear and angular acceleration of the body frame from the state vector or  prescribed accelerations.  Valid for the results of steady state and initial condition  analyses.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Points","page":"API Reference","title":"Points","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"GXBeam.point_loads\nGXBeam.point_load_jacobians\nGXBeam.point_displacement\nGXBeam.point_displacement_jacobians\nGXBeam.point_displacement_rates\nGXBeam.point_velocities\nGXBeam.initial_point_displacement\nGXBeam.initial_point_velocity_rates\nGXBeam.initial_point_displacement_jacobian\nGXBeam.initial_point_velocity_rate_jacobian\nGXBeam.static_point_properties\nGXBeam.steady_point_properties\nGXBeam.initial_point_properties\nGXBeam.newmark_point_properties\nGXBeam.dynamic_point_properties\nGXBeam.expanded_steady_point_properties\nGXBeam.expanded_dynamic_point_properties\nGXBeam.point_velocity_residuals\nGXBeam.expanded_point_velocity_residuals\nGXBeam.static_point_resultants\nGXBeam.dynamic_point_resultants\nGXBeam.expanded_point_resultants\nGXBeam.static_point_residual!\nGXBeam.steady_point_residual!\nGXBeam.initial_point_residual!\nGXBeam.newmark_point_residual!\nGXBeam.dynamic_point_residual!\nGXBeam.expanded_steady_point_residual!\nGXBeam.expanded_dynamic_point_residual!\nGXBeam.static_point_jacobian_properties\nGXBeam.steady_point_jacobian_properties\nGXBeam.initial_point_jacobian_properties\nGXBeam.newmark_point_jacobian_properties\nGXBeam.dynamic_point_jacobian_properties\nGXBeam.expanded_steady_point_jacobian_properties\nGXBeam.expanded_dynamic_point_jacobian_properties\nGXBeam.mass_matrix_point_jacobian_properties\nGXBeam.expanded_mass_matrix_point_jacobian_properties\nGXBeam.static_point_resultant_jacobians\nGXBeam.steady_point_resultant_jacobians\nGXBeam.initial_point_resultant_jacobians\nGXBeam.dynamic_point_resultant_jacobians\nGXBeam.expanded_steady_point_resultant_jacobians\nGXBeam.expanded_dynamic_point_resultant_jacobians\nGXBeam.mass_matrix_point_resultant_jacobians\nGXBeam.initial_point_velocity_jacobians\nGXBeam.newmark_point_velocity_jacobians\nGXBeam.dynamic_point_velocity_jacobians\nGXBeam.expanded_point_velocity_jacobians\nGXBeam.mass_matrix_point_velocity_jacobians\nGXBeam.insert_static_point_jacobians!\nGXBeam.insert_initial_point_jacobians!\nGXBeam.insert_dynamic_point_jacobians!\nGXBeam.insert_expanded_steady_point_jacobians!\nGXBeam.insert_expanded_dynamic_point_jacobians!\nGXBeam.insert_mass_matrix_point_jacobians!\nGXBeam.static_point_jacobian!\nGXBeam.steady_point_jacobian!\nGXBeam.initial_point_jacobian!\nGXBeam.newmark_point_jacobian!\nGXBeam.dynamic_point_jacobian!\nGXBeam.expanded_steady_point_jacobian!\nGXBeam.expanded_dynamic_point_jacobian!\nGXBeam.mass_matrix_point_jacobian!\nGXBeam.expanded_mass_matrix_point_jacobian!","category":"page"},{"location":"reference/reference/#GXBeam.point_loads","page":"API Reference","title":"GXBeam.point_loads","text":"point_loads(x, ipoint, icol, force_scaling, prescribed_conditions)\n\nExtract the loads F and M of point ipoint from the state variable vector or  prescribed conditions.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.point_load_jacobians","page":"API Reference","title":"GXBeam.point_load_jacobians","text":"point_load_jacobians(x, ipoint, icol, force_scaling, prescribed_conditions)\n\nCalculate the load jacobians F_θ, F_F, M_θ, and M_M of point ipoint.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.point_displacement","page":"API Reference","title":"GXBeam.point_displacement","text":"point_displacement(x, ipoint, icol_point, prescribed_conditions)\n\nExtract the displacements u and θ of point ipoint from the state variable vector or  prescribed conditions.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.point_displacement_jacobians","page":"API Reference","title":"GXBeam.point_displacement_jacobians","text":"point_displacement_jacobians(ipoint, prescribed_conditions)\n\nCalculate the displacement jacobians u_u and θ_θ of point ipoint.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.point_displacement_rates","page":"API Reference","title":"GXBeam.point_displacement_rates","text":"point_displacement_rates(dx, ipoint, icol, prescribed_conditions)\n\nExtract the displacement rates udot and θdot of point ipoint from the rate variable vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.point_velocities","page":"API Reference","title":"GXBeam.point_velocities","text":"point_velocities(x, ipoint, icol_point)\n\nExtract the velocities V and Ω of point ipoint from the state variable vector\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_point_displacement","page":"API Reference","title":"GXBeam.initial_point_displacement","text":"initial_point_displacement(x, ipoint, icol_point, prescribed_conditions, \n    rate_vars)\n\nExtract the displacements u and θ of point ipoint from the state variable vector or  prescribed conditions for an initial condition analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_point_velocity_rates","page":"API Reference","title":"GXBeam.initial_point_velocity_rates","text":"initial_point_velocity_rates(x, ipoint, icol_point, prescribed_conditions, \n    Vdot0, Ωdot0, rate_vars)\n\nExtract the velocity rates Vdot and Ωdot of point ipoint from the state variable  vector or provided initial conditions.  Note that Vdot and Ωdot in this case do not  include any contributions resulting from body frame motion. \n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_point_displacement_jacobian","page":"API Reference","title":"GXBeam.initial_point_displacement_jacobian","text":"initial_point_displacement_jacobian(ipoint, icol_point, prescribed_conditions, \n    rate_vars)\n\nExtract the displacement jacobians u_u and θ_θ of point ipoint from the state  variable vector or prescribed conditions for an initial condition analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_point_velocity_rate_jacobian","page":"API Reference","title":"GXBeam.initial_point_velocity_rate_jacobian","text":"initial_point_velocity_rate_jacobian(ipoint, icol_point, prescribed_conditions, \n    rate_vars)\n\nReturn the velocity rate jacobians Vdot_Vdot and Ωdot_Ωdot of point ipoint.  Note  that Vdot and Ωdot in this case do not minclude any contributions resulting from  body frame motion. \n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_point_properties","page":"API Reference","title":"GXBeam.static_point_properties","text":"static_point_properties(x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity)\n\nCalculate/extract the point properties needed to construct the residual for a static  analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_point_properties","page":"API Reference","title":"GXBeam.steady_point_properties","text":"steady_point_properties(x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity, \n    linear_acceleration=(@SVector zeros(3)), angular_acceleration=(@SVector zeros(3)))\n\nCalculate/extract the point properties needed to construct the residual for a steady state  analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_point_properties","page":"API Reference","title":"GXBeam.initial_point_properties","text":"initial_point_properties(x, indices, rate_vars, force_scaling, \n    assembly, ipoint, prescribed_conditions, point_masses, gravity, \n    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration, \n    u0, θ0, V0, Ω0, Vdot0, Ωdot0)\n\nCalculate/extract the point properties needed to construct the residual for a time domain  analysis initialization.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.newmark_point_properties","page":"API Reference","title":"GXBeam.newmark_point_properties","text":"newmark_point_properties(x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity, \n    udot_init, θdot_init, Vdot_init, Ωdot_init, dt)\n\nCalculate/extract the point properties needed to construct the residual for a newmark-scheme time stepping analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_point_properties","page":"API Reference","title":"GXBeam.dynamic_point_properties","text":"dynamic_point_properties(dx, x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity)\n\nCalculate/extract the point properties needed to construct the residual for a dynamic  analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_point_properties","page":"API Reference","title":"GXBeam.expanded_steady_point_properties","text":"expanded_steady_point_properties(x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity, \n    linear_acceleration=(@SVector zeros(3)), angular_acceleration=(@SVector zeros(3)))\n\nCalculate/extract the point properties needed to construct the residual for a constant  mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_point_properties","page":"API Reference","title":"GXBeam.expanded_dynamic_point_properties","text":"expanded_dynamic_point_properties(dx, x, indices, force_scaling, assembly, \n    ipoint, prescribed_conditions, point_masses, gravity, linear_velocity, \n    angular_velocity)\n\nCalculate/extract the point properties needed to construct the residual for a constant  mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.point_velocity_residuals","page":"API Reference","title":"GXBeam.point_velocity_residuals","text":"point_velocity_residuals(properties)\n\nCalculate the velocity residuals rV and rΩ for a point for a steady state analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_point_velocity_residuals","page":"API Reference","title":"GXBeam.expanded_point_velocity_residuals","text":"expanded_point_velocity_residuals(properties)\n\nCalculate the velocity residuals rV and rΩ for a point for a constant mass matrix  system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_point_resultants","page":"API Reference","title":"GXBeam.static_point_resultants","text":"static_point_resultants(properties)\n\nCalculate the net loads F and M applied at a point for a static analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_point_resultants","page":"API Reference","title":"GXBeam.dynamic_point_resultants","text":"dynamic_point_resultants(properties)\n\nCalculate the net loads F and M applied at a point for a steady analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_point_resultants","page":"API Reference","title":"GXBeam.expanded_point_resultants","text":"expanded_point_resultants(properties)\n\nCalculate the net loads F and M applied at a point for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_point_residual!","page":"API Reference","title":"GXBeam.static_point_residual!","text":"static_point_residual!(resid, x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity)\n\nCalculate and insert the residual entries corresponding to a point for a static analysis  into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_point_residual!","page":"API Reference","title":"GXBeam.steady_point_residual!","text":"steady_point_residual!(resid, x, indices, force_scaling, assembly, ipoint, \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity, \n    linear_acceleration, angular_acceleration)\n\nCalculate and insert the residual entries corresponding to a point for a steady state analysis into the  system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_point_residual!","page":"API Reference","title":"GXBeam.initial_point_residual!","text":"initial_point_residual!(resid, x, indices, rate_vars,  \n    force_scaling, assembly, ipoint, prescribed_conditions, point_masses, gravity, \n    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration, \n    u0, θ0, V0, Ω0, Vdot0, Ωdot0)\n\nCalculate and insert the residual entries corresponding to a point for the initialization  of a time domain analysis into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.newmark_point_residual!","page":"API Reference","title":"GXBeam.newmark_point_residual!","text":"newmark_point_residual!(resid, x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity, \n    udot_init, θdot_init, Vdot_init, Ωdot_init, dt)\n\nCalculate and insert the residual entries corresponding to a point for a newmark-scheme  time marching analysis into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_point_residual!","page":"API Reference","title":"GXBeam.dynamic_point_residual!","text":"dynamic_point_residual!(resid, dx, x, indices, force_scaling, assembly, ipoint, \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity)\n\nCalculate and insert the residual entries corresponding to a point for a dynamic analysis  into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_point_residual!","page":"API Reference","title":"GXBeam.expanded_steady_point_residual!","text":"expanded_steady_point_residual!(resid, x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity, \n    linear_acceleration, angular_acceleration)\n\nCalculate and insert the residual entries corresponding to a point into the system residual  vector for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_point_residual!","page":"API Reference","title":"GXBeam.expanded_dynamic_point_residual!","text":"expanded_dynamic_point_residual!(resid, dx, x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity)\n\nCalculate and insert the residual entries corresponding to a point into the system residual  vector for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_point_jacobian_properties","page":"API Reference","title":"GXBeam.static_point_jacobian_properties","text":"static_point_jacobian_properties(properties, x, indices, force_scaling, assembly, \n    ipoint, prescribed_conditions, point_masses, gravity)\n\nCalculate/extract the point properties needed to calculate the jacobian entries  corresponding to a point for a static analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_point_jacobian_properties","page":"API Reference","title":"GXBeam.steady_point_jacobian_properties","text":"steady_point_jacobian_properties(properties, x, indices, force_scaling, \n    assembly, ipoint, prescribed_conditions, point_masses, gravity, \n    ub_ub, θb_θb, vb_vb, ωb_ωb, ab_ab, αb_αb)\n\nCalculate/extract the point properties needed to calculate the jacobian entries  corresponding to a point for a steady state analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_point_jacobian_properties","page":"API Reference","title":"GXBeam.initial_point_jacobian_properties","text":"initial_point_jacobian_properties(properties, x, indices, rate_vars, \n    force_scaling, assembly, ipoint, prescribed_conditions, point_masses, gravity, \n    u0, θ0, V0, Ω0, Vdot0, Ωdot0)\n\nCalculate/extract the point properties needed to calculate the jacobian entries  corresponding to a point for a Newmark scheme time marching analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.newmark_point_jacobian_properties","page":"API Reference","title":"GXBeam.newmark_point_jacobian_properties","text":"newmark_point_jacobian_properties(properties, x, indices, force_scaling, \n    assembly, ipoint, prescribed_conditions, point_masses, gravity, \n    udot_init, θdot_init, Vdot_init, Ωdot_init, dt)\n\nCalculate/extract the point properties needed to calculate the jacobian entries  corresponding to a point for a Newmark scheme time marching analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_point_jacobian_properties","page":"API Reference","title":"GXBeam.dynamic_point_jacobian_properties","text":"dynamic_point_jacobian_properties(properties, dx, x, indices, force_scaling, \n    assembly, ipoint, prescribed_conditions, point_masses, gravity)\n\nCalculate/extract the point properties needed to calculate the jacobian entries  corresponding to a point for a dynamic analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_point_jacobian_properties","page":"API Reference","title":"GXBeam.expanded_steady_point_jacobian_properties","text":"expanded_steady_point_jacobian_properties(properties, x, indices, force_scaling, \n    assembly, ipoint, prescribed_conditions, point_masses, gravity)\n\nCalculate/extract the point properties needed to calculate the jacobian entries  corresponding to a point for a constant mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_point_jacobian_properties","page":"API Reference","title":"GXBeam.expanded_dynamic_point_jacobian_properties","text":"expanded_dynamic_point_jacobian_properties(properties, dx, x, indices, force_scaling, \n    assembly, ipoint, prescribed_conditions, point_masses, gravity)\n\nCalculate/extract the point properties needed to calculate the jacobian entries  corresponding to a point for a constant mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.mass_matrix_point_jacobian_properties","page":"API Reference","title":"GXBeam.mass_matrix_point_jacobian_properties","text":"mass_matrix_point_jacobian_properties(x, indices, force_scaling, \n    assembly, ipoint, prescribed_conditions, point_masses)\n\nCalculate/extract the point properties needed to calculate the mass matrix jacobian entries  corresponding to a point\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_mass_matrix_point_jacobian_properties","page":"API Reference","title":"GXBeam.expanded_mass_matrix_point_jacobian_properties","text":"expanded_mass_matrix_point_jacobian_properties(assembly, ipoint, prescribed_conditions, point_masses)\n\nCalculate/extract the point properties needed to calculate the mass matrix jacobian entries  corresponding to a point for a constant mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_point_resultant_jacobians","page":"API Reference","title":"GXBeam.static_point_resultant_jacobians","text":"static_point_resultant_jacobians(properties)\n\nCalculate the jacobians for the net loads F and M applied at a point for a static analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_point_resultant_jacobians","page":"API Reference","title":"GXBeam.steady_point_resultant_jacobians","text":"steady_point_resultant_jacobians(properties)\n\nCalculate the jacobians for the net loads F and M applied at a point for a steady state  analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_point_resultant_jacobians","page":"API Reference","title":"GXBeam.initial_point_resultant_jacobians","text":"initial_point_resultant_jacobians(properties)\n\nCalculate the jacobians for the net loads F and M applied at a point for the initialization of a time domain analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_point_resultant_jacobians","page":"API Reference","title":"GXBeam.dynamic_point_resultant_jacobians","text":"dynamic_point_resultant_jacobians(properties)\n\nCalculate the jacobians for the net loads F and M applied at a point for a dynamic  analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_point_resultant_jacobians","page":"API Reference","title":"GXBeam.expanded_steady_point_resultant_jacobians","text":"expanded_steady_point_resultant_jacobians(properties)\n\nCalculate the jacobians for the net loads F and M applied at a point for a constant mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_point_resultant_jacobians","page":"API Reference","title":"GXBeam.expanded_dynamic_point_resultant_jacobians","text":"expanded_dynamic_point_resultant_jacobians(properties)\n\nCalculate the jacobians for the net loads F and M applied at a point for a constant mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.mass_matrix_point_resultant_jacobians","page":"API Reference","title":"GXBeam.mass_matrix_point_resultant_jacobians","text":"mass_matrix_point_resultant_jacobians(properties)\n\nCalculate the mass matrix jacobians for the net loads F and M applied at a point\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_point_velocity_jacobians","page":"API Reference","title":"GXBeam.initial_point_velocity_jacobians","text":"initial_point_velocity_jacobians(properties)\n\nCalculate the jacobians of the velocity residuals rV and rΩ of a point for the initialization of a time domain analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.newmark_point_velocity_jacobians","page":"API Reference","title":"GXBeam.newmark_point_velocity_jacobians","text":"newmark_point_velocity_jacobians(properties)\n\nCalculate the jacobians of the velocity residuals rV and rΩ of a point for a Newmark  scheme time-marching analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_point_velocity_jacobians","page":"API Reference","title":"GXBeam.dynamic_point_velocity_jacobians","text":"dynamic_point_velocity_jacobians(properties)\n\nCalculate the jacobians of the velocity residuals rV and rΩ of a point for a dynamic  state analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_point_velocity_jacobians","page":"API Reference","title":"GXBeam.expanded_point_velocity_jacobians","text":"expanded_point_velocity_jacobians(properties)\n\nCalculate the jacobians of the velocity residuals rV and rΩ of a point for a constant  mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.mass_matrix_point_velocity_jacobians","page":"API Reference","title":"GXBeam.mass_matrix_point_velocity_jacobians","text":"mass_matrix_point_velocity_jacobians(properties)\n\nCalculate the mass matrix jacobians of the velocity residuals rV and rΩ of a point\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.insert_static_point_jacobians!","page":"API Reference","title":"GXBeam.insert_static_point_jacobians!","text":"insert_static_point_jacobians!(jacob, indices, force_scaling, ipoint, properties, \n    resultants)\n\nInsert the jacobian entries corresponding to a point for a static analysis  into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.insert_initial_point_jacobians!","page":"API Reference","title":"GXBeam.insert_initial_point_jacobians!","text":"insert_initial_point_jacobians!(jacob, indices, force_scaling, ipoint, properties, \n    resultants, velocities)\n\nInsert the jacobian entries corresponding to a point for the initialization of a  time domain analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.insert_dynamic_point_jacobians!","page":"API Reference","title":"GXBeam.insert_dynamic_point_jacobians!","text":"insert_dynamic_point_jacobians!(jacob, indices, force_scaling, ipoint, \n    properties, resultants, velocities)\n\nInsert the jacobian entries corresponding to a point for a steady state analysis into the  system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.insert_expanded_steady_point_jacobians!","page":"API Reference","title":"GXBeam.insert_expanded_steady_point_jacobians!","text":"insert_expanded_steady_point_jacobians!(jacob, indices, force_scaling, ipoint, properties, \n    resultants, velocities)\n\nInsert the jacobian entries corresponding to a point for a constant mass matrix system into  the system jacobian matrix for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.insert_expanded_dynamic_point_jacobians!","page":"API Reference","title":"GXBeam.insert_expanded_dynamic_point_jacobians!","text":"insert_expanded_dynamic_point_jacobians!(jacob, indices, force_scaling, ipoint, properties, \n    resultants, velocities)\n\nInsert the jacobian entries corresponding to a point for a constant mass matrix system into  the system jacobian matrix for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.insert_mass_matrix_point_jacobians!","page":"API Reference","title":"GXBeam.insert_mass_matrix_point_jacobians!","text":"insert_mass_matrix_point_jacobians!(jacob, gamma, indices, two_dimensional, force_scaling, ipoint, \n    properties, resultants, velocities)\n\nInsert the mass matrix jacobian entries corresponding to a point into the system jacobian  matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_point_jacobian!","page":"API Reference","title":"GXBeam.static_point_jacobian!","text":"static_point_jacobian!(jacob, x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity)\n\nCalculate and insert the jacobian entries corresponding to a point for a static analysis  into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_point_jacobian!","page":"API Reference","title":"GXBeam.steady_point_jacobian!","text":"steady_point_jacobian!(jacob, x, indices, force_scaling, assembly, \n    ipoint, prescribed_conditions, point_masses, gravity, \n    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)\n\nCalculate and insert the jacobian entries corresponding to a point for a steady state  analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_point_jacobian!","page":"API Reference","title":"GXBeam.initial_point_jacobian!","text":"initial_point_jacobian!(jacob, x, indices, rate_vars, \n    force_scaling, assembly, ipoint, prescribed_conditions, point_masses, gravity, \n    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration, \n    u0, θ0, V0, Ω0, Vdot0, Ωdot0)\n\nCalculate and insert the jacobian entries corresponding to a point for the initialization of a time domain analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.newmark_point_jacobian!","page":"API Reference","title":"GXBeam.newmark_point_jacobian!","text":"newmark_point_jacobian!(jacob, x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity, \n    udot_init, θdot_init, Vdot_init, Ωdot_init, dt))\n\nCalculate and insert the jacobian entries corresponding to a point for a Newmark scheme time marching analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_point_jacobian!","page":"API Reference","title":"GXBeam.dynamic_point_jacobian!","text":"dynamic_point_jacobian!(jacob, dx, x, indices, force_scaling, assembly, ipoint, \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity)\n\nCalculate and insert the jacobian entries corresponding to a point for a dynamic  analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_point_jacobian!","page":"API Reference","title":"GXBeam.expanded_steady_point_jacobian!","text":"expanded_steady_point_jacobian!(jacob, x, indices, force_scaling, \n    assembly, ipoint, prescribed_conditions, point_masses, gravity,\n    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)\n\nCalculate and insert the jacobian entries corresponding to a point for a constant mass  matrix system into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_point_jacobian!","page":"API Reference","title":"GXBeam.expanded_dynamic_point_jacobian!","text":"expanded_dynamic_point_jacobian!(jacob, dx, x, indices, force_scaling, assembly, ipoint,  \n    prescribed_conditions, point_masses, gravity, linear_velocity, angular_velocity)\n\nCalculate and insert the jacobian entries corresponding to a point for a constant mass  matrix system into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.mass_matrix_point_jacobian!","page":"API Reference","title":"GXBeam.mass_matrix_point_jacobian!","text":"mass_matrix_point_jacobian!(jacob, gamma, x, indices, two_dimensional, force_scaling, assembly, \n    ipoint, prescribed_conditions)\n\nCalculate and insert the mass_matrix jacobian entries corresponding to a point into the  system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_mass_matrix_point_jacobian!","page":"API Reference","title":"GXBeam.expanded_mass_matrix_point_jacobian!","text":"expanded_mass_matrix_point_jacobian!(jacob, gamma, indices, two_dimensional, force_scaling, assembly, \n    ipoint, prescribed_conditions, point_masses)\n\nCalculate and insert the mass_matrix jacobian entries corresponding to a point into the  system jacobian matrix for a constant mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Elements","page":"API Reference","title":"Elements","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"GXBeam.Element\nGXBeam.element_loads\nGXBeam.expanded_element_loads\nGXBeam.expanded_element_velocities\nGXBeam.static_element_properties\nGXBeam.steady_element_properties\nGXBeam.initial_element_properties\nGXBeam.newmark_element_properties\nGXBeam.dynamic_element_properties\nGXBeam.expanded_steady_element_properties\nGXBeam.expanded_dynamic_element_properties\nGXBeam.compatability_residuals\nGXBeam.expanded_element_steady_velocity_residuals\nGXBeam.expanded_element_dynamic_velocity_residuals\nGXBeam.expanded_element_equilibrium_residuals\nGXBeam.static_element_resultants\nGXBeam.dynamic_element_resultants\nGXBeam.expanded_element_resultants\nGXBeam.insert_element_residuals!\nGXBeam.insert_expanded_element_residuals!\nGXBeam.static_element_residual!\nGXBeam.steady_element_residual!\nGXBeam.initial_element_residual!\nGXBeam.newmark_element_residual!\nGXBeam.dynamic_element_residual!\nGXBeam.expanded_steady_element_residual!\nGXBeam.expanded_dynamic_element_residual!\nGXBeam.static_element_jacobian_properties\nGXBeam.steady_element_jacobian_properties\nGXBeam.initial_element_jacobian_properties\nGXBeam.newmark_element_jacobian_properties\nGXBeam.dynamic_element_jacobian_properties\nGXBeam.expanded_steady_element_jacobian_properties\nGXBeam.expanded_dynamic_element_jacobian_properties\nGXBeam.mass_matrix_element_jacobian_properties\nGXBeam.expanded_mass_matrix_element_jacobian_properties\nGXBeam.expanded_element_steady_velocity_jacobians\nGXBeam.expanded_element_dynamic_velocity_jacobians\nGXBeam.expanded_steady_element_equilibrium_jacobians\nGXBeam.expanded_dynamic_element_equilibrium_jacobians\nGXBeam.expanded_mass_matrix_element_equilibrium_jacobians\nGXBeam.static_element_resultant_jacobians\nGXBeam.steady_element_resultant_jacobians\nGXBeam.initial_element_resultant_jacobians\nGXBeam.dynamic_element_resultant_jacobians\nGXBeam.expanded_element_resultant_jacobians\nGXBeam.mass_matrix_element_resultant_jacobians\nGXBeam.expanded_mass_matrix_element_velocity_jacobians\nGXBeam.static_element_jacobian!\nGXBeam.steady_element_jacobian!\nGXBeam.initial_element_jacobian!\nGXBeam.newmark_element_jacobian!\nGXBeam.dynamic_element_jacobian!\nGXBeam.expanded_steady_element_jacobian!\nGXBeam.expanded_dynamic_element_jacobian!\nGXBeam.mass_matrix_element_jacobian!\nGXBeam.expanded_mass_matrix_element_jacobian!","category":"page"},{"location":"reference/reference/#GXBeam.Element","page":"API Reference","title":"GXBeam.Element","text":"Element{TF}\n\nComposite type that defines a beam element's properties\n\nFields\n\nL: Beam element length\nx: Beam element location\ncompliance: Beam element compliance matrix\nmass: Beam element mass matrix\nCab: Transformation matrix from the undeformed beam element frame to the body frame\nmu: Beam element damping coefficients\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.element_loads","page":"API Reference","title":"GXBeam.element_loads","text":"element_loads(x, ielem, icol_elem, force_scaling)\n\nExtract the internal loads (F, M) for a beam element from the state variable vector.   These loads are expressed in the deformed element frame.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_element_loads","page":"API Reference","title":"GXBeam.expanded_element_loads","text":"expanded_element_loads(x, ielem, icol_elem, force_scaling)\n\nExtract the internal loads of a beam element at its endpoints (F1, M1, F2, M2)  from the state variable vector for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_element_velocities","page":"API Reference","title":"GXBeam.expanded_element_velocities","text":"expanded_element_velocities(x, ielem, icol_elem)\n\nExtract the velocities of a beam element from the state variable vector for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_element_properties","page":"API Reference","title":"GXBeam.static_element_properties","text":"static_element_properties(x, indices, force_scaling, assembly, ielem, \n    prescribed_conditions, gravity)\n\nCalculate/extract the element properties needed to construct the residual for a static  analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_element_properties","page":"API Reference","title":"GXBeam.steady_element_properties","text":"steady_element_properties(x, indices, force_scaling, structural_damping, \n    assembly, ielem, prescribed_conditions, gravity, linear_velocity, angular_velocity, \n    linear_acceleration=(@SVector zeros(3)), angular_acceleration=(@SVector zeros(3)))\n\nCalculate/extract the element properties needed to construct the residual for a steady  state analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_element_properties","page":"API Reference","title":"GXBeam.initial_element_properties","text":"initial_element_properties(x, indices, rate_vars, force_scaling, \n    structural_damping, assembly, ielem, prescribed_conditions, gravity, \n    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration, u0, θ0, V0, Ω0, Vdot0, Ωdot0)\n\nCalculate/extract the element properties needed to construct the residual for a time-domain analysis initialization\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.newmark_element_properties","page":"API Reference","title":"GXBeam.newmark_element_properties","text":"newmark_element_properties(x, indices, force_scaling, structural_damping, \n    assembly, ielem, prescribed_conditions, gravity, linear_velocity, angular_velocity,\n    Vdot_init, Ωdot_init, dt)\n\nCalculate/extract the element properties needed to construct the residual for a newmark- scheme time stepping analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_element_properties","page":"API Reference","title":"GXBeam.dynamic_element_properties","text":"dynamic_element_properties(dx, x, indices, force_scaling, structural_damping, \n    assembly, ielem, prescribed_conditions, gravity, linear_velocity, angular_velocity)\n\nCalculate/extract the element properties needed to construct the residual for a dynamic  analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_element_properties","page":"API Reference","title":"GXBeam.expanded_steady_element_properties","text":"expanded_steady_element_properties(x, indices, force_scaling, structural_damping, \n    assembly, ielem, prescribed_conditions, gravity, linear_velocity, angular_velocity, \n    linear_acceleration=(@SVector zeros(3)), angular_acceleration=(@SVector zeros(3)))\n\nCalculate/extract the element properties needed to construct the residual for a constant mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_element_properties","page":"API Reference","title":"GXBeam.expanded_dynamic_element_properties","text":"expanded_dynamic_element_properties(dx, x, indices, force_scaling, structural_damping, \n    assembly, ielem, prescribed_conditions, gravity, linear_velocity, angular_velocity)\n\nCalculate/extract the element properties needed to construct the residual for a constant mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_element_equilibrium_residuals","page":"API Reference","title":"GXBeam.expanded_element_equilibrium_residuals","text":"expanded_element_equilibrium_residuals(properties, distributed_loads, ielem)\n\nCalculate the equilibrium residuals of a beam element for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_element_resultants","page":"API Reference","title":"GXBeam.static_element_resultants","text":"static_element_resultants(properties, distributed_loads, ielem)\n\nCalculate the resultant loads applied at each end of a beam element for a static analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_element_resultants","page":"API Reference","title":"GXBeam.dynamic_element_resultants","text":"dynamic_element_resultants(properties, distributed_loads, ielem)\n\nCalculate the resultant loads applied at each end of a beam element for a steady state  analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_element_resultants","page":"API Reference","title":"GXBeam.expanded_element_resultants","text":"expanded_element_resultants(properties)\n\nCalculate the resultant loads applied at each end of a beam element for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.insert_element_residuals!","page":"API Reference","title":"GXBeam.insert_element_residuals!","text":"insert_element_residuals!(resid, indices, force_scaling, assembly, ielem, \n    compatibility, resultants)\n\nInsert the residual entries corresponding to a beam element into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.insert_expanded_element_residuals!","page":"API Reference","title":"GXBeam.insert_expanded_element_residuals!","text":"insert_expanded_element_residuals!(resid, indices, force_scaling, assembly, ielem, \n    compatibility, velocities, equilibrium, resultants)\n\nInsert the residual entries corresponding to a beam element into the system residual vector for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_element_residual!","page":"API Reference","title":"GXBeam.static_element_residual!","text":"static_element_residual!(resid, x, indices, force_scaling, assembly, ielem,  \n    prescribed_conditions, distributed_loads, gravity)\n\nCalculate and insert the residual entries corresponding to a beam element for a static  analysis into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_element_residual!","page":"API Reference","title":"GXBeam.steady_element_residual!","text":"steady_element_residual!(resid, x, indices, force_scaling, structural_damping, \n    assembly, ielem, prescribed_conditions, distributed_loads, gravity, \n    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)\n\nCalculate and insert the residual entries corresponding to a beam element for a steady state  analysis into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_element_residual!","page":"API Reference","title":"GXBeam.initial_element_residual!","text":"initial_element_residual!(resid, x, indices, rate_vars, \n    force_scaling, structural_damping, assembly, ielem, prescribed_conditions, \n    distributed_loads, gravity, linear_velocity, angular_velocity, \n    linear_acceleration, angular_acceleration, u0, θ0, V0, Ω0, Vdot0, Ωdot0)\n\nCalculate and insert the residual entries corresponding to a beam element for the  initialization of a time domain simulation into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.newmark_element_residual!","page":"API Reference","title":"GXBeam.newmark_element_residual!","text":"newmark_element_residual!(resid, x, indices, force_scaling, structural_damping, \n    assembly, ielem, prescribed_conditions, distributed_loads, gravity, \n    linear_velocity, angular_velocity, Vdot_init, Ωdot_init, dt)\n\nCalculate and insert the residual entries corresponding to a beam element for a  newmark-scheme time marching analysis into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_element_residual!","page":"API Reference","title":"GXBeam.dynamic_element_residual!","text":"dynamic_element_residual!(resid, dx, x, indices, force_scaling, structural_damping, \n    assembly, ielem, prescribed_conditions, distributed_loads, gravity, \n    linear_velocity, angular_velocity)\n\nCalculate and insert the residual entries corresponding to a beam element for a dynamic analysis into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_element_residual!","page":"API Reference","title":"GXBeam.expanded_steady_element_residual!","text":"expanded_steady_element_residual!(resid, x, indices, force_scaling, structural_damping, \n    assembly, ielem, prescribed_conditions, distributed_loads, gravity,\n    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)\n\nCalculate and insert the residual entries corresponding to a beam element for a constant mass matrix system into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_element_residual!","page":"API Reference","title":"GXBeam.expanded_dynamic_element_residual!","text":"expanded_dynamic_element_residual!(resid, dx, x, indices, force_scaling, \n    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads, \n    gravity, linear_velocity, angular_velocity)\n\nCalculate and insert the residual entries corresponding to a beam element for a constant mass matrix system into the system residual vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_element_jacobian_properties","page":"API Reference","title":"GXBeam.static_element_jacobian_properties","text":"static_element_jacobian_properties(properties, x, indices, force_scaling, \n    assembly, ielem, prescribed_conditions, gravity)\n\nCalculate/extract the element properties needed to calculate the jacobian entries  corresponding to a beam element for a static analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_element_jacobian_properties","page":"API Reference","title":"GXBeam.steady_element_jacobian_properties","text":"steady_element_jacobian_properties(properties, x, indices, \n    force_scaling, structural_damping, assembly, ielem, prescribed_conditions, \n    gravity)\n\nCalculate/extract the element properties needed to calculate the jacobian entries  corresponding to a element for a steady state analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_element_jacobian_properties","page":"API Reference","title":"GXBeam.initial_element_jacobian_properties","text":"initial_element_jacobian_properties(properties, x, indices, rate_vars, \n    force_scaling, structural_damping, assembly, ielem, prescribed_conditions, gravity, \n    u0, θ0, V0, Ω0, Vdot0, Ωdot0)\n\nCalculate/extract the element properties needed to calculate the jacobian entries  corresponding to a element for a Newmark scheme time marching analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.newmark_element_jacobian_properties","page":"API Reference","title":"GXBeam.newmark_element_jacobian_properties","text":"newmark_element_jacobian_properties(properties, x, indices, force_scaling, \n    structural_damping, assembly, ielem, prescribed_conditions, gravity, \n    Vdot_init, Ωdot_init, dt)\n\nCalculate/extract the element properties needed to calculate the jacobian entries  corresponding to a element for a Newmark scheme time marching analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_element_jacobian_properties","page":"API Reference","title":"GXBeam.dynamic_element_jacobian_properties","text":"dynamic_element_jacobian_properties(properties, dx, x, indices, \n    force_scaling, assembly, ielem, prescribed_conditions, gravity)\n\nCalculate/extract the element properties needed to calculate the jacobian entries  corresponding to a element for a dynamic analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_element_jacobian_properties","page":"API Reference","title":"GXBeam.expanded_steady_element_jacobian_properties","text":"expanded_element_jacobian_properties(properties, x, indices, force_scaling, \n    structural_damping, assembly, ielem, prescribed_conditions, gravity)\n\nCalculate/extract the element properties needed to calculate the jacobian entries  corresponding to a element for a steady state analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_element_jacobian_properties","page":"API Reference","title":"GXBeam.expanded_dynamic_element_jacobian_properties","text":"expanded_dynamic_element_jacobian_properties(properties, dx, x, indices, force_scaling, \n    structural_damping, assembly, ielem, prescribed_conditions, gravity)\n\nCalculate/extract the element properties needed to calculate the jacobian entries  corresponding to a element for a dynamic analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.mass_matrix_element_jacobian_properties","page":"API Reference","title":"GXBeam.mass_matrix_element_jacobian_properties","text":"mass_matrix_element_jacobian_properties(x, indices, force_scaling, \nassembly, ielem, prescribed_conditions)\n\nCalculate/extract the element properties needed to calculate the mass matrix jacobian entries  corresponding to a beam element\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_mass_matrix_element_jacobian_properties","page":"API Reference","title":"GXBeam.expanded_mass_matrix_element_jacobian_properties","text":"expanded_mass_matrix_element_jacobian_properties(assembly, ielem, prescribed_conditions)\n\nCalculate/extract the element properties needed to calculate the mass matrix jacobian entries  corresponding to a beam element for a constant mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_element_equilibrium_jacobians","page":"API Reference","title":"GXBeam.expanded_steady_element_equilibrium_jacobians","text":"expanded_steady_element_equilibrium_jacobians(properties)\n\nCalculate the jacobians of the element equilibrium residuals for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_element_equilibrium_jacobians","page":"API Reference","title":"GXBeam.expanded_dynamic_element_equilibrium_jacobians","text":"expanded_dynamic_element_equilibrium_jacobians(properties)\n\nCalculate the jacobians of the element equilibrium residuals for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_mass_matrix_element_equilibrium_jacobians","page":"API Reference","title":"GXBeam.expanded_mass_matrix_element_equilibrium_jacobians","text":"expanded_mass_matrix_element_equilibrium_jacobians(properties)\n\nCalculate the mass matrix jacobians for the resultant loads applied at each end of a  beam element for a constant mass matrix system \n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_element_resultant_jacobians","page":"API Reference","title":"GXBeam.static_element_resultant_jacobians","text":"static_element_resultant_jacobians(properties, distributed_loads, ielem)\n\nCalculate the jacobians for the resultant loads applied at each end of a beam element  for a static analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_element_resultant_jacobians","page":"API Reference","title":"GXBeam.steady_element_resultant_jacobians","text":"steady_element_resultant_jacobians(properties, distributed_loads, ielem)\n\nCalculate the jacobians for the resultant loads applied at each end of a beam element  for a steady state analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_element_resultant_jacobians","page":"API Reference","title":"GXBeam.initial_element_resultant_jacobians","text":"initial_element_resultant_jacobians(properties, distributed_loads, ielem)\n\nCalculate the jacobians for the resultant loads applied at each end of V beam element  for the initialization of a time domain analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_element_resultant_jacobians","page":"API Reference","title":"GXBeam.dynamic_element_resultant_jacobians","text":"dynamic_element_resultant_jacobians(properties, distributed_loads, ielem)\n\nCalculate the jacobians for the resultant loads applied at each end of a beam element  for a dynamic analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_element_resultant_jacobians","page":"API Reference","title":"GXBeam.expanded_element_resultant_jacobians","text":"expanded_element_resultant_jacobians(properties)\n\nCalculate the jacobians for the resultant loads applied at each end of a beam element  for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.mass_matrix_element_resultant_jacobians","page":"API Reference","title":"GXBeam.mass_matrix_element_resultant_jacobians","text":"mass_matrix_element_resultant_jacobians(properties)\n\nCalculate the mass matrix jacobians for the resultant loads applied at each end of a beam element \n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_element_jacobian!","page":"API Reference","title":"GXBeam.static_element_jacobian!","text":"static_element_jacobian!(jacob, x, indices, force_scaling, \n    assembly, ielem, prescribed_conditions, distributed_loads, gravity)\n\nCalculate and insert the jacobian entries corresponding to a beam element for a static  analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_element_jacobian!","page":"API Reference","title":"GXBeam.steady_element_jacobian!","text":"steady_element_jacobian!(jacob, x, indices, force_scaling, \n    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads, \n    gravity, linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)\n\nCalculate and insert the jacobian entries corresponding to a beam element for a steady state  analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_element_jacobian!","page":"API Reference","title":"GXBeam.initial_element_jacobian!","text":"initial_element_jacobian!(jacob, x, indices, rate_vars, force_scaling, \n    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads, \n    gravity, ub, θb, vb, ωb, ab, αb, u0, θ0, V0, Ω0, Vdot0, Ωdot0)\n\nCalculate and insert the jacobian entries corresponding to a beam element for the  initialization of a time domain analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.newmark_element_jacobian!","page":"API Reference","title":"GXBeam.newmark_element_jacobian!","text":"newmark_element_jacobian!(jacob, x, indices, force_scaling, \n    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads, \n    gravity, linear_velocity, angular_velocity, Vdot_init, Ωdot_init, dt)\n\nCalculate and insert the jacobian entries corresponding to a beam element for a Newmark-scheme time marching analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_element_jacobian!","page":"API Reference","title":"GXBeam.dynamic_element_jacobian!","text":"dynamic_element_jacobian!(jacob, dx, x, indices, force_scaling, \n    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads, \n    gravity, linear_velocity, angular_velocity)\n\nCalculate and insert the jacobian entries corresponding to a beam element for a dynamic analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_element_jacobian!","page":"API Reference","title":"GXBeam.expanded_steady_element_jacobian!","text":"expanded_steady_element_jacobian!(jacob, x, indices, force_scaling, \n    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads, \n    gravity, linear_velocity, angular_velocity, linear_acceleration, \n    angular_acceleration)\n\nCalculate and insert the jacobian entries corresponding to a beam element for a dynamic analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_element_jacobian!","page":"API Reference","title":"GXBeam.expanded_dynamic_element_jacobian!","text":"expanded_dynamic_element_jacobian!(jacob, dx, x, indices, force_scaling, \n    structural_damping, assembly, ielem, prescribed_conditions, distributed_loads, \n    gravity, linear_velocity, angular_velocity)\n\nCalculate and insert the jacobian entries corresponding to a beam element for a dynamic analysis into the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.mass_matrix_element_jacobian!","page":"API Reference","title":"GXBeam.mass_matrix_element_jacobian!","text":"mass_matrix_element_jacobian!(jacob, gamma, x, indices, two_dimensional, force_scaling, assembly, \n    ielem, prescribed_conditions)\n\nCalculate and insert the mass_matrix jacobian entries corresponding to a beam element into  the system jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_mass_matrix_element_jacobian!","page":"API Reference","title":"GXBeam.expanded_mass_matrix_element_jacobian!","text":"expanded_mass_matrix_element_jacobian!(jacob, gamma, indices, two_dimensional, force_scaling, assembly, \n    ielem, prescribed_conditions)\n\nCalculate and insert the mass_matrix jacobian entries corresponding to a beam element into  the system jacobian matrix for a constant mass matrix system\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#System","page":"API Reference","title":"System","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"GXBeam.SystemIndices\nGXBeam.default_force_scaling\nGXBeam.curve_triad\nGXBeam.curve_coordinates\nGXBeam.static_system_residual!\nGXBeam.initial_system_residual!\nGXBeam.steady_system_residual!\nGXBeam.newmark_system_residual!\nGXBeam.dynamic_system_residual!\nGXBeam.expanded_steady_system_residual!\nGXBeam.expanded_dynamic_system_residual!\nGXBeam.static_system_jacobian!\nGXBeam.steady_system_jacobian!\nGXBeam.initial_system_jacobian!\nGXBeam.newmark_system_jacobian!\nGXBeam.dynamic_system_jacobian!\nGXBeam.expanded_steady_system_jacobian!\nGXBeam.expanded_dynamic_system_jacobian!\nGXBeam.system_mass_matrix!\nGXBeam.expanded_system_mass_matrix\nGXBeam.expanded_system_mass_matrix!","category":"page"},{"location":"reference/reference/#GXBeam.SystemIndices","page":"API Reference","title":"GXBeam.SystemIndices","text":"SystemIndices\n\nStructure for holding indices for accessing the state variables and equations associated  with each point and beam element in a system.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#GXBeam.default_force_scaling","page":"API Reference","title":"GXBeam.default_force_scaling","text":"default_force_scaling(assembly)\n\nDefines a suitable default force scaling factor based on the nonzero elements of the  compliance matrices in assembly.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.curve_triad","page":"API Reference","title":"GXBeam.curve_triad","text":"curve_triad(Cab, k, s)\ncurve_triad(Cab, kkt, ktilde, kn, s)\n\nReturn the transformation matrix at s along the length of the beam given the curvature vector k and the initial transformation matrix Cab.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.curve_coordinates","page":"API Reference","title":"GXBeam.curve_coordinates","text":"curve_coordiantes(r, Cab, k, s)\ncurve_coordinates(r, Cab, kkt, ktilde, kn, s)\n\nReturn the coordinates at s along the length of the beam given the starting point r, initial transformation matrix Cab, and curvature vector k.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_system_residual!","page":"API Reference","title":"GXBeam.static_system_residual!","text":"static_system_residual!(resid, x, indices, two_dimensional, force_scaling, \n    assembly, prescribed_conditions, distributed_loads, point_masses, gravity)\n\nPopulate the system residual vector resid for a static analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_system_residual!","page":"API Reference","title":"GXBeam.initial_system_residual!","text":"initial_system_residual!(resid, x, indices, rate_vars1, rate_vars2, \n    two_dimensional, force_scaling, structural_damping, assembly, prescribed_conditions, \n    distributed_loads, point_masses, gravity, linear_velocity, angular_velocity, \n    linear_acceleration, angular_acceleration, u0, θ0, V0, Ω0, Vdot0, Ωdot0)\n\nPopulate the system residual vector resid for the initialization of a time domain  simulation.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_system_residual!","page":"API Reference","title":"GXBeam.steady_system_residual!","text":"steady_system_residual!(resid, x, indices, two_dimensional, force_scaling, \n    structural_damping, assembly, prescribed_conditions, distributed_loads, \n    point_masses, gravity, vb, ωb, ab, αb)\n\nPopulate the system residual vector resid for a steady state analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.newmark_system_residual!","page":"API Reference","title":"GXBeam.newmark_system_residual!","text":"newmark_system_residual!(resid, x, indices, two_dimensional, force_scaling, structural_damping, \n    assembly, prescribed_conditions, distributed_loads, point_masses, gravity,\n    linear_velocity, angular_velocity, udot_init, θdot_init, Vdot_init, Ωdot_init, dt)\n\nPopulate the system residual vector resid for a Newmark scheme time marching analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_system_residual!","page":"API Reference","title":"GXBeam.dynamic_system_residual!","text":"dynamic_system_residual!(resid, dx, x, indices, two_dimensional, force_scaling, \n    structural_damping, assembly, prescribed_conditions, distributed_loads, \n    point_masses, gravity, linear_velocity, angular_velocity)\n\nPopulate the system residual vector resid for a general dynamic analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_system_residual!","page":"API Reference","title":"GXBeam.expanded_steady_system_residual!","text":"expanded_steady_system_residual!(resid, x, indices, two_dimensional, force_scaling, structural_damping, \n    assembly, prescribed_conditions, distributed_loads, point_masses, gravity, \n    linear_velocity, angular_velocity, linear_acceleration, angular_acceleration)\n\nPopulate the system residual vector resid for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_system_residual!","page":"API Reference","title":"GXBeam.expanded_dynamic_system_residual!","text":"expanded_dynamic_system_residual!(resid, dx, x, indices, two_dimensional, force_scaling, \n    structural_damping, assembly, prescribed_conditions, distributed_loads, \n    point_masses, gravity, linear_velocity, angular_velocity)\n\nPopulate the system residual vector resid for a constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.static_system_jacobian!","page":"API Reference","title":"GXBeam.static_system_jacobian!","text":"static_system_jacobian!(jacob, x, indices, two_dimensional, force_scaling, \n    assembly, prescribed_conditions, distributed_loads, point_masses, gravity)\n\nPopulate the system jacobian matrix jacob for a static analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.steady_system_jacobian!","page":"API Reference","title":"GXBeam.steady_system_jacobian!","text":"steady_system_jacobian!(jacob, x, indices, two_dimensional, force_scaling, \n    structural_damping, assembly, prescribed_conditions, distributed_loads, \n    point_masses, gravity, linear_velocity, angular_velocity, linear_acceleration, \n    angular_acceleration)\n\nPopulate the system jacobian matrix jacob for a steady-state analysis\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.initial_system_jacobian!","page":"API Reference","title":"GXBeam.initial_system_jacobian!","text":"initial_system_jacobian!(jacob, x, indices, rate_vars1, rate_vars2, two_dimensional, force_scaling, \n    structural_damping, assembly, prescribed_conditions, distributed_loads, \n    point_masses, gravity, linear_velocity, angular_velocity, linear_acceleration, \n    angular_acceleration, u0, θ0, V0, Ω0, Vdot0, Ωdot0)\n\nPopulate the system jacobian matrix jacob for the initialization of a time domain  simulation.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.newmark_system_jacobian!","page":"API Reference","title":"GXBeam.newmark_system_jacobian!","text":"newmark_system_jacobian!(jacob, x, indices, two_dimensional, force_scaling, structural_damping, \n    assembly, prescribed_conditions, distributed_loads, point_masses, gravity, \n    linear_velocity, angular_velocity, udot_init, θdot_init, Vdot_init, Ωdot_init, dt)\n\nPopulate the system jacobian matrix jacob for a Newmark scheme time marching analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.dynamic_system_jacobian!","page":"API Reference","title":"GXBeam.dynamic_system_jacobian!","text":"dynamic_system_jacobian!(jacob, dx, x, indices, two_dimensional, force_scaling, \n    structural_damping, assembly, prescribed_conditions, distributed_loads, \n    point_masses, gravity, linear_velocity, angular_velocity)\n\nPopulate the system jacobian matrix jacob for a general dynamic analysis.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_steady_system_jacobian!","page":"API Reference","title":"GXBeam.expanded_steady_system_jacobian!","text":"expanded_steady_system_jacobian!(jacob, x, indices, two_dimensional, force_scaling, structural_damping, \n    assembly, prescribed_conditions, distributed_loads, point_masses, gravity, \n    ub_p, θb_p, vb_p, ωb_p, ab_p, αb_p)\n\nPopulate the system jacobian matrix jacob for a general dynamic analysis with a  constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_dynamic_system_jacobian!","page":"API Reference","title":"GXBeam.expanded_dynamic_system_jacobian!","text":"expanded_dynamic_system_jacobian!(jacob, dx, x, indices, two_dimensional, force_scaling, structural_damping, \n    assembly, prescribed_conditions, distributed_loads, point_masses, gravity, \n    linear_velocity, angular_velocity)\n\nPopulate the system jacobian matrix jacob for a general dynamic analysis with a  constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.system_mass_matrix!","page":"API Reference","title":"GXBeam.system_mass_matrix!","text":"system_mass_matrix!(jacob, x, indices, two_dimensional, force_scaling,  assembly, \n    prescribed_conditions, point_masses)\n\nCalculate the jacobian of the residual expressions with respect to the state rates.\n\n\n\n\n\nsystem_mass_matrix!(jacob, gamma, x, indices, two_dimensional, force_scaling, assembly, \n    prescribed_conditions, point_masses)\n\nCalculate the jacobian of the residual expressions with respect to the state rates and  add the result multiplied by gamma to jacob.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_system_mass_matrix","page":"API Reference","title":"GXBeam.expanded_system_mass_matrix","text":"expanded_system_mass_matrix(system, assembly;\n    two_dimensional = false,\n    prescribed_conditions=Dict{Int, PrescribedConditions}(), \n    point_masses=Dict{Int, PointMass}())\n\nCalculate the jacobian of the residual expressions with respect to the state rates for a  constant mass matrix system.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#GXBeam.expanded_system_mass_matrix!","page":"API Reference","title":"GXBeam.expanded_system_mass_matrix!","text":"expanded_system_mass_matrix!(jacob, indices, two_dimensional, force_scaling,  assembly, prescribed_conditions, \n    point_masses)\n\nCalculate the jacobian of the residual expressions with respect to the state rates.\n\n\n\n\n\nexpanded_system_mass_matrix!(jacob, gamma, indices, two_dimensional, force_scaling, assembly, \n    prescribed_conditions, point_masses)\n\nCalculate the jacobian of the residual expressions with respect to the state rates and  add the result multiplied by gamma to jacob.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"reference/reference/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/diffeq.jl\"","category":"page"},{"location":"examples/diffeq/#diffeq","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"While the capabilities provided by GXBeam are probably sufficient for most users, advanced users may wish to make use of some of the features of the DifferentialEquations package. For this reason, we have created an interface in GXBeam to allow users to model the differential algebraic equations encountered in GXBeam in DifferentialEquations.","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"Pages = [\"diffeq.md\"]\nDepth = 3","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"tip: Tip\nThis guide is also available as a Jupyter notebook: diffeq.ipynb.","category":"page"},{"location":"examples/diffeq/#Interface-Functions","page":"Using GXBeam with DifferentialEquations.jl","title":"Interface Functions","text":"","category":"section"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"The following constructors are available for modeling the differential algebraic equations from GXBeam in DifferentialEquations.","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"GXBeam.ODEFunction(system::AbstractSystem, assembly; kwargs...)\nGXBeam.ODEProblem(system::AbstractSystem, assembly, tspan; kwargs...)\nGXBeam.DAEFunction(system::DynamicSystem, assembly; kwargs...)\nGXBeam.DAEProblem(system::DynamicSystem, assembly, tspan; kwargs...)","category":"page"},{"location":"examples/diffeq/#SciMLBase.ODEFunction-Tuple{AbstractSystem, Any}","page":"Using GXBeam with DifferentialEquations.jl","title":"SciMLBase.ODEFunction","text":"ODEFunction(system::GXBeam.AbstractSystem, assembly, pfunc = (p, t) -> p; kwargs...)\n\nConstruct a ODEFunction for the system of nonlinear beams contained in assembly  which may be used with the DifferentialEquations package.\n\nArguments\n\nsystem:  Object of type GXBeam.AbstractSystem which holds indices for accessing the   state variables and equations associated with each point and beam element in a system.\nassembly: Object of type GXBeam.Assembly which defines an assembly of connected   nonlinear beam elements.\npfunc = (p, t) -> p: Function which returns a named tuple with the fields\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():  A dictionary with keys corresponding to the points at which prescribed conditions   are applied and elements of type PrescribedConditions which describe the   prescribed conditions at those points.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary  with keys corresponding to the elements to which distributed loads are  applied and elements of type DistributedLoads which describe  the distributed loads on those elements.\npoint_masses = Dict{Int,Vector{PointMass{Float64}}}(): A dictionary with keys   corresponding to the points at which point masses are attached and values   containing vectors of objects of type PointMass which describe   the point masses attached at those points.\ngravity: Gravity vector.\nlinear_velocity = zeros(3): Global frame linear velocity vector.\nangular_velocity = zeros(3): Global frame angular velocity vector.\np: Parameters, as defined in conjunction with the keyword argument pfunc.  Defaults to an empty named tuple.  \n\nKeyword Arguments\n\ntwo_dimensional = false: Flag indicating whether to constrain results to the x-y plane\nstructural_damping = true: Flag indicating whether structural damping should be enabled\nconstant_mass_matrix = true: Flag indicating whether to use a constant mass matrix.  \nsparse = false: Flag indicating whether to use a sparse jacobian.\n\n\n\n\n\n","category":"method"},{"location":"examples/diffeq/#SciMLBase.ODEProblem-Tuple{AbstractSystem, Any, Any}","page":"Using GXBeam with DifferentialEquations.jl","title":"SciMLBase.ODEProblem","text":"ODEProblem(system::GXBeam.AbstractSystem, assembly, tspan, p=(;); kwargs...)\n\nConstruct an ODEProblem for the system of nonlinear beams contained in assembly which  may be used with the DifferentialEquations package.\n\nArguments\n\nsystem:  Object of type GXBeam.AbstractSystem which holds indices for accessing the   state variables and equations associated with each point and beam element in a system.\nassembly: Object of type GXBeam.Assembly which defines an assembly of connected   nonlinear beam elements.\ntspan: Time span over which to solve the ODE problem\np: Parameters, as defined in conjunction with the keyword argument pfunc.      Defaults to an empty named tuple.  \n\nKeyword Arguments\n\npfunc = (p, t) -> p: Function which returns a named tuple with parameters as   described in ODEFunction.\ntwo_dimensional = false: Flag indicating whether to constrain results to the x-y plane\nstructural_damping = true: Flag indicating whether structural damping should be enabled\nconstant_mass_matrix = true: Flag indicating whether to use a constant mass matrix.\nsparse = false: Flag indicating whether to use a sparse jacobian.\n\nAdditional keyword arguments are passed forward to ODEProblem.\n\n\n\n\n\n","category":"method"},{"location":"examples/diffeq/#SciMLBase.DAEFunction-Tuple{DynamicSystem, Any}","page":"Using GXBeam with DifferentialEquations.jl","title":"SciMLBase.DAEFunction","text":"DAEFunction(system::GXBeam.DynamicSystem, assembly; kwargs...)\n\nConstruct a DAEFunction for the system of nonlinear beams contained in assembly  which may be used with the DifferentialEquations package.\n\nArguments\n\nsystem:  Object of type GXBeam.AbstractSystem which holds indices for accessing the   state variables and equations associated with each point and beam element in a system.\nassembly: Object of type GXBeam.Assembly which defines an assembly of connected   nonlinear beam elements.\npfunc = (p, t) -> p: Function which returns a named tuple with the fields\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():  A dictionary with keys corresponding to the points at which prescribed conditions   are applied and elements of type PrescribedConditions which describe the   prescribed conditions at those points.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary  with keys corresponding to the elements to which distributed loads are  applied and elements of type DistributedLoads which describe  the distributed loads on those elements.\npoint_masses = Dict{Int,Vector{PointMass{Float64}}}(): A dictionary with keys   corresponding to the points at which point masses are attached and values   containing vectors of objects of type PointMass which describe   the point masses attached at those points.\ngravity: Gravity vector.\nlinear_velocity = zeros(3): Global frame linear velocity vector.\nangular_velocity = zeros(3): Global frame angular velocity vector.\n\nKeyword Arguments:\n\ntwo_dimensional = false: Flag indicating whether to constrain results to the x-y plane\nstructural_damping = true: Flag indicating whether structural damping should be enabled\n\n\n\n\n\n","category":"method"},{"location":"examples/diffeq/#SciMLBase.DAEProblem-Tuple{DynamicSystem, Any, Any}","page":"Using GXBeam with DifferentialEquations.jl","title":"SciMLBase.DAEProblem","text":"DAEProblem(system::GXBeam.DynamicSystem, assembly, tspan, p=(;); kwargs...)\n\nConstruct a DAEProblem for the system of nonlinear beams contained in assembly which  may be used with the DifferentialEquations package.\n\nArguments\n\nsystem:  Object of type GXBeam.AbstractSystem which holds indices for accessing the   state variables and equations associated with each point and beam element in a system.\nassembly: Object of type GXBeam.Assembly which defines an assembly of connected   nonlinear beam elements.\ntspan: Time span over which to solve the ODE problem    \np: Parameters, as defined in conjunction with the keyword argument pfunc.    Defaults to an empty named tuple.\n\nKeyword Arguments\n\npfunc = (p, t) -> p: Function which returns a named tuple with parameters as   described in DAEFunction.\ntwo_dimensional = false: Flag indicating whether to constrain results to the x-y plane\nstructural_damping = true: Flag indicating whether structural damping should be enabled\n\n\n\n\n\n","category":"method"},{"location":"examples/diffeq/#Example-Usage","page":"Using GXBeam with DifferentialEquations.jl","title":"Example Usage","text":"","category":"section"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"For this example we demonstrate how to solve the wind turbine Time-Domain Simulation of a Wind Turbine Blade problem using DifferentialEquations.","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"We start by setting up the problem as if we were solving the problem using GXBeam's internal solver.","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"using GXBeam, LinearAlgebra\n\nL = 60 # m\n\n# create points\nnelem = 10\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# stiffness matrix for each beam element\nstiffness = fill(\n    [2.389e9  1.524e6  6.734e6 -3.382e7 -2.627e7 -4.736e8\n     1.524e6  4.334e8 -3.741e6 -2.935e5  1.527e7  3.835e5\n     6.734e6 -3.741e6  2.743e7 -4.592e5 -6.869e5 -4.742e6\n    -3.382e7 -2.935e5 -4.592e5  2.167e7 -6.279e5  1.430e6\n    -2.627e7  1.527e7 -6.869e5 -6.279e5  1.970e7  1.209e7\n    -4.736e8  3.835e5 -4.742e6  1.430e6  1.209e7  4.406e8],\n    nelem)\n\n# mass matrix for each beam element\nmass = fill(\n    [258.053      0.0        0.0      0.0      7.07839  -71.6871\n       0.0      258.053      0.0     -7.07839  0.0        0.0\n       0.0        0.0      258.053   71.6871   0.0        0.0\n       0.0       -7.07839   71.6871  48.59     0.0        0.0\n       7.07839    0.0        0.0      0.0      2.172      0.0\n     -71.6871     0.0        0.0      0.0      0.0       46.418],\n     nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop; stiffness=stiffness, mass=mass)\n\n# prescribed conditions\nprescribed_conditions = (t) -> begin\n    Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force on right side\n        nelem+1 => PrescribedConditions(Fz = 1e5*sin(20*t))\n    )\nend\n\nnothing #hide","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"At this point if we wanted to use GXBeam's internal solver, we would choose a time discretization and call the time_domain_analysis function.","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"# simulation time\nt = 0:0.001:2.0\n\nsystem, gxbeam_history, converged = time_domain_analysis(assembly, t;\n    prescribed_conditions = prescribed_conditions,\n    structural_damping = false)\n\nnothing #hide","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"To instead use the capabilities of the DifferentialEquations package we first initialize our system using the initial_condition_analysis function and then construct and solve a DAEProblem.","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"using DifferentialEquations\n\n# define simulation time\ntspan = (0.0, 2.0)\n\n# define named tuple with parameters\np = (; prescribed_conditions=prescribed_conditions)\n\n# run initial condition analysis to get consistent set of initial conditions\ndae_system, converged = initial_condition_analysis(assembly, tspan[1];\n    prescribed_conditions = prescribed_conditions,\n    structural_damping = false)\n\n# construct an ODEProblem (with a constant mass matrix)\ndae_prob = DAEProblem(dae_system, assembly, tspan, p;\n    structural_damping = false)\n\n# solve the problem\ndae_sol = solve(dae_prob, DABDF2())\n\nnothing #hide","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"Alternatively, we can construct and solve a constant mass matrix formulation of our differential algebraic equations.","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"# run initial condition analysis to get consistent set of initial conditions\node_system, converged = initial_condition_analysis(assembly, tspan[1];\n    prescribed_conditions = prescribed_conditions,\n    constant_mass_matrix = true,\n    structural_damping = false)\n\n# construct an ODEProblem (with a constant mass matrix)\node_prob = ODEProblem(ode_system, assembly, tspan, p;\n    constant_mass_matrix = true,\n    structural_damping = false)\n\n# solve the problem\node_sol = solve(ode_prob, Rodas4())\n\nnothing #hide","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"We can then extract the outputs from the solution in a easy to understand format using the AssemblyState constructor.","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"ode_history = [AssemblyState(ode_system, assembly, ode_sol[it]; prescribed_conditions)\n    for it in eachindex(ode_sol)]\n\ndae_history = [AssemblyState(dae_system, assembly, dae_sol[it]; prescribed_conditions)\n    for it in eachindex(dae_sol)]\n\nnothing #hide","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"Let's now compare the solutions from GXBeam's internal solver and the DifferentialEquations solvers.","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"using Plots\nusing Suppressor #hide\npyplot()\n\n@suppress_err begin #hide\n\npoint = vcat(fill(nelem+1, 6), fill(1, 6))\nfield = [:u, :u, :u, :theta, :theta, :theta, :F, :F, :F, :M, :M, :M]\ndirection = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\nylabel = [\"\\$u_x\\$ (\\$m\\$)\", \"\\$u_y\\$ (\\$m\\$)\", \"\\$u_z\\$ (\\$m\\$)\",\n    \"Rodriguez Parameter \\$\\\\theta_x\\$ (degree)\",\n    \"Rodriguez Parameter \\$\\\\theta_y\\$ (degree)\",\n    \"Rodriguez Parameter \\$\\\\theta_z\\$ (degree)\",\n    \"\\$F_x\\$ (\\$N\\$)\", \"\\$F_y\\$ (\\$N\\$)\", \"\\$F_z\\$ (\\$N\\$)\",\n    \"\\$M_x\\$ (\\$Nm\\$)\", \"\\$M_y\\$ (\\$Nm\\$)\", \"\\$M_z\\$ (\\$N\\$)\"]\n\nfor i = 1:12\n    #md local y #hide\n    plot(\n        xlim = (0, 2.0),\n        xticks = 0:0.5:2.0,\n        xlabel = \"Time (s)\",\n        ylabel = ylabel[i],\n        grid = false,\n        overwrite_figure=false\n        )\n    y_gxbeam = [getproperty(state.points[point[i]], field[i])[direction[i]]\n        for state in gxbeam_history]\n\n    y_ode = [getproperty(state.points[point[i]], field[i])[direction[i]]\n        for state in ode_history]\n\n    y_dae = [getproperty(state.points[point[i]], field[i])[direction[i]]\n        for state in dae_history]\n\n    if field[i] == :theta\n        # convert to Rodriguez parameter\n        @. y_gxbeam = 4*atan(y_gxbeam/4)\n        @. y_ode = 4*atan(y_ode/4)\n        @. y_dae = 4*atan(y_dae/4)\n        # convert to degrees\n        @. y_gxbeam = rad2deg(y_gxbeam)\n        @. y_ode = rad2deg(y_ode)\n        @. y_dae = rad2deg(y_dae)\n    end\n\n    if field[i] == :F || field[i] == :M\n        y_gxbeam = -y_gxbeam\n        y_ode = -y_ode\n        y_dae = -y_dae\n    end\n\n    plot!(t, y_gxbeam, label=\"GXBeam\")\n    plot!(ode_sol.t, y_ode, label=\"ODEProblem\")\n    plot!(dae_sol.t, y_dae, label=\"DAEProblem\")\n    plot!(show=true)\n    savefig(\"../assets/diffeq-\"*string(field[i])*string(direction[i])*\".svg\"); #hide\n    closeall() #hide\nend\n\nend #hide\nnothing #hide","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"As can be seen, the solutions provided by GXBeam and DifferentialEquations track closely with each other.","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"root_chord = 1.9000\ntip_chord =  0.4540\nairfoil = [ # MH-104\n    1.00000000  0.00000000;\n    0.99619582  0.00017047;\n    0.98515158  0.00100213;\n    0.96764209  0.00285474;\n    0.94421447  0.00556001;\n    0.91510964  0.00906779;\n    0.88074158  0.01357364;\n    0.84177999  0.01916802;\n    0.79894110  0.02580144;\n    0.75297076  0.03334313;\n    0.70461763  0.04158593;\n    0.65461515  0.05026338;\n    0.60366461  0.05906756;\n    0.55242353  0.06766426;\n    0.50149950  0.07571157;\n    0.45144530  0.08287416;\n    0.40276150  0.08882939;\n    0.35589801  0.09329359;\n    0.31131449  0.09592864;\n    0.26917194  0.09626763;\n    0.22927064  0.09424396;\n    0.19167283  0.09023579;\n    0.15672257  0.08451656;\n    0.12469599  0.07727756;\n    0.09585870  0.06875796;\n    0.07046974  0.05918984;\n    0.04874337  0.04880096;\n    0.03081405  0.03786904;\n    0.01681379  0.02676332;\n    0.00687971  0.01592385;\n    0.00143518  0.00647946;\n    0.00053606  0.00370956;\n    0.00006572  0.00112514;\n    0.00001249 -0.00046881;\n    0.00023032 -0.00191488;\n    0.00079945 -0.00329201;\n    0.00170287 -0.00470585;\n    0.00354717 -0.00688469;\n    0.00592084 -0.00912202;\n    0.01810144 -0.01720842;\n    0.03471169 -0.02488211;\n    0.05589286 -0.03226730;\n    0.08132751 -0.03908459;\n    0.11073805 -0.04503763;\n    0.14391397 -0.04986836;\n    0.18067874 -0.05338180;\n    0.22089879 -0.05551392;\n    0.26433734 -0.05636585;\n    0.31062190 -0.05605816;\n    0.35933893 -0.05472399;\n    0.40999990 -0.05254383;\n    0.46204424 -0.04969990;\n    0.51483073 -0.04637175;\n    0.56767889 -0.04264894;\n    0.61998250 -0.03859653;\n    0.67114514 -0.03433153;\n    0.72054815 -0.02996944;\n    0.76758733 -0.02560890;\n    0.81168064 -0.02134397;\n    0.85227225 -0.01726049;\n    0.88883823 -0.01343567;\n    0.92088961 -0.00993849;\n    0.94797259 -0.00679919;\n    0.96977487 -0.00402321;\n    0.98607009 -0.00180118;\n    0.99640466 -0.00044469;\n    1.00000000  0.00000000;\n]\n\nsections = zeros(3, size(airfoil, 1), length(points))\nfor ip = 1:length(points)\n    chord = root_chord * (1 - x[ip]/L) + tip_chord * x[ip]/L\n    sections[1, :, ip] .= 0\n    sections[2, :, ip] .= chord .* (airfoil[:,1] .- 0.5)\n    sections[3, :, ip] .= chord .* airfoil[:,2]\nend\n\nmkpath(\"dynamic-wind-turbine\")\nwrite_vtk(\"dynamic-wind-turbine/dynamic-wind-turbine\", assembly, gxbeam_history, t; sections = sections)\nrm(\"dynamic-wind-turbine\"; recursive=true) #hide","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"","category":"page"},{"location":"examples/diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/overdetermined.jl\"","category":"page"},{"location":"examples/overdetermined/#overdetermined","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"","category":"section"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"This example shows how to predict the behavior of a beam which is clamped at one end and simply supported at the other end when subjected to a linear distributed load.","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"(Image: )","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"tip: Tip\nThis example is also available as a Jupyter notebook: overdetermined.ipynb.","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"using GXBeam, LinearAlgebra\n\nnelem = 16\n\n# create points\nL = 1\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints for each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# create compliance matrix for each beam element\nEI = 1e7\ncompliance = fill(Diagonal([0, 0, 0, 0, 1/EI, 0]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# set prescribed conditions\nprescribed_conditions = Dict(\n    # simply supported left endpoint\n    1 => PrescribedConditions(uz=0),\n    # clamped right endpoint\n    nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0)\n)\n\n# create distributed load\nqmax = 1000\ndistributed_loads = Dict()\nfor i = 1:nelem\n    distributed_loads[i] = DistributedLoads(assembly, i; s1=x[i],\n        s2=x[i+1], fz = (s) -> qmax*s)\nend\n\n# perform a static analysis\nsystem, converged = static_analysis(assembly;\n    prescribed_conditions = prescribed_conditions,\n    distributed_loads = distributed_loads,\n    linear = true)\n\n# post-process the results\nstate = AssemblyState(system, assembly;\n    prescribed_conditions = prescribed_conditions)\nnothing #hide","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"An analytical solution to this over-determined problem can be found using the method of superposition using the analytical solutions to a cantilever with a linearly distributed load and a cantilever with an end load.","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"# construct analytical solution\nx_a = range(0.0, L, length=1000)\nw_a = @. qmax*(1-x_a)^2/(120*EI)*(4 - 8*(1-x_a) + 5*(1-x_a)^2 - (1-x_a)^3)\nslope_a = @. -qmax*(1-x_a)/(120*EI)*(8 - 24*(1-x_a) + 20*(1-x_a)^2 - 5*(1-x_a)^3)\nM_a = @. qmax/120*(8 - 48*(1-x_a) + 60*(1-x_a)^2 - 20*(1-x_a)^3)\n\ntheta_a = -atan.(slope_a)\n\n# adjust coordinate system of analytical solution\nM_a = -M_a\nnothing #hide","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"Plotting the results reveals that the analytical and computational solutions show excellent agreement.","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"using Plots\nusing Suppressor #hide\npyplot()\nnothing #hide","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"@suppress_err begin #hide\nlocal x #hide\n\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Linear Deflection (m)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint =\n    1:length(assembly.points)]\ndeflection = [state.points[ipoint].u[3] for ipoint = 1:length(assembly.points)]\nplot!(x_a, w_a, label=\"Analytical\")\nscatter!(x, deflection, label=\"GXBeam\")\nplot!(show=true)\nsavefig(\"../assets/overdetermined-linear-deflection.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"(Image: )","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"@suppress_err begin #hide\nlocal x #hide\n\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Angular Deflection (rad)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1]\n    for ipoint = 1:length(assembly.points)]\ntheta = [4*atan.(state.points[ipoint].theta[2]/4)\n    for ipoint = 1:length(assembly.points)]\nplot!(x_a, theta_a, label=\"Analytical\")\nscatter!(x, theta, label=\"GXBeam\")\nplot!(show=true)\nsavefig(\"../assets/overdetermined-angular-deflection.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"(Image: )","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"@suppress_err begin #hide\nlocal x #hide\n\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Bending Moment (\\$Nm\\$)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.elements[ielem].x[1] + state.elements[ielem].u[1] for ielem =\n    1:length(assembly.elements)]\nM = [state.elements[ielem].Mi[2] for ielem = 1:length(assembly.elements)]\nplot!(x_a, M_a, label=\"Analytical\")\nscatter!(x, M, label=\"GXBeam\")\nplot!(show=true)\nsavefig(\"../assets/overdetermined-bending-moment.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"(Image: )","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"Note that we could have easily performed a nonlinear analysis for this problem by setting linear=false.","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"","category":"page"},{"location":"examples/overdetermined/","page":"Overdetermined Beam","title":"Overdetermined Beam","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/excited/","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/excited.jl\"","category":"page"},{"location":"examples/excited/#excited","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"","category":"section"},{"location":"examples/excited/","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"This example shows how to simulate a simply supported beam with an excited second bending mode","category":"page"},{"location":"examples/excited/","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"(Image: )","category":"page"},{"location":"examples/excited/","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"tip: Tip\nThis example is also available as a Jupyter notebook: excited.ipynb.","category":"page"},{"location":"examples/excited/","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"using GXBeam, LinearAlgebra\n\n# simply-supported beam with excited second bending mode\n\n# beam properties\nL = 1\nEA = 1\nEI = 1\nρA = 1\n\n# generate points\nnelem = 40\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# define connectivity\nstart = 1:nelem\nstop = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([1e-6, 1e-6, 1e-6, 1e-6, 1/EI, 1e-6]), nelem)\n\n# mass matrix for each beam element\nmass = fill(Diagonal([ρA, ρA, ρA, 0.0, 0.0, 0.0]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop; compliance=compliance, mass=mass)\n\n# excite the second bending mode\ndelta = 1e-3 ## displacement magnitude\nuz = delta*sin.(2*pi*x/L) ## linear displacement\nu0 = [[0, 0, uz[i]] for i in eachindex(uz)]\n\n# prescribe the vertical displacement of each point\nprescribed_conditions = Dict(i => PrescribedConditions(uz = uz[i]) for i = 1:length(points))\n\n# simply supported left side\nprescribed_conditions[1] = PrescribedConditions(ux=0, uy=0, uz=0)\n\n# simply supported right side\nprescribed_conditions[nelem+1] = PrescribedConditions(uz=0)\n\n# solve for static operating conditions\nsystem, converged = static_analysis(assembly; prescribed_conditions)\n\n# postprocess results\nstate = AssemblyState(system, assembly; prescribed_conditions)\n\n# extract initial conditions from the state vector\nu0 = getproperty.(state.points, :u)\ntheta0 = getproperty.(state.points, :theta)\n\n# set new prescribed conditions\nprescribed_conditions = Dict(\n    # simply supported left side\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_z=0),\n    # simply supported right side\n    nelem+1 => PrescribedConditions(uz=0)\n)\n\n# excited mode natural frequency\nω = (2*pi/L)^2*sqrt((EI)/(ρA))\n\n# solution time vector\nt = range(0, 2*pi/ω, step=0.001)\n\n# perform time domain analysis\nsystem, history, converged = time_domain_analysis(assembly, t;\n    prescribed_conditions = prescribed_conditions,\n    initialize = true,\n    structural_damping = false,\n    u0=u0, theta0=theta0)\n\n# write visualization file\nmkpath(\"excited-simulation\")\nwrite_vtk(\"excited-simulation/excited-simulation\", assembly, history, t; scaling = 100)\nrm(\"excited-simulation\"; recursive=true) #hide","category":"page"},{"location":"examples/excited/","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"(Image: )","category":"page"},{"location":"examples/excited/","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"Plotting the results reveals that the analytical and computational solutions show excellent agreement.","category":"page"},{"location":"examples/excited/","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"# Get displacements at 1/4 of the beam's length\nipoint = div(nelem, 4) + 1\n\n# calculated deflection\nw14_gxbeam = [state.points[ipoint].u[3]/L for state in history]\n\n# analytic deflection\nw14_analytic = delta/L*cos.(ω*t)*sin(2*pi*x[ipoint]/L)\n\n# Plot\nusing Plots\npyplot()\nplot(\n    title=\"Deflection at x/L = $(x[ipoint]/L)\",\n    xlabel = \"Time (s)\",\n    ylabel = \"\\$w/L\\$\",\n    grid = false,\n    legend = :bottomleft,\n    overwrite_figure=false\n    )\nplot!(t, w14_analytic, label=\"Analytic\")\nplot!(t, w14_gxbeam, label=\"GXBeam\")\nplot!(show=true)\nsavefig(\"../assets/excited-deflection.svg\") #hide\ncloseall() #hide\nnothing #hide","category":"page"},{"location":"examples/excited/","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"(Image: )","category":"page"},{"location":"examples/excited/","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"","category":"page"},{"location":"examples/excited/","page":"Excited Second Bending Mode","title":"Excited Second Bending Mode","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/rotating.jl\"","category":"page"},{"location":"examples/rotating/#rotating","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"","category":"section"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"In this example we analyze a rotating beam with a swept tip.  The parameters for this example come from \"Finite element solution of nonlinear intrinsic equations for curved composite beams\" by Hodges, Shang, and Cesnik.","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"(Image: )","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"tip: Tip\nThis example is also available as a Jupyter notebook: rotating.ipynb.","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"using GXBeam, LinearAlgebra\n\nsweep = 45 * pi/180\nrpm = 0:25:750\n\n# straight section of the beam\nL_b1 = 31.5 ## inch\nr_b1 = [2.5, 0, 0]\nnelem_b1 = 13\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)\n\n# swept section of the beam\nL_b2 = 6 ## inch\nr_b2 = [34, 0, 0]\nnelem_b2 = 3\ncs, ss = cos(sweep), sin(sweep)\nframe_b2 = [cs ss 0; -ss cs 0; 0 0 1]\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2;\n    frame = frame_b2)\n\n# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2\npoints = vcat(xp_b1, xp_b2[2:end])\nstart = 1:nelem_b1 + nelem_b2\nstop = 2:nelem_b1 + nelem_b2 + 1\nlengths = vcat(lengths_b1, lengths_b2)\nmidpoints = vcat(xm_b1, xm_b2)\nCab = vcat(Cab_b1, Cab_b2)\n\n# cross section\nw = 1 ## inch\nh = 0.063 ## inch\n\n# material properties\nE = 1.06e7 ## lb/in^2\nν = 0.325\nρ = 2.51e-4 ## lb sec^2/in^4\n\n# shear and torsion correction factors\nky = 1.2000001839588001\nkz = 14.625127919304001\nkt = 65.85255016982444\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\n# apply corrections\nAy = A/ky\nAz = A/kz\nJx = J/kt\n\nG = E/(2*(1+ν))\n\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy),\n    1/(E*Izz)]), nelem)\n\nmass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop;\n    compliance = compliance,\n    mass = mass,\n    frames = Cab,\n    lengths = lengths,\n    midpoints = midpoints)\n\n# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # root section is fixed\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n    )\n\nnonlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nfor i = 1:length(rpm)\n    # global frame rotation\n    w0 = [0, 0, rpm[i]*(2*pi)/60]\n\n    # perform nonlinear steady state analysis\n    system, converged = steady_state_analysis(assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions)\n\n    nonlinear_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\n\n    # perform linear steady state analysis\n    system, converged = steady_state_analysis(assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions,\n        linear = true)\n\n    linear_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\nend\n\nnothing ##hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"To visualize the solutions we will plot the root moment and tip deflections against the angular speed.","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"using Plots\nusing Suppressor #hide\npyplot()\ncolors = get_color_palette(:auto, 17)\nnothing #hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"@suppress_err begin #hide\n\n# root moment\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    yticks = 0.0:2:12,\n    ylabel = \"\\$M_z\\$ at the root (lb-in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nMz_nl = [-nonlinear_states[i].points[1].M[3] for i = 1:length(rpm)]\nMz_l = [-linear_states[i].points[1].M[3] for i = 1:length(rpm)]\nplot!(rpm, Mz_nl, label=\"Nonlinear\")\nplot!(rpm, Mz_l, label=\"Linear\")\nplot!(show=true)\nsavefig(\"../assets/rotating-Mz.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"(Image: )","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"@suppress_err begin #hide\n\n# x tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.002, 0.074),\n    yticks = 0.0:0.01:0.07,\n    ylabel = \"\\$u_x\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nux_nl = [nonlinear_states[i].points[end].u[1] for i = 1:length(rpm)]\nux_l = [linear_states[i].points[end].u[1] for i = 1:length(rpm)]\nplot!(rpm, ux_nl, label=\"Nonlinear\")\nplot!(rpm, ux_l, label=\"Linear\")\nplot!(show=true)\nsavefig(\"../assets/rotating-ux.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"(Image: )","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"@suppress_err begin #hide\n\n# y tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.01, 0.27),\n    yticks = 0.0:0.05:0.25,\n    ylabel = \"\\$u_y\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nuy_nl = [nonlinear_states[i].points[end].u[2] for i = 1:length(rpm)]\nuy_l = [linear_states[i].points[end].u[2] for i = 1:length(rpm)]\nplot!(rpm, uy_nl, label=\"Nonlinear\")\nplot!(rpm, uy_l, label=\"Linear\")\nplot!(show=true)\nsavefig(\"../assets/rotating-uy.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"(Image: )","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"@suppress_err begin #hide\n\n# rotation of the tip\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylabel = \"\\$θ_z\\$ at the tip\",\n    grid = false,\n    overwrite_figure=false\n    )\ntheta_z_nl = [4*atan(nonlinear_states[i].points[end].theta[3]/4)\n    for i = 1:length(rpm)]\ntheta_z_l = [4*atan(linear_states[i].points[end].theta[3]/4)\n    for i = 1:length(rpm)]\n\nplot!(rpm, theta_z_nl, label=\"Nonlinear\")\nplot!(rpm, theta_z_l, label=\"Linear\")\n\nplot!(show=true)\nsavefig(\"../assets/rotating-theta_z.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"(Image: )","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"We will now compute the eigenvalues of this system for a range of sweep angles and and angular speeds.","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"sweep = (0:2.5:45) * pi/180\nrpm = [0, 500, 750]\nnev = 30\n\nλ = Matrix{Vector{ComplexF64}}(undef, length(sweep), length(rpm))\nU = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))\nV = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))\nstate = Matrix{AssemblyState{Float64}}(undef, length(sweep), length(rpm))\neigenstates = Matrix{Vector{AssemblyState{ComplexF64}}}(undef, length(sweep), length(rpm))\n\nfor i = 1:length(sweep)\n\n    local L_b1, r_b1, nelem_b1, lengths_b1\n    local xp_b1, xm_b1, Cab_b1\n    local cs, ss\n    local L_b2, r_b2, nelem_b2, frame_b2, lengths_b2\n    local xp_b2, xm_b2, Cab_b2\n    local nelem, points, start, stop\n    local lengths, midpoints, Cab, compliance, mass, assembly\n\n    # straight section of the beam\n    L_b1 = 31.5 # inch\n    r_b1 = [2.5, 0, 0]\n    nelem_b1 = 20\n    lengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)\n\n    # swept section of the beam\n    L_b2 = 6 # inch\n    r_b2 = [34, 0, 0]\n    nelem_b2 = 20\n    cs, ss = cos(sweep[i]), sin(sweep[i])\n    frame_b2 = [cs ss 0; -ss cs 0; 0 0 1]\n    lengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2;\n        frame = frame_b2)\n\n    # combine elements and points into one array\n    nelem = nelem_b1 + nelem_b2\n    points = vcat(xp_b1, xp_b2[2:end])\n    start = 1:nelem_b1 + nelem_b2\n    stop = 2:nelem_b1 + nelem_b2 + 1\n    lengths = vcat(lengths_b1, lengths_b2)\n    midpoints = vcat(xm_b1, xm_b2)\n    Cab = vcat(Cab_b1, Cab_b2)\n\n    compliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx),\n        1/(E*Iyy), 1/(E*Izz)]), nelem)\n\n    mass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)\n\n    # create assembly\n    assembly = Assembly(points, start, stop;\n        compliance = compliance,\n        mass = mass,\n        frames = Cab,\n        lengths = lengths,\n        midpoints = midpoints)\n\n    # create system\n    system = DynamicSystem(assembly)\n\n    for j = 1:length(rpm)\n\n        # global frame rotation\n        w0 = [0, 0, rpm[j]*(2*pi)/60]\n\n        # define previous left eigenvector matrix (used for correlating eigenmodes)\n        if i == 1 && j == 1\n            Uprev = nothing\n        elseif i == 1\n            Uprev = U[i,j-1]\n        else\n            Uprev = U[i-1,j]\n        end\n\n        # eigenvalues and eigenvectors\n        system, λ[i,j], U[i,j], V[i,j], converged = eigenvalue_analysis!(system, assembly;\n            angular_velocity = w0,\n            prescribed_conditions = prescribed_conditions,\n            nev = nev,\n            left = true,\n            Uprev = Uprev)\n\n        # post-process state variables\n        state[i,j] = AssemblyState(system, assembly; prescribed_conditions)\n\n        # post-process eigenvector state variables\n        eigenstates[i,j] = [\n            AssemblyState(system, assembly, V[i,j][:,k]; prescribed_conditions)\n            for k = 1:nev\n        ]\n    end\nend\n\n# extract frequencies\nfrequency = [\n    [imag(λ[i,j][k])/(2*pi) for i = 1:length(sweep), j=1:length(rpm)] for k = 1:2:nev\n    ]\n\nnothing #hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"Note that we correlated each eigenmode by taking advantage of the fact that left and right eigenvectors satisfy the following relationships:","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"beginaligned\nu^H M v = 1 textif (u) and (v) correspond to the same eigenmode \nu^H M v = 0 textif (u) and (v) correspond to different eigenmodes\nendaligned","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"In this case these eigenmode correlations work, but remember that large changes in the underlying parameters (or just drastic changes in the eigenvectors themselves due to a small perturbation) can cause these correlations to fail.","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"We'll now plot the frequency of the different eigenmodes against those found by Epps and Chandra in \"The Natural Frequencies of Rotating Composite Beams With Tip Sweep\".","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"@suppress_err begin #hide\n\n# index of first bending mode\nindex = 1\n\n# experimental data\nexperiment_sweep = [0, 15, 30, 45]\nexperiment_rpm = [0, 500, 750]\nexperiment_frequencies = [\n    1.4 10.2 14.8;\n    1.8 10.1 14.4;\n    1.7 10.2 14.9;\n    1.6 10.2 14.7;\n]\n\n# initialize plot\nplot(\n    xlabel = \"Sweep Angle (degrees)\",\n    xticks = 0:15:45,\n    xlim = (0, 45),\n    ylabel = \"Frequency (Hz)\",\n    yticks = 0:2.5:20.0,\n    ylim = (0, 20),\n    grid = false,\n    legend= :topright,\n    overwrite_figure=false,\n    )\n\n# initialize legend entries\nplot!([], [], color=:black, label=\"GXBeam\")\nscatter!([], [], color=:black, label = \"Experiment\")\n\n# plot frequency for each rotation rate\nfor j = 1:length(rpm)\n    # gxbeam\n    plot!(sweep*180/pi, frequency[index][:,j], label=\"\", color=colors[j])\n    # experimental\n    scatter!(experiment_sweep, experiment_frequencies[:,j], label=\"\", color=colors[j])\n    # annotation\n    iann = round(Int, 1/4*length(sweep))\n    xann = sweep[iann]*180/pi\n    yann = frequency[index][iann,j] + 1.5\n    annotate!(xann, yann, text(\"$(rpm[j]) RPM\", 8, :center, :bottom, colors[j]))\nend\nplot!(show=true)\nsavefig(\"../assets/rotating-frequencies-1.svg\");\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"(Image: )","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"@suppress_err begin #hide\n\n# index of second bending mode\nindex = 2\n\n# experimental data\nexperiment_sweep = [0, 15, 30, 45]\nexperiment_rpm = [0, 500, 750]\nexperiment_frequencies = [\n    10.3  25.2  36.1;\n    10.2  25.2  34.8;\n    10.4  23.7  30.7;\n    10.4  21.6  26.1;\n]\n\n# initialize plot\nplot(\n    xlabel = \"Sweep Angle (degrees)\",\n    xticks = 0:15:45,\n    xlim = (0, 45),\n    ylabel = \"Frequency (Hz)\",\n    yticks = 0:5:45,\n    ylim = (0, 45),\n    grid = false,\n    legend = :topright,\n    overwrite_figure=false\n    )\n\n# initialize legend entries\nplot!([], [], color=:black, label=\"GXBeam\")\nscatter!([], [], color=:black, label = \"Experiment\")\n\n# plot frequency for each rotation rate\nfor j = 1:length(rpm)\n    # gxbeam\n    plot!(sweep*180/pi, frequency[index][:,j], label=\"\", color=colors[j])\n    # experimental\n    scatter!(experiment_sweep, experiment_frequencies[:,j], label=\"\", color=colors[j])\n    # annotation\n    iann = round(Int, 1/4*length(sweep))\n    xann = sweep[iann]*180/pi\n    yann = frequency[index][iann,j] + 1.5\n    annotate!(xann, yann, text(\"$(rpm[j]) RPM\", \"Serif\", 8, :center, :bottom, colors[j]))\nend\nplot!(show=true)\nsavefig(\"../assets/rotating-frequencies-2.svg\");\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"(Image: )","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"@suppress_err begin #hide\n\n# index of third bending mode\nindex = 4\n\n# experimental data\nexperiment_sweep = [0, 15, 30, 45]\nexperiment_rpm = [0, 500, 750]\nexperiment_frequencies = [\n    27.7  47.0  62.9\n    27.2  44.4  55.9\n    26.6  39.3  48.6\n    24.8  35.1  44.8\n]\n\n# initialize plot\nplot(\n    xlabel = \"Sweep Angle (degrees)\",\n    xticks = 0:15:45,\n    xlim = (0, 45),\n    ylabel = \"Frequency (Hz)\",\n    yticks = 0:10:70.0,\n    ylim = (0, 70),\n    grid = false,\n    legend = :bottomright,\n    overwrite_figure=false\n    )\n\n# initialize legend entries\nplot!([], [], color=:black, label=\"GXBeam\")\nscatter!([], [], color=:black, label = \"Experiment\")\n\n# plot frequency for each rotation rate\nfor j = 1:length(rpm)\n    # gxbeam\n    plot!(sweep*180/pi, frequency[index][:,j], label=\"\", color=colors[j])\n    # experimental\n    scatter!(experiment_sweep, experiment_frequencies[:,j], label=\"\", color=colors[j])\n    # annotation\n    iann = round(Int, 1/4*length(sweep))\n    xann = sweep[iann]*180/pi\n    yann = frequency[index][iann,j] + 1.5\n    annotate!(xann, yann, text(\"$(rpm[j]) RPM\", \"Serif\", 8, :center, :bottom, colors[j]))\nend\nplot!(show=true)\nsavefig(\"../assets/rotating-frequencies-3.svg\"); #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"(Image: )","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"@suppress_err begin #hide\n\n# names and indices of modes\nnames = [\"1T/5B\", \"5B/1T\", \"4B/1T\"]\nindices = [5, 7, 6]\n\n# experimental data\nexperiment_sweep = [0, 15, 30, 45]\nexperiment_rpm = 750\nexperiment_frequencies = [\n    95.4  106.6  132.7;\n    87.5  120.1  147.3;\n    83.7  122.6  166.2;\n    78.8  117.7  162.0;\n]\n\n# initialize plot\nplot(\n    xlabel = \"Sweep Angle (degrees)\",\n    xticks = 0:15:45,\n    xlim = (0, 45),\n    ylabel = \"Frequency (Hz)\",\n    yticks = 0:20:180,\n    ylim = (0, 180),\n    grid = false,\n    legend = :bottomright,\n    overwrite_figure=false,\n    )\n\n# initialize legend entries\nplot!([], [], color=:black, label=\"GXBeam\")\nscatter!([], [], color=:black, label = \"Experiment\")\n\nfor k = 1:length(indices)\n    # gxbeam\n    plot!(sweep*180/pi, frequency[indices[k]][:,end]; label=\"\", color=colors[k])\n    # experimental\n    scatter!(experiment_sweep, experiment_frequencies[:,k]; label=\"\", color=colors[k])\n    # annotation\n    iann = round(Int, 1/4*length(sweep))\n    xann = sweep[iann]*180/pi\n    yann = frequency[indices[k]][iann,end] + 1.5\n    annotate!(xann, yann, text(\"$(names[k])\", \"Serif\", 8, :center, :bottom, colors[k]))\nend\nplot!(show=true)\nsavefig(\"../assets/rotating-frequencies-4.svg\");\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"(Image: )","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"As you can see, the frequency results from the eigenmode analysis in this package compare well with experimental results.","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"We can also visualize eigenmodes using ParaView.  Here we will visualize the first bending mode for the 45 degree swept tip at a rotational speed of 750 RPM.  This can be helpful for identifying different eigenmodes.","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"# write the response to vtk files for visualization using ParaView\nmkpath(\"rotating-eigenmode\")\nwrite_vtk(\"rotating-eigenmode/rotating-eigenmode\", assembly, state[end,end],\n    λ[end,end][1], eigenstates[end,end][1]; mode_scaling = 100.0)\nrm(\"rotating-eigenmode\"; recursive=true) #hide","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"(Image: )","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"","category":"page"},{"location":"examples/rotating/","page":"Rotating Beam with a Swept Tip","title":"Rotating Beam with a Swept Tip","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/guide.jl\"","category":"page"},{"location":"examples/guide/#guide","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"# this is placed here to pre-install matplotlib so the documentation doesn't get cluttered with the installation print statements.\nusing Plots\npyplot()","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"In this guide we introduce you to the basic functionality of this package in a step by step manner.  This is a good starting point for learning about how to use this package.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nThis guide is also available as a Jupyter notebook: guide.ipynb.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"If you haven't yet, now would be a good time to install GXBeam.  It can be installed from the Julia REPL by typing ] (to enter the package manager) and then running add GXBeam.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Now, that the package is installed we need to load it so that we can use it.  It's also often helpful to load the LinearAlgebra package.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"using GXBeam, LinearAlgebra\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"The geometry we will be working with is a rotating beam with a swept tip as pictured.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"This geometry has a fixed boundary condition on the left side of the beam and rotates around a point 2.5 inches to the left of the beam.  We will investigate the steady behavior of this system for a variety of rotation rates when the sweep angle is 45°.","category":"page"},{"location":"examples/guide/#Creating-an-Assembly","page":"Getting Started","title":"Creating an Assembly","text":"","category":"section"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"The first step for any analysis is to create an object of type Assembly.  This object stores the properties of each of the points and beam elements in our model.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"To create an object of type Assembly we need the following:","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"An array of points\nThe starting point for each beam element\nThe ending point for each beam element\nThe frame of reference for each beam element, specified as a 3x3 direction cosine matrix\nThe stiffness or compliance matrix for each beam element\nThe mass or inverse mass matrix for each beam element, for dynamic simulations\nThe element length and midpoint, if the element is curved","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"We will first focus on the geometry.  We start by defining the straight section of the beam.  This section extends from (2.5, 0, 0) to (34, 0, 0).  The local coordinate frame for this section of the beam is the same as the global coordinate frame.  We will discretize this section into 10 elements.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"To aid with constructing the geometry we can use the discretize_beam function. We pass in the length, starting point, and number of elements of the beam section to the discretize_beam function.  The function returns the lengths, endpoints, midpoints, and reference frame of each beam element.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"# straight section of the beam\nL_b1 = 31.5 # length of straight section of the beam in inches\nr_b1 = [2.5, 0, 0] # starting point of straight section of the beam\nnelem_b1 = 10 # number of elements in the straight section of the beam\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"The length of each beam element is equal since we used the number of elements to define the discretization.  For more control over the discretization we can pass in the discretization directly.  The following is an equally valid method for obtaining uniformly spaced beam elements.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"# normalized element endpoints in the straight section of the beam\ndisc_b1 = range(0, 1, length=nelem_b1+1)\n\n# discretize straight beam section\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, disc_b1)\n\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"We now create the geometry for the swept portion of the wing.  To do so we use the same discretize_beam function, but use the additional keyword argument frame in order to define the undeformed local beam frame.  The direction cosine matrix which describes the local beam frame is","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"beginbmatrix\ne_1x  e_2x  e_3x \ne_1y  e_2y  e_3y \ne_1z  e_2z  e_3z \nendbmatrix","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"where e_1, e_2, and e_3 are unit vectors which define the axes of the local frame of reference in the body frame of reference.  This matrix may be interpreted as a transformation matrix from the undeformed local beam frame to the body frame.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"sweep = 45 * pi/180\n\n# swept section of the beam\nL_b2 = 6 # length of swept section of the beam\nr_b2 = [34, 0, 0] # starting point of swept section of the beam\nnelem_b2 = 5 # number of elements in swept section of the beam\ne1 = [cos(sweep), -sin(sweep), 0] # axis 1\ne2 = [sin(sweep), cos(sweep), 0] # axis 2\ne3 = [0, 0, 1] # axis 3\nframe_b2 = hcat(e1, e2, e3) # transformation matrix from local to body frame\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2;\n    frame = frame_b2)\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"We will now manually combine the results of our two calls to discretize_beam.  Since the last endpoint from the straight section is the same as the first endpoint of the swept section we drop one of the endpoints when combining our results.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2 # total number of elements\npoints = vcat(xp_b1, xp_b2[2:end]) # all points in our assembly\nstart = 1:nelem_b1 + nelem_b2 # starting point of each beam element in our assembly\nstop = 2:nelem_b1 + nelem_b2 + 1 # ending point of each beam element in our assembly\nlengths = vcat(lengths_b1, lengths_b2) # length of each beam element in our assembly\nmidpoints = vcat(xm_b1, xm_b2) # midpoint of each beam element in our assembly\nCab = vcat(Cab_b1, Cab_b2) # transformation matrix from local to body frame\n                           # for each beam element in our assembly\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Next we need to define the stiffness (or compliance) and mass matrices for each beam element.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"The compliance matrix is defined by the following equation","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"beginbmatrix\ngamma_11 \n2gamma_12 \n2gamma_13 \nkappa_1 \nkappa_2 \nkappa_3\nendbmatrix\n=\nbeginbmatrix\n   S_11  S_12  S_13  S_14  S_15  S_16 \n   S_12  S_22  S_23  S_24  S_25  S_26 \n   S_13  S_23  S_33  S_34  S_35  S_36 \n   S_14  S_24  S_43  S_44  S_45  S_46 \n   S_15  S_25  S_35  S_45  S_55  S_56 \n   S_16  S_26  S_36  S_46  S_56  S_66\nendbmatrix\nbeginbmatrix\n   F_1 \n   F_2 \n   F_3 \n   M_1 \n   M_2 \n   M_3\nendbmatrix","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"with the variables defined as follows:","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"gamma_11: beam axial strain\n2gamma_12 engineering transverse strain along axis 2\n2gamma_13 engineering transverse strain along axis 3\nkappa_1: twist\nkappa_2: curvature about axis 2\nkappa_3: curvature about axis 3\nF_i: resultant force about axis i\nM_i: resultant moment about axis i","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"The mass matrix is defined using the following equation","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"beginbmatrix\n   P_1 \n   P_2 \n   P_3 \n   H_1 \n   H_2 \n   H_3\nendbmatrix\n=\nbeginbmatrix\n   mu  0  0  0  mu x_m3  -mu x_m2 \n   0  mu  0  -mu x_m3  0  0 \n   0  0  mu  mu x_m2  0  0 \n   0  -mu x_m3  mu x_m2  i_22 + i_33  0  0 \n   mu x_m3   0  0  0  i_22  -i_23 \n   -mu x_m2  0  0  0  -i_23  i_33\nendbmatrix\nbeginbmatrix\n   V_1 \n   V_2 \n   V_3 \n   Omega_1 \n   Omega_2 \n   Omega_3\nendbmatrix","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"with the variables defined as follows:","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"P: linear momentum per unit length\nH: angular momentum per unit length\nV: linear velocity\nOmega: angular velocity\nmu: mass per unit length\n(x_m2 x_m3): mass center location\ni_22: mass moment of inertia about axis 2\ni_33: mass moment of inertia about axis 3\ni_23: product of inertia","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"We assume that our beam has a constant cross section with the following properties:","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"1 inch width\n0.063 inch height\n1.06 x 10^7 lb/in^2 elastic modulus\n0.325 Poisson's ratio\n2.51 x 10^-4 lb sec^2/in^4 density","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"We also assume the following shear and torsion correction factors:","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"k_y = 12000001839588001\nk_z = 14625127919304001\nk_t = 6585255016982444","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"# cross section\nw = 1 # inch\nh = 0.063 # inch\n\n# material properties\nE = 1.06e7 # lb/in^2\nν = 0.325\nρ = 2.51e-4 # lb sec^2/in^4\n\n# shear and torsion correction factors\nky = 1.2000001839588001\nkz = 14.625127919304001\nkt = 65.85255016982444\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\n# apply corrections\nAy = A/ky\nAz = A/kz\nJx = J/kt\n\nG = E/(2*(1+ν))\n\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy),\n    1/(E*Izz)]), nelem)\n\nmass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Our case is simple enough that we can analytically calculate most values for the compliance and mass matrices, but this is not generally the case.  For more complex geometries/structures see the section of the documentation titled Computing Stiffness and Mass Matrices Also note that any row/column of the stiffness and/or compliance matrix which is zero will be interpreted as infinitely stiff in that degree of freedom.  This corresponds to a row/column of zeros in the compliance matrix.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"We are now ready to put together our assembly.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"assembly = Assembly(points, start, stop;\n   compliance = compliance,\n   mass = mass,\n   frames = Cab,\n   lengths = lengths,\n   midpoints = midpoints)\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"At this point this is probably a good time to check that the geometry of our assembly is correct.  We can do this by visualizing the geometry in ParaView.  We can use the write_vtk function to do this.  Note that in order to visualize the generated file yourself you will need to install ParaView separately.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"mkpath(\"rotating-geometry\")\nwrite_vtk(\"rotating-geometry/rotating-geometry\", assembly)\nrm(\"rotating-geometry\"; recursive=true) #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"examples/guide/#Point-Masses","page":"Getting Started","title":"Point Masses","text":"","category":"section"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"We won't be applying point masses to our model, but we will demonstrate how to do so.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Point masses are defined by using the constructor PointMass and may be attached to any point.  One instance of PointMass must be created for every point with attached point masses.  These instances of PointMass are then stored in a dictionary with keys corresponding to each point index.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Each PointMass contains a 6x6 mass matrix which describes the relationship between the linear/angular velocity of the point and the linear/angular momentum of the point mass.  For a single point mass, this matrix is defined as","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"beginbmatrix\n   P_x \n   P_y \n   P_z \n   H_x \n   H_y \n   H_z\nendbmatrix\n=\nbeginbmatrix\n   m  0  0  0  m p_z  -m p_y \n   0  m  0  -m p_z  0  m p_x \n   0  0  m  m p_y  -m p_x  0 \n   0  -m p_z  m p_y  I_xx^*  -I_xy^*  -I_xz^* \n   m p_z   0  -m p_x  -I_xy^*  I_yy^*  -I_yz^* \n   -m p_y  m p_x  0  -I_xz^*  -I_yz^*  I_zz^*\nendbmatrix\nbeginbmatrix\n   V_x \n   V_y \n   V_z \n   Omega_x \n   Omega_y \n   Omega_z\nendbmatrix","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"where m is the mass of the point mass, p is the position of the point mass relative to the point to which it is attached, and I^* is the inertia matrix corresponding to the point mass, defined relative to the point. Multiple point masses may be modeled by adding their respective mass matrices together.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Objects of type PointMass may be constructed by providing the fully populated mass matrix as described above or by providing the mass, offset, and inertia matrix of the point mass, with the later being the inertia matrix of the point mass about its center of gravity rather than the beam center.  To demonstrate, the following code places a 10 kg tip mass at the end of our swept beam.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"m = 10 # mass\np = zeros(3) # relative location\nJ = zeros(3,3) # inertia matrix (about the point mass center of gravity)\n\n# create dictionary of point masses\npoint_masses = Dict(\n    nelem+1 => PointMass(m, p, J)\n    )\n\nnothing #hide","category":"page"},{"location":"examples/guide/#Defining-Distributed-Loads","page":"Getting Started","title":"Defining Distributed Loads","text":"","category":"section"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"We won't be applying distributed loads to our model, but we will demonstrate how to do so.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Distributed loads are defined by using the constructor DistributedLoads.  One instance of DistributedLoads must be created for every beam element on which the distributed load is applied.  These instances of DistributedLoads are then stored in a dictionary with keys corresponding to each beam element index.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"To define a DistributedLoads the assembly, element number, and distributed load functions must be passed to DistributedLoads.  Possible distributed load functions are:","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"fx: Distributed x-direction force\nfy: Distributed y-direction force\nfz: Distributed z-direction force\nmx: Distributed x-direction moment\nmy: Distributed y-direction moment\nmz: Distributed z-direction moment\nfx_follower: Distributed x-direction follower force\nfy_follower: Distributed y-direction follower force\nfz_follower: Distributed z-direction follower force\nmx_follower: Distributed x-direction follower moment\nmy_follower: Distributed y-direction follower moment\nmz_follower: Distributed z-direction follower moment","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Each of these forces/moments are specified as functions of the arbitrary coordinate s. Thes-coordinate at the start and end of the beam element can be specified using the keyword argumentss1ands2`.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"For example, the following code applies a uniform 10 pound distributed load in the z-direction on all beam elements:","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"distributed_loads = Dict{Int64, DistributedLoads{Float64}}()\nfor ielem in 1:nelem\n    distributed_loads[ielem] = DistributedLoads(assembly, ielem; fz = (s) -> 10)\nend\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"To instead use a follower force (a force that rotates with the structure) we would use the following code:","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"distributed_loads = Dict{Int64, DistributedLoads{Float64}}()\nfor ielem in 1:nelem\n    distributed_loads[ielem] = DistributedLoads(assembly, ielem;\n        fz_follower = (s) -> 10)\nend\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"The units are arbitrary, but must be consistent with the units used when constructing the beam assembly.  Also note that both non-follower and follower forces may exist simultaneously.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Note that the distributed loads are integrated over each element when they are created using 4-point Gauss-Legendre quadrature.  If more control over the integration is desired one may specify a custom integration method as described in the documentation for DistributedLoads.","category":"page"},{"location":"examples/guide/#Defining-Prescribed-Conditions","page":"Getting Started","title":"Defining Prescribed Conditions","text":"","category":"section"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Whereas distributed loads are applied to beam elements, prescribed conditions are external loads or displacement boundary conditions applied to points. One instance of PrescribedConditions must be created for every point on which prescribed conditions are applied.  These instances of PrescribedConditions are then stored in a dictionary with keys corresponding to each point index.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Possible prescribed conditions include:","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"ux: Prescribed x-displacement\nuy: Prescribed y-displacement\nuz: Prescribed z-displacement\ntheta_x: Prescribed first Wiener-Milenkovic parameter\ntheta_y: Prescribed second Wiener-Milenkovic parameter\ntheta_z: Prescribed third Wiener-Milenkovic parameter\nFx: Prescribed x-direction force\nFy: Prescribed y-direction force\nFz: Prescribed z-direction force\nMx: Prescribed x-axis moment\nMy: Prescribed y-axis moment\nMz: Prescribed z-axis moment\nFx_follower: Prescribed x-direction follower force\nFy_follower: Prescribed y-direction follower force\nFz_follower: Prescribed z-direction follower force\nMx_follower: Prescribed x-direction follower moment\nMy_follower: Prescribed y-direction follower moment\nMz_follower: Prescribed z-direction follower moment","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"One can apply both force and displacement boundary conditions to the same point, but one cannot specify a force and displacement condition at the same point corresponding to the same degree of freedom.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Here we create a fixed boundary condition on the left side of the beam.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # root section is fixed\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n    )\n\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Note that most problems should have at least one point where deflections and/or rotations are constrained in order to be well-posed.","category":"page"},{"location":"examples/guide/#Pre-Allocating-Memory-for-an-Analysis","page":"Getting Started","title":"Pre-Allocating Memory for an Analysis","text":"","category":"section"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"At this point we have everything we need to perform an analysis.  However, since we will be performing multiple analyses using the same assembly we can save computational time be pre-allocating memory for the analysis.  This can be done by constructing an object of type AbstractSystem.  There are two main options: StaticSystem for static systems and DynamicSystem for dynamic systems.  The third option: ExpandedSystem is primarily useful when constructing a constant mass matrix system for use with DifferentialEquations Since our system is rotating, we construct an object of type DynamicSystem.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"system = DynamicSystem(assembly)\nnothing #hide","category":"page"},{"location":"examples/guide/#Performing-a-Steady-State-Analysis","page":"Getting Started","title":"Performing a Steady State Analysis","text":"","category":"section"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"We're now ready to perform our steady state analyses.  This can be done by calling steady_state_analysis! with the pre-allocated system storage, assembly, angular velocity, and the prescribed point conditions.  A linear analysis may be performed instead of a nonlinear analysis by using the linear keyword argument.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"After each analysis we'll also construct an object of type AssemblyState so that we can save the results of each analysis prior to re-using the pre-allocated memory for the next analysis.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"rpm = 0:25:750\n\nlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nfor i = 1:length(rpm)\n\n    # global frame rotation\n    w0 = [0, 0, rpm[i]*(2*pi)/60]\n\n    # perform linear steady state analysis\n    _, converged = steady_state_analysis!(system, assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions,\n        linear = true)\n\n    linear_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions=prescribed_conditions)\n\nend\n\nreset_state!(system)\n\nnonlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nfor i = 1:length(rpm)\n\n   # global frame rotation\n   w0 = [0, 0, rpm[i]*(2*pi)/60]\n\n    # perform nonlinear steady state analysis\n    _, converged = steady_state_analysis!(system, assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions)\n\n     nonlinear_states[i] = AssemblyState(system, assembly;\n         prescribed_conditions=prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/guide/#Post-Processing-Results","page":"Getting Started","title":"Post Processing Results","text":"","category":"section"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"We can access the fields in each instance of AssemblyState in order to plot various quantities of interest.  This object stores an array of objects of type PointState in the field points and an array of objects of type ElementState in the field elements.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"The fields of PointState are the following:","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"u: point linear displacement (in the global frame)\ntheta: point angular displacement (in the global frame)\nF: externally applied forces on the point (in the global frame)\nM: externally applied moments on the point (in the global frame)\nV: linear velocity (in the global frame)\nOmega: angular velocity (in the global frame)","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"The fields of ElementState are the following:","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"u: element displacement (in the global frame )\ntheta: angular displacement (in the global frame)\nF: resultant forces (in the local element frame)\nM: resultant moments (in the local element frame)\nV: linear velocity (in the global frame)\nOmega: angular velocity (in the global frame)","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Angular displacements are expressed in terms of Wiener-Milenkovic parameters.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"To demonstrate how these fields can be accessed we will now plot the root moment and tip deflections.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"using Plots\nusing Suppressor #hide\npyplot()\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"@suppress_err begin #hide\n\n# root moment\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    yticks = 0.0:2:12,\n    ylabel = \"\\$M_z\\$ at the root (lb-in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nMz_nl = [-nonlinear_states[i].points[1].M[3] for i = 1:length(rpm)]\nMz_l = [-linear_states[i].points[1].M[3] for i = 1:length(rpm)]\nplot!(rpm, Mz_nl, label=\"Nonlinear\")\nplot!(rpm, Mz_l, label=\"Linear\")\nplot!(show=true)\nsavefig(\"../assets/guide-Mz.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"@suppress_err begin #hide\n\n# x tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.002, 0.074),\n    yticks = 0.0:0.01:0.07,\n    ylabel = \"\\$u_x\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nux_nl = [nonlinear_states[i].points[end].u[1] for i = 1:length(rpm)]\nux_l = [linear_states[i].points[end].u[1] for i = 1:length(rpm)]\nplot!(rpm, ux_nl, label=\"Nonlinear\")\nplot!(rpm, ux_l, label=\"Linear\")\nplot!(show=true)\nsavefig(\"../assets/guide-ux.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"@suppress_err begin #hide\n\n# y tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.01, 0.27),\n    yticks = 0.0:0.05:0.25,\n    ylabel = \"\\$u_y\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nuy_nl = [nonlinear_states[i].points[end].u[2] for i = 1:length(rpm)]\nuy_l = [linear_states[i].points[end].u[2] for i = 1:length(rpm)]\nplot!(rpm, uy_nl, label=\"Nonlinear\")\nplot!(rpm, uy_l, label=\"Linear\")\nplot!(show=true)\nsavefig(\"../assets/guide-uy.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"@suppress_err begin #hide\n\n# rotation of the tip\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylabel = \"\\$θ_z\\$ at the tip\",\n    grid = false,\n    overwrite_figure=false\n    )\ntheta_z_nl = [4*atan(nonlinear_states[i].points[end].theta[3]/4)\n    for i = 1:length(rpm)]\ntheta_z_l = [4*atan(linear_states[i].points[end].theta[3]/4)\n    for i = 1:length(rpm)]\n\nplot!(rpm, theta_z_nl, label=\"Nonlinear\")\nplot!(rpm, theta_z_l, label=\"Linear\")\nplot!(show=true)\nsavefig(\"../assets/guide-theta_z.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"examples/guide/#Other-Capabilities","page":"Getting Started","title":"Other Capabilities","text":"","category":"section"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"Further information about how to use this package may be obtained by looking through the examples or browsing the Public API.","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"examples/guide/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/section.jl\"","category":"page"},{"location":"examples/section/#section","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness/Mass Matrices and Strain Recovery","text":"","category":"section"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"Cross section stiffness and inertial properties are provided as direct inputs for most of the examples in this package.  In general, however, we need to compute these section properties from input geometry and material properties.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"We implemented the 2D finite element procedure described by Giavotto et al. and that is also described in the BECAS User Guide. This approach is much more accurate than those based on classical laminate theory, especially for coupled and transverse stiffnesses, and of course is much more accurate for thicker sections. Our implementation uses bilinear quadrilateral (Q4) elements, and is tailored for use in design optimization.  First, the implementation is fast.  The memory for all large matrices is preallocated, in sparse formats where applicable.  This allows operations to be done in place for subsequent iterations within an optimization. We also save the matrix factorization in the linear solve and use sparse solvers.   Second, meshes are carefully resized to avoid discrete jumps in properties as airfoil/thickness dimensions change.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"There are two main ways to compute section properties using this package.  The first is from explicit creation of a mesh, i.e., nodes and elements. This is the most general approach, and can be used for any shape. However, as our primary usage is for airfoils, we have a second convenience function that generates the nodes and elements for a parameterized airfoil.  This approach does not require understanding the format of nodes and elements, but rather the specificiations for the paramterized airfoil.  Other convenience functions could be created for other common geometries.  These two different approaches are explained below, but before describing them we note the material definition as that is needed in both methods.","category":"page"},{"location":"examples/section/#Material-Properties","page":"Computing Stiffness and Mass Matrices","title":"Material Properties","text":"","category":"section"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"We can specify a general orthotropic Material with three independent Young's moduli, shear moduli, Poisson's ratios, and the material density.  E_i is the Young's modulus along axis i, G_ij is the shear modulus in direction j on the plane whose normal is in direction i, and nu_ij is the Poisson’s ratio that corresponds to a contraction in direction j when an extension is applied in direction i (from symmetry the opposite definitions would also apply, where we swap i and j). Also from symmetry we know that nu_ij E_j = nu_ji E_i.  For example:","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"using GXBeam\n\nE1 = 10e9\nE2 = 5e9\nE3 = 5e9\nG12 = 8e9\nG13 = 4e9\nG23 = 4e9\nnu12 = 0.3\nnu13 = 0.3\nnu23 = 0.3\nrho = 1.8e3\n\nmat = Material(E1, E2, E3, G12, G13, G23, nu12, nu13, nu23, rho)\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"The ply, element, and beam coordinate systems are shown below.  Axis 1 is along the ply main fiber direction, 2 is the transverse direction, and 3 is normal to the ply. For a wing/blade 1 is nominally along the span/radius, 2 is tangent to airfoil, and 3 is normal to airfoil (these are nominal as they would only be exact if the fiber orientation, theta, is 0 degrees).","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"(Image: )","category":"page"},{"location":"examples/section/#Nodes-and-Elements","page":"Computing Stiffness and Mass Matrices","title":"Nodes and Elements","text":"","category":"section"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"The structure is discretized into nodes.  A Node is a point given by an x, y coordinate pair.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"x = 0.0\ny = 0.0\nnode = Node(x, y)\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"Of course, a structure has many nodes, and these should be assembled in a vector of nodes.  The node number is given by the vector index.  In this example we create four nodes in the shape of a square from which we can later construct an element.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"x = 0.0\ny = 0.0\nnode1 = Node(x, y)\nx = 1.0\ny = 0.0\nnode2 = Node(x, y)\nx = 1.0\ny = 1.0\nnode3 = Node(x, y)\nx = 0.0\ny = 1.0\nnode4 = Node(x, y)\n\nnodes = [node1; node2; node3; node4]\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"The structure is constructed with elements.  Each MeshElement is made of four nodes, ordered as shown below Each element also has a material, and that material has a fiber orientation theta (see previous figure).","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"(Image: )","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"nodenumbers = [1, 2, 3, 4]\nmaterial = mat\ntheta = 20*pi/180\nelement = MeshElement(nodenumbers, material, theta)\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"A mesh would then consist of an array of nodes and an array of elements. As an example we construct a mesh for the square cross section with isotropic material shown in the BECAS User Guide (which is just a square of side length 0.1).  We discretize the square into 100 equally-sized elements, 10 in each dimension.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"iso = Material(100.0, 100.0, 100.0, 41.667, 41.667, 41.667, 0.2, 0.2, 0.2, 1000.0)\nx = range(-0.05, 0.05, length=11)\ny = range(-0.05, 0.05, length=11)\n\nnodes = Vector{Node{Float64}}(undef, 11*11)\nelements = Vector{MeshElement{Vector{Int64},Float64}}(undef, 10*10)\n\nlet\n    m = 1\n    for i = 1:11\n        for j = 1:11\n            nodes[m] = Node(x[i], y[j])\n            m += 1\n        end\n    end\n\n    m = 1\n    for i = 1:10\n        for j = 1:10\n            elements[m] = MeshElement([11*(i-1)+j, 11*(i)+j, 11*(i)+j+1, 11*(i-1)+j+1], iso, 0.0)\n            m += 1\n        end\n    end\nend\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"With the mesh constructed we can now compute the compliance matrix.  The compliance_matrix is computed about the shear center.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"S, sc, tc = compliance_matrix(nodes, elements)\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"S is the compliance matrix, sc is the x and y coordinates for the shear center, and tc is the x and y coordinates for the tension center.  These coordinates are relative to the origin (0, 0) of the mesh.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"Inertial properties can be computed from the mass_matrix function:","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"M, mc = mass_matrix(nodes, elements)\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"where M is the mass matrix and mc is the x and y coordinates for the mass center.","category":"page"},{"location":"examples/section/#Airfoil-Shape","page":"Computing Stiffness and Mass Matrices","title":"Airfoil Shape","text":"","category":"section"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"The airfoil outer mold line is defined by a set of x, y coordinates, normalized by chord. The points must start at the trailing edge, traverse counterclockwise (i.e., upper surface first), and end at the trailing edge as shown below. The trailing edge can be blunt or sharp. For the former the trailing edge would start and end at different points, and in the later they would be the same point.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"(Image: )","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"In this example we will use ST1 for the MH-104 airfoil described in the paper by Chen, Yu, and Capellaro.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"xaf = [1.00000000, 0.99619582, 0.98515158, 0.96764209, 0.94421447, 0.91510964, 0.88074158, 0.84177999, 0.79894110, 0.75297076, 0.70461763, 0.65461515, 0.60366461, 0.55242353, 0.50149950, 0.45144530, 0.40276150, 0.35589801, 0.31131449, 0.26917194, 0.22927064, 0.19167283, 0.15672257, 0.12469599, 0.09585870, 0.07046974, 0.04874337, 0.03081405, 0.01681379, 0.00687971, 0.00143518, 0.00053606, 0.00006572, 0.00001249, 0.00023032, 0.00079945, 0.00170287, 0.00354717, 0.00592084, 0.01810144, 0.03471169, 0.05589286, 0.08132751, 0.11073805, 0.14391397, 0.18067874, 0.22089879, 0.26433734, 0.31062190, 0.35933893, 0.40999990, 0.46204424, 0.51483073, 0.56767889, 0.61998250, 0.67114514, 0.72054815, 0.76758733, 0.81168064, 0.85227225, 0.88883823, 0.92088961, 0.94797259, 0.96977487, 0.98607009, 0.99640466, 1.00000000]\nyaf = [0.00000000, 0.00017047, 0.00100213, 0.00285474, 0.00556001, 0.00906779, 0.01357364, 0.01916802, 0.02580144, 0.03334313, 0.04158593, 0.05026338, 0.05906756, 0.06766426, 0.07571157, 0.08287416, 0.08882939, 0.09329359, 0.09592864, 0.09626763, 0.09424396, 0.09023579, 0.08451656, 0.07727756, 0.06875796, 0.05918984, 0.04880096, 0.03786904, 0.02676332, 0.01592385, 0.00647946, 0.00370956, 0.00112514, -0.00046881, -0.00191488, -0.00329201, -0.00470585, -0.00688469, -0.00912202, -0.01720842, -0.02488211, -0.03226730, -0.03908459, -0.04503763, -0.04986836, -0.05338180, -0.05551392, -0.05636585, -0.05605816, -0.05472399, -0.05254383, -0.04969990, -0.04637175, -0.04264894, -0.03859653, -0.03433153, -0.02996944, -0.02560890, -0.02134397, -0.01726049, -0.01343567, -0.00993849, -0.00679919, -0.00402321, -0.00180118, -0.00044469, 0.00000000]\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"Next, we define the chord length, the twist angle, and the pitch axis.  The pitch axis is the x-coordinate, measured back from the leading edge, normalized by chord, that defines where the airfoil should be twisted about as seen in the figure below. So a pitch axis of 0.25 means that the airfoil rotates about the quarter chord.  Positive twist is in the direction of increasing angle of attack. In our case the twist is zero so the pitch axis is irrelevant though we use the value noted in the paper.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"(Image: )","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"chord = 1.9\ntwist = 0.0*pi/180\npaxis = 0.4750 / chord\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"We now define the materials we will use in our layup.  There are five materials in this case, and for convenience we put them in an array so we can refer to them by number.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"uni = Material(37.00e9, 9.00e9, 9.00e9, 4.00e9, 4.00e9, 4.00e9, 0.28, 0.28, 0.28, 1.86e3)\ndouble = Material(10.30e9, 10.30e9, 10.30e9, 8.00e9, 8.00e9, 8.00e9, 0.30, 0.30, 0.30, 1.83e3)\ngelcoat = Material(1e1, 1e1, 1e1, 1.0, 1.0, 1.0, 0.30, 0.30, 0.30, 1.83e3)\nnexus = Material(10.30e9, 10.30e9, 10.30e9, 8.00e9, 8.00e9, 8.00e9, 0.30, 0.30, 0.30, 1.664e3)\nbalsa = Material(0.01e9, 0.01e9, 0.01e9, 2e5, 2e5, 2e5, 0.30, 0.30, 0.30, 0.128e3)\nmat = [uni, double, gelcoat, nexus, balsa]\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"The heart of the parmeterization is defining the ply sequence.  A single ply (or multiple plys of the same material and orientation) is given by a Layer.  A Layer is defined by a material, a thickness, and a fiber orientation. Thicknesses are absolute (not normalized), and orientation angles should be in radians.  For example:","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"t = 0.001\ntheta = 20*pi/180\nlayer = Layer(balsa, t, theta)\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"A given segment on the airfoil will have multiple layers, which defines the ply sequencing at that section (see figure below). (Image: ) For example the first segment of this airfoil uses three materials: a gelcoat followed by nexus then the double-bias FRP.  Note that the sequencing always starts from the outer edge of the airfoil.  Recall that we placed our materials in an array so we can refer to them by number.  We then use broadcasting to create a vector of these three layers.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"idx = [3, 4, 2]  # material index\nt = [0.000381, 0.00051, 18*0.00053]\ntheta = [0, 0, 20]*pi/180\nlayup1 = Layer.(mat[idx], t, theta)\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"This particular airfoil is made up of four separate segments, so we now define the next three using the specifications from the document.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"idx = [3, 4, 2]\nt = [0.000381, 0.00051, 33*0.00053]\ntheta = [0, 0, 20]*pi/180\nlayup2 = Layer.(mat[idx], t, theta)\n\nidx = [3, 4, 2, 1, 5, 1, 2]\nt = [0.000381, 0.00051, 17*0.00053, 38*0.00053, 1*0.003125, 37*0.00053, 16*0.00053]\ntheta = [0, 0, 20, 30, 0, 30, 20]*pi/180\nlayup3 = Layer.(mat[idx], t, theta)\n\nidx = [3, 4, 2, 5, 2]\nt = [0.000381, 0.00051, 17*0.00053, 0.003125, 16*0.00053]\ntheta = [0, 0, 20, 0, 0]*pi/180\nlayup4 = Layer.(mat[idx], t, theta)\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"These four layups correspond four different regions of the airfoil.  We concatenate them into a vector called segments.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"segments = [layup1, layup2, layup3, layup4]\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"We need to define over what region each layup corresponds to.  We do this by providing the normalized x locations as breakpoints.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"xbreak = [0.0, 0.0041, 0.1147, 0.5366, 1.0]\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"The above means that layup 1 applies from x/c = 0 to 0.0041, layup 2 from x/c = 0.0041 to 0.1147, and so on.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"Shear webs are defined in the same way as segments. Each web has a stack of layers, and the airfoil can have as many webs as desired.  In our case, we have two webs, both with the same ply stack.  The ordering if from the leading edge side towards the trailing edge, although usually the web layups are symmetric anyway.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"idx = [1, 5, 1]\nt = [38*0.00053, 0.003125, 38*0.00053]\ntheta = [0, 0, 0]*pi/180\nweb = Layer.(mat[idx], t, theta)\n\nwebs = [web, web]\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"We also need to define the normalized x location of each web center.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"webloc = [0.15, 0.5]\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"Thus, our first web is at x/c = 0.15, the second at x/c = 0.5.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"We now have all the information we need to create the structural mesh using the afmesh function.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"nodes, elements = afmesh(xaf, yaf, chord, twist, paxis, xbreak, webloc, segments, webs)\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"We can now compute compliance_matrix and inertial matices (mass_matrix) in the same manner as shown in the prior section.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"S, sc, tc = compliance_matrix(nodes, elements)\nM, mc = mass_matrix(nodes, elements)\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"For optimization usage, one should also initialize the cache upfront (see initialize_cache). Then re-use that cache for subsequent calls to compliance_matrix.  That wiill avoid recreating the cache at each iteration and will speed up computation. The cache does not needed to be re-initialized as long as the matrix sizes stay constant (the geometry can change sizes, but the overall mesh connectivity remains the same, which should be the case during gradient-based design optimization) If passing derivatives through with ForwardDiff make sure to set the d parameter of initialize_cache, which is the number of design variables.  See the sectionwrapper function in the unit tests for section.jl for an example.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"cache = initialize_cache(nodes, elements)\nS, sc, tc = compliance_matrix(nodes, elements, cache=cache)  # these calls are now much faster\nS, sc, tc = compliance_matrix(nodes, elements, cache=cache)\nnothing #hide","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"For visualizing the mesh there is a provided helper function plotmesh. It uses PyPlot, although that must be loaded on the user-side and passed in as it is not a dependency in the package.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"using PyPlot\nfigure(); plotmesh(nodes, elements, PyPlot)","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"(Image: )","category":"page"},{"location":"examples/section/#Airfoil-Mesh-Control","page":"Computing Stiffness and Mass Matrices","title":"Airfoil Mesh Control","text":"","category":"section"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"A few additional parameters are available to control the airfoil meshing.  By default the mesh is discretized in the tangential direction using the airfoil coordinates. In other words, to get a finer mesh in this direction we could specify more airfoil points.  By default the mesh in the normal direction uses the layers defined by the segments.  Since we use the same number of elements for each segment, we subdivide some layers as needed (and thus the segment with the most layers defines the number of elements).  In our above example the the third segment has the most layers (7) so we discretize the mesh with 7 elements in the tangential direction for all segments.  To get a finer mesh in this direction we could breakup a segment into more layers (for example a layer of material 1 of 0.1 thickness could be divided into four layers of material 1 with 0.025 thickness).","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"However, doing this remeshing manually is a bit tedious so there are functions that can automate this. First, there are two optional parameters that control the desired spacing in the tangential and normal directions.  The first is \"ds\", which if provided, will resample the airfoil with approximately this spacing, normalized by chord.  For example, ds=0.01 will create points on the airfoil spaced roughly 1% chord apart. Siimilarly, there is an optional parameter \"dt\", which resamples the thicknesses with this maximium mesh size (thickness is absolute). For example, dt=0.01, will target a maximum element thickness of 0.01. Recall that the total number of elements remains constant along the airfoil, so most thicknesses will less than this value. This same parameter is used for discretizing along the thickness of the webs.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"These two parameters are simple to use, but are typically not desirable for gradient-based optimization if ply thicknesses or airfoil coordinates are changed.  This is because a fixed element size will experience discrete jumps as the airfoil is resized.  Thus, rather than specify a fixed element size, we should specify a fixed number of elements.  The optional parameters ns and nt provide this functionality.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"The parameter ns is an array specifying the number of elements to create in each segment.  In our case we have four different segments so we could define an array like: ns = [15, 20, 40, 30].  This is less convenient as it is not as immediately obvious how many elements should to put in each sector in order to provide a consistently spaced mesh.  However, as the airfoil shape changes, the mesh will simply stretch/shrink and never experience discrete jumps.  Similarly, we can specify nt to define the number of elements to use across the thickness.  The parameter nt is actually an array of arrays.  Each subaray defines how many elements should be used for each layer.  For example nt = [[1, 1, 5], [1, 1, 5], [1, 1, 1, 1, 1, 1, 1], [1, 1, 2, 1, 2]] would subdivide the innermost layer of the first segment into 5 elements, and so on.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"Finally, for discretizing along the webs we can use wns and wnt.  The parmeter wns is an integer and specifies the number of elements to use along the height of the web (same definition as ns but a web only needs one number). The default is four. The parameters wnt has the same definition as nt but applies to the webs.","category":"page"},{"location":"examples/section/#Strain-Recovery","page":"Computing Stiffness and Mass Matrices","title":"Strain Recovery","text":"","category":"section"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"After the beam solution is complete, we can map the forces and moments back into stresses and strains in the input mesh.  This allows us to compute strains and stresses within each ply and is much more accurate than smeared approaches that are commonly used with classical laminate theory.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"For this example we will use the same airfoil/layup as the previous section except with different values so we can compare to the study published in the MS Thesis: \"Loss of accuracy using smeared properties in composite beam modeling\" by Ning Liu, Purdue University.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"xaf = [1.00000000, 0.99619582, 0.98515158, 0.96764209, 0.94421447, 0.91510964, 0.88074158, 0.84177999, 0.79894110, 0.75297076, 0.70461763, 0.65461515, 0.60366461, 0.55242353, 0.50149950, 0.45144530, 0.40276150, 0.35589801, 0.31131449, 0.26917194, 0.22927064, 0.19167283, 0.15672257, 0.12469599, 0.09585870, 0.07046974, 0.04874337, 0.03081405, 0.01681379, 0.00687971, 0.00143518, 0.00053606, 0.00006572, 0.00001249, 0.00023032, 0.00079945, 0.00170287, 0.00354717, 0.00592084, 0.01810144, 0.03471169, 0.05589286, 0.08132751, 0.11073805, 0.14391397, 0.18067874, 0.22089879, 0.26433734, 0.31062190, 0.35933893, 0.40999990, 0.46204424, 0.51483073, 0.56767889, 0.61998250, 0.67114514, 0.72054815, 0.76758733, 0.81168064, 0.85227225, 0.88883823, 0.92088961, 0.94797259, 0.96977487, 0.98607009, 0.99640466, 1.00000000]\nyaf = [0.00000000, 0.00017047, 0.00100213, 0.00285474, 0.00556001, 0.00906779, 0.01357364, 0.01916802, 0.02580144, 0.03334313, 0.04158593, 0.05026338, 0.05906756, 0.06766426, 0.07571157, 0.08287416, 0.08882939, 0.09329359, 0.09592864, 0.09626763, 0.09424396, 0.09023579, 0.08451656, 0.07727756, 0.06875796, 0.05918984, 0.04880096, 0.03786904, 0.02676332, 0.01592385, 0.00647946, 0.00370956, 0.00112514, -0.00046881, -0.00191488, -0.00329201, -0.00470585, -0.00688469, -0.00912202, -0.01720842, -0.02488211, -0.03226730, -0.03908459, -0.04503763, -0.04986836, -0.05338180, -0.05551392, -0.05636585, -0.05605816, -0.05472399, -0.05254383, -0.04969990, -0.04637175, -0.04264894, -0.03859653, -0.03433153, -0.02996944, -0.02560890, -0.02134397, -0.01726049, -0.01343567, -0.00993849, -0.00679919, -0.00402321, -0.00180118, -0.00044469, 0.00000000]\n\nuni = Material(5.3664e6, 1.3053e6, 1.3053e6, 5.8015e5, 5.8015e5, 5.8015e5, 0.28, 0.28, 0.28, 1.740449e-4)\ndouble = Material(1.4939e6, 1.4939e6, 1.4939e6, 1.1603e6, 1.1603e6, 1.1603e6, 0.30, 0.30, 0.30, 1.712378e-4)\ngelcoat = Material(1.4504e-3, 1.4504e-3, 1.4504e-3, 1.4504e-4, 1.4504e-4, 1.4504e-4, 0.30, 0.30, 0.30, 1.712378e-4)\nnexus = Material(1.4939e6, 1.4939e6, 1.4939e6, 1.1603e6, 1.1603e6, 1.1603e6, 0.30, 0.30, 0.30, 1.557047e-4)\nbalsa = Material(1.4504e3, 1.4504e3, 1.4504e3, 2.9008e1, 2.9008e1, 2.9008e1, 0.30, 0.30, 0.30, 1.197729e-5)\nmat = [uni, double, gelcoat, nexus, balsa]\n\nchord = 74.8031\ntwist = 0.0*pi/180\npaxis = 19.72747356 / chord\nxbreak = [0.0, 0.0041, 0.1147, 0.5366, 1.0]\nwebloc = [0.15 0.5]\n\nidx = [3, 4, 2]\nt = [0.015, 0.02007874, 18*0.020866142]\ntheta = [0, 0, 20]*pi/180\nlayup1 = Layer.(mat[idx], t, theta)\nidx = [3, 4, 2]\nt = [0.015, 0.02007874, 33*0.020866142]\ntheta = [0, 0, 20]*pi/180\nlayup2 = Layer.(mat[idx], t, theta)\nidx = [3, 4, 2, 1, 5, 1, 2]\nt = [0.015, 0.02007874, 17*0.020866142, 38*0.020866142, 1*0.123031496, 37*0.020866142, 16*0.020866142]\ntheta = [0, 0, 20, 30, 0, 30, 20]*pi/180\nlayup3 = Layer.(mat[idx], t, theta)\nidx = [3, 4, 2, 5, 2]\nt = [0.015, 0.02007874, 17*0.020866142, 0.123031496, 16*0.020866142]\ntheta = [0, 0, 20, 0, 0]*pi/180\nlayup4 = Layer.(mat[idx], t, theta)\n\nidx = [1, 5, 1]\nt = [38*0.020866142, 2*0.061515748, 38*0.020866142]\ntheta = [0, 0, 0]*pi/180\nweb = Layer.(mat[idx], t, theta)\n\nsegments = [layup1, layup2, layup3, layup4]\nwebs = [web, web]\n\nnodes, elements = afmesh(xaf, yaf, chord, twist, paxis, xbreak, webloc, segments, webs, ds=0.01, dt=0.2, wns=20)","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"We need to initialize (and save) the cache as we will need to reuse values computed in the solution of the compliance matrix.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"cache = initialize_cache(nodes, elements)\nS, sc, tc = compliance_matrix(nodes, elements; cache)","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"After the forces and moments are computed at this section using GXBeam we can input them into the strain recovery function (strain_recovery).  These forces/moments are in the beam coordinate system in the order x, y, z. Note that we have to pass in that cache that corresponds to this section.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"F = [0.0; 0; 0]\nM = [0.0; 0; 1e6]\nstrain_b, stress_b, strain_p, stress_p = strain_recovery(F, M, nodes, elements, cache)","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"The resulting outputs are the strains and the stresses in the beam (b) and ply (p) coordinate systems at each element. The order for beam stresses/strains is: xx, yy, zz, xy, xz, yz. For ply stresses/strains the order is: 11, 22, 33, 12, 13, 23.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"There is a convenience function for plotting stresses and strains (plotsoln).  For example, to plot the stress in the beam z (axial) direction we do the following:","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"figure()\nplotsoln(nodes, elements, stress_b[3, :], PyPlot)\ncolorbar()","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"(Image: )","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"We now compare the stresses at a vertical cut through the upper surface near the center of the airfoil, corresponding to finite element data from the above mentioned thesis.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"idx = 585:-1:571\nn = length(idx)\nx3vec = zeros(n)\ns11 = zeros(n)\ns22 = zeros(n)\ns12 = zeros(n)\nfor i = 1:n\n    _, _, x3vec[i] = GXBeam.area_and_centroid_of_element(nodes[elements[idx[i]].nodenum])\n    s11[i] = stress_b[3, idx[i]]\n    s22[i] = stress_b[1, idx[i]]\n    s12[i] = stress_b[5, idx[i]]\nend\n\ndata11 = [0.0180411653073842  406.5894924309885\n0.12482948694456675  415.13802315227076\n0.22710651266109672  422.61798753339275\n0.33239062250525886  431.166518254675\n0.3319566379808254  -422.6179875333927\n0.3951603224558594  -443.98931433659857\n0.47943100878363254  -471.7720391807662\n0.583264485171124  -505.9661620658952\n0.6886021733516359  -540.1602849510242\n0.7924369891975358  -575.4229741763141\n0.8962718050434362  -610.6856634016029\n1.0001052814309277  -644.8797862867322\n1.1039387578184199  -679.0739091718616\n1.1045910740634781  0.5342831700800161\n1.2264322292981351  0.5342831700800161\n1.2266532399355787  -175.77916295636703\n1.312426798597963  -202.4933214603742\n1.3966988243841445  -231.3446126447019\n1.5200950908313546  -271.9501335707927\n1.6449982479884022  -314.6927871772042\n1.7699000656870412  -356.36687444345546\n1.89480322284409  -399.10952804986675\n2.0197050405427284  -440.78361531611824\n2.021628502817685  424.75512021371304\n2.123904189075806  433.30365093499523\n2.2487417127708254  442.9207479964378\n2.3735805759242536  451.46927871772004\n2.3753741107335635  220.6589492430985\n2.3964317363774406  221.72751558325876\n2.393700580682011  0.5342831700797888\n2.413255333991277  0.5342831700797888\n]\n\ndata22 = [0.001481042654028153  127.32714942430584\n0.12885071090047373  118.00254045514711\n0.2325236966824643  109.58167883523336\n0.33323459715639814  101.76177362196324\n0.3347156398104264  -1.2414072840613244\n0.41913507109004733  -11.762058266797624\n0.5242890995260663  -24.987902594537616\n0.6072274881516587  -35.80867597455273\n0.6916469194312798  -46.62962725758939\n0.7938388625592419  -59.85511577928645\n0.8975118483412323  -73.38108250430525\n1.0011848341232228  -86.30644862872356\n1.1063388625592419  -100.73349415766478\n1.1063388625592419  -0.13289355706416472\n1.2277843601895737  0.45311899577302484\n1.2292654028436019  40.99348163329208\n1.3758886255924172  22.056950315244137\n1.5017772511848344  6.125912642500339\n1.6039691943127963  -7.399876179497028\n1.7091232227488151  -20.625720507237133\n1.8142772511848342  -34.15186513527743\n1.916469194312796  -47.97795425757511\n2.021623222748815  -61.80439918591571\n2.0245853080568725  26.18323299602929\n2.0838270142180093  21.371312070364183\n2.166765402843602  14.754742894553374\n2.2719194312796214  6.634003671918379\n2.375592417061612  -1.1862573473947577\n2.375592417061612  230.34527418413685\n2.397808056872038  230.04230533851398\n2.397808056872038  -0.8886255924169859\n2.4170616113744083  -0.2903377310960309\n]\n\ndata12 = [\n0.017772511848341277  -577.8947368421051\n0.12440758293838872  -603.157894736842\n0.22956161137440767  -628.4210526315788\n0.33175355450236965  -652.6315789473684\n0.3347156398104265  -733.6842105263157\n0.3969194312796209  -754.7368421052631\n0.47985781990521326  -781.0526315789473\n0.5850118483412324  -816.8421052631579\n0.6886848341232227  -850.5263157894738\n0.7923578199052131  -884.2105263157894\n0.8960308056872036  -918.9473684210525\n1.0011848341232228  -952.6315789473683\n1.1033767772511847  -987.3684210526317\n1.1078199052132702  1.1368683772161603e-13\n1.2263033175355447  1.0526315789474552\n1.2277843601895735  -470.52631578947353\n1.294431279620853  -491.5789473684209\n1.3951421800947865  -525.2631578947368\n1.4988151658767772  -559.9999999999999\n1.6024881516587675  -595.7894736842104\n1.7076421800947865  -630.5263157894736\n1.8127962085308051  -665.2631578947367\n1.914988151658768  -698.9473684210525\n2.018661137440758  -733.6842105263155\n2.021623222748815  -656.8421052631578\n2.1238151658767768  -681.0526315789473\n2.249703791469194  -711.5789473684209\n2.375592417061611  -742.1052631578947\n2.374111374407583  -941.0526315789473\n2.396327014218009  -947.3684210526314\n2.396327014218009  3.157894736842138\n2.4140995260663507  2.1052631578947967\n]\n\ns11smeared = [-0.0010447775588210417  32.59127337488883\n2.379079052692152  -334.9955476402496]\ns22smeared = [-0.0011000343353035347  72.67277506936747\n2.4092723702804526  -72.36150389815401]\ns12smeared = [-0.001173578869337999  -409.47368421052636\n2.395547579103429  -997.8947368421054]","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"figure()\nplot(x3vec .- 4.77, s11, \"x\")\nplot(data11[:, 1], data11[:, 2])\nplot(s11smeared[:, 1], s11smeared[:, 2], \"--\")\nxlabel(\"y\")\nylabel(L\"\\sigma_z\")\nlegend([\"GXBeam\", \"3D FEA\", \"Smeared\"])\n\nfigure()\nplot(x3vec .- 4.77, s22, \"x\")\nplot(data22[:, 1], data22[:, 2])\nplot(s22smeared[:, 1], s22smeared[:, 2], \"--\")\nxlabel(\"y\")\nylabel(L\"\\sigma_x\")\nlegend([\"GXBeam\", \"3D FEA\", \"Smeared\"])\n\nfigure()\nplot(x3vec .- 4.77, s12, \"x\")\nplot(data12[:, 1], data12[:, 2])\nplot(s12smeared[:, 1], s12smeared[:, 2], \"--\")\nxlabel(\"y\")\nylabel(L\"\\sigma_{xz}\")\nlegend([\"GXBeam\", \"3D FEA\", \"Smeared\"])","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"Trends are in good agreement, though there is an offset in some stresses as some of the stiffnesses are overpredicted (although the geometry/mesh is not quite the same so the comparison is not exactly 1-to-1).","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"Finally, there is a function to compute the Tsai-wu failure criteria.  We pass in the ply stresses and the elements (where the strength properties are stored).","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"failure = tsai_wu(stress_p, elements)","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"The result is a vector (one for each element) where failure is predicted for values >= 1. These results can be plotted as shown previously, or used as constraints in an optimization typically with a smooth max, an extraction of some subset of elements, or some combination of both.","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"","category":"page"},{"location":"examples/section/","page":"Computing Stiffness and Mass Matrices","title":"Computing Stiffness and Mass Matrices","text":"This page was generated using Literate.jl.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/#Structural-Damping","page":"Theory","title":"Structural Damping","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"When stiffness proportional structural damping is used, the relationship between stresses and strains takes the following form:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginbmatrix F   M endbmatrix = S beginbmatrix gamma  kappa endbmatrix + mu S beginbmatrix dotgamma  dotkappa endbmatrix  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mu is a diagonal matrix with damping coefficients.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Rearranging this equations yields a new expression for the strains and curvatures when stiffness proportional structural damping is assumed.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginbmatrix gamma  kappa endbmatrix = S^-1 beginbmatrix F   M endbmatrix - mu beginbmatrix dotgamma  dotkappa endbmatrix","category":"page"},{"location":"theory/#Strain-Rates","page":"Theory","title":"Strain Rates","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The strain rates may be expressed as a function of our state variables using the strain compatability relationship.  We first rearrange the strain compatability equation to yield the following expression for the element strain.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"gamma_i = C^ba C fracDelta uDelta L + C^ba C C^ab e_1 - e_1 ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We then differentiate this equation with respect to time to obtain an expression for the strain rates:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"dotgamma_i = C^ba C fracDelta dotuDelta L + C^ba dotC fracDelta uDelta L + C^ba dotC C^ab e_1 ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The derivative of the rotation matrix dotC can be defined in terms of angular velocity as dotC = -left(tildeOmega-tildeomega right) C.  The linear displacement rates dotu can be defined in terms of linear velocity as dotu = V - v - tildeomega u.  Using these two expressions allows us to write the strain rates in terms of the state variables.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"dotgamma_i = C^ba C fracDelta dotuDelta L - C^ba widetilde(Omega-omega) C fracDelta uDelta L -  C^ba widetilde(Omega-omega) C C^ab e_1 ","category":"page"},{"location":"theory/#Curvature-Rates","page":"Theory","title":"Curvature Rates","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The curvature rates may be expressed as a function of our state variables using the curvature compatability relationship.  We first rearrange the curvature compatability equation to yield the following expression for the element curvature.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"kappa_i = C^ba Q fracDelta thetaDelta L","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Differentiating this equation with respect to time yields:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"dotkappa_i = C^ba Q fracDelta dotthetaDelta L + C^ba dotQ fracDelta thetaDelta L","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We can expand dotQ using its partial derivatives ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"dotQ = Q_theta_1 dottheta_1 + Q_theta_2 dottheta_2 + Q_theta_3 dottheta_3","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"so that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"dotQ Delta theta = \n(Q_theta_1 Delta theta) dottheta_1 + \n(Q_theta_2 Delta theta) dottheta_2 + \n(Q_theta_3 Delta theta) dottheta_3 \nequiv Delta Q dottheta","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Our expression for the curvature rates is then","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"dotkappa_i = C^ba Q fracDelta dotthetaDelta L + C^ba Delta Q fracdotthetaDelta L","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We can then use the following expression for the angular displacement rates to express the curvature rates as a function of our state variables.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"dottheta = Q^-1 C (Omega - omega)","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/static-joined-wing.jl\"","category":"page"},{"location":"examples/static-joined-wing/#static-joined-wing","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"","category":"section"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"In this example we consider the joined-wing model proposed by Blair in \"An Equivalent Beam Formulation for Joined-Wings in a Post-Buckled State\" and optimized by Green et al. in \"Structural Optimization of Joined-Wing Beam Model with Bend-Twist Coupling using Equivalent Static Loads\".","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"(Image: )","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"tip: Tip\nThis example is also available as a Jupyter notebook: static-joined-wing.ipynb.","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"using GXBeam, LinearAlgebra\n\n# Set endpoints of each beam\np1 = [-7.1726, -12, -3.21539]\np2 = [-5.37945, -9, -2.41154]\np3 = [-3.5863, -6, -1.6077]\np4 = [-1.79315, -3, -0.803848]\np5 = [0, 0, 0]\np6 = [7.1726, -12, 3.21539]\n\n# get transformation matrix for left beams\n\n# transformation from intermediate frame to global frame\ntmp1 = sqrt(p1[1]^2 + p1[2]^2)\nc1, s1 = -p1[1]/tmp1, -p1[2]/tmp1\nrot1 = [c1 -s1 0; s1 c1 0; 0 0 1]\n\n# transformation from local beam frame to intermediate frame\ntmp2 = sqrt(p1[1]^2 + p1[2]^2 + p1[3]^2)\nc2, s2 = tmp1/tmp2, -p1[3]/tmp2\nrot2 = [c2 0 -s2; 0 1 0; s2 0 c2]\n\nCab_1 = rot1*rot2\n\n# get transformation matrix for right beam\n\n# transformation from intermediate frame to global frame\ntmp1 = sqrt(p6[1]^2 + p6[2]^2)\nc1, s1 = p6[1]/tmp1, p6[2]/tmp1\nrot1 = [c1 -s1 0; s1 c1 0; 0 0 1]\n\n# transformation from local beam frame to intermediate frame\ntmp2 = sqrt(p6[1]^2 + p6[2]^2 + p6[3]^2)\nc2, s2 = tmp1/tmp2, p6[3]/tmp2\nrot2 = [c2 0 -s2; 0 1 0; s2 0 c2]\n\nCab_2 = rot1*rot2\n\n# beam 1\nL_b1 = norm(p2-p1)\nr_b1 = p1\nnelem_b1 = 5\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1;\n    frame = Cab_1)\ncompliance_b1 = fill(Diagonal([1.05204e-9, 3.19659e-9, 2.13106e-8, 1.15475e-7,\n    1.52885e-7, 7.1672e-9]), nelem_b1)\n\n# beam 2\nL_b2 = norm(p3-p2)\nr_b2 = p2\nnelem_b2 = 5\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2;\n    frame = Cab_1)\ncompliance_b2 = fill(Diagonal([1.24467e-9, 3.77682e-9, 2.51788e-8, 1.90461e-7,\n    2.55034e-7, 1.18646e-8]), nelem_b2)\n\n# beam 3\nL_b3 = norm(p4-p3)\nr_b3 = p3\nnelem_b3 = 5\nlengths_b3, xp_b3, xm_b3, Cab_b3 = discretize_beam(L_b3, r_b3, nelem_b3;\n    frame = Cab_1)\ncompliance_b3 = fill(Diagonal([1.60806e-9, 4.86724e-9, 3.24482e-8, 4.07637e-7,\n    5.57611e-7, 2.55684e-8]), nelem_b3)\n\n# beam 4\nL_b4 = norm(p5-p4)\nr_b4 = p4\nnelem_b4 = 5\nlengths_b4, xp_b4, xm_b4, Cab_b4 = discretize_beam(L_b4, r_b4, nelem_b4;\n    frame = Cab_1)\ncompliance_b4 = fill(Diagonal([2.56482e-9, 7.60456e-9, 5.67609e-8, 1.92171e-6,\n    2.8757e-6, 1.02718e-7]), nelem_b4)\n\n# beam 5\nL_b5 = norm(p6-p5)\nr_b5 = p5\nnelem_b5 = 20\nlengths_b5, xp_b5, xm_b5, Cab_b5 = discretize_beam(L_b5, r_b5, nelem_b5;\n    frame = Cab_2)\ncompliance_b5 = fill(Diagonal([2.77393e-9, 7.60456e-9, 1.52091e-7, 1.27757e-5,\n    2.7835e-5, 1.26026e-7]), nelem_b5)\n\n# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + nelem_b5\npoints = vcat(xp_b1, xp_b2[2:end], xp_b3[2:end], xp_b4[2:end], xp_b5[2:end])\nstart = 1:nelem\nstop = 2:nelem + 1\nlengths = vcat(lengths_b1, lengths_b2, lengths_b3, lengths_b4, lengths_b5)\nmidpoints = vcat(xm_b1, xm_b2, xm_b3, xm_b4, xm_b5)\nCab = vcat(Cab_b1, Cab_b2, Cab_b3, Cab_b4, Cab_b5)\ncompliance = vcat(compliance_b1, compliance_b2, compliance_b3, compliance_b4,\n    compliance_b5)\n\n# create assembly\nassembly = Assembly(points, start, stop;\n    compliance = compliance,\n    frames = Cab,\n    lengths = lengths,\n    midpoints = midpoints)\n\nFz = range(0, 70e3, length=141)\n\n# pre-allocate memory to reduce run-time\nijoint = nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1\nprescribed_points = [1, ijoint, nelem+1]\nstatic = true\nsystem = StaticSystem(assembly)\n\nlinear_states = Vector{AssemblyState{Float64}}(undef, length(Fz))\nfor i = 1:length(Fz)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed endpoint on beam 1\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n            theta_z=0),\n\n        # force applied on point 4\n        nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1 => PrescribedConditions(\n            Fz = Fz[i]),\n\n        # fixed endpoint on last beam\n        nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n            theta_z=0),\n    )\n\n    static_analysis!(system, assembly;\n        prescribed_conditions = prescribed_conditions,\n        linear = true)\n\n    linear_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\n\nend\n\nreset_state!(system)\nnonlinear_states = Vector{AssemblyState{Float64}}(undef, length(Fz))\nfor i = 1:length(Fz)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed endpoint on beam 1\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n            theta_z=0),\n\n        # force applied on point 4\n        nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1 => PrescribedConditions(\n            Fz = Fz[i]),\n\n        # fixed endpoint on last beam\n        nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n            theta_z=0),\n    )\n\n    static_analysis!(system, assembly;\n        prescribed_conditions=prescribed_conditions, reset_state=false)\n\n    nonlinear_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\n\nend\n\nreset_state!(system)\nnonlinear_follower_states = Vector{AssemblyState{Float64}}(undef, length(Fz))\nfor i = 1:length(Fz)\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed endpoint on beam 1\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n            theta_z=0),\n\n        # force applied on point 4\n        nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1 => PrescribedConditions(\n            Fz_follower = Fz[i]),\n\n        # fixed endpoint on last beam\n        nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n            theta_z=0),\n    )\n\n    static_analysis!(system, assembly;\n        prescribed_conditions=prescribed_conditions, reset_state=false)\n\n    nonlinear_follower_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"Note that we incrementally increased the load from 0 to 70 kN in order to ensure that we obtained converged solutions.","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"To visualize the differences between the different types of analyses we can plot the load deflection curve.","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"using Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\nplot(\n    xlim = (0, 7),\n    xticks = 0:1:7,\n    xlabel = \"Vertical Displacement at the Joint (m)\",\n    yticks = 0:10:70,\n    ylim = (0, 70),\n    ylabel = \"Load (kN)\",\n    grid = false,\n    overwrite_figure=false\n    )\nuz_l = [linear_states[i].points[ijoint].u[3] for i = 1:length(Fz)]\nuz_nl = [nonlinear_states[i].points[ijoint].u[3] for i = 1:length(Fz)]\nuz_fnl = [nonlinear_follower_states[i].points[ijoint].u[3] for i = 1:length(Fz)]\n\nplot!(uz_l, Fz./1e3, label=\"Linear\")\nplot!(uz_nl, Fz./1e3, label=\"Nonlinear with Dead Force\")\nplot!(uz_fnl, Fz./1e3, label=\"Nonlinear with Follower Force\")\nplot!(show=true)\nsavefig(\"../assets/static-joined-wing-deflection.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"(Image: )","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"This plot matches the plot provided by Wenbin Yu in \"GEBT: A general-purpose nonlinear analysis tool for composite beams\".","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"We can also visualize the deformed geometry and inspect the associated point and element data for any of these operating conditions conditions using ParaView.  To demonstrate we will visualize the 70kN follower force condition and set the color gradient to match the magnitude of the deflections.","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"airfoil  = [ #FX 60-100 airfoil\n    0.0000000 0.0000000;\n    0.0010700 0.0057400;\n    0.0042800 0.0114400;\n    0.0096100 0.0177500;\n    0.0170400 0.0236800;\n    0.0265300 0.0294800;\n    0.0380600 0.0352300;\n    0.0515600 0.0405600;\n    0.0669900 0.0460900;\n    0.0842700 0.0508600;\n    0.1033200 0.0556900;\n    0.1240800 0.0598900;\n    0.1464500 0.0640400;\n    0.1703300 0.0675400;\n    0.1956200 0.0708100;\n    0.2222100 0.0733900;\n    0.2500000 0.0756500;\n    0.2788600 0.0772000;\n    0.3086600 0.0783800;\n    0.3392800 0.0788800;\n    0.3705900 0.0789800;\n    0.4024500 0.0784500;\n    0.4347400 0.0775000;\n    0.4673000 0.0759600;\n    0.5000000 0.0740900;\n    0.5327000 0.0717400;\n    0.5652600 0.0691100;\n    0.5975500 0.0660800;\n    0.6294100 0.0627500;\n    0.6607200 0.0590500;\n    0.6913400 0.0551100;\n    0.7211400 0.0508900;\n    0.7500000 0.0465200;\n    0.7777900 0.0420000;\n    0.8043801 0.0374700;\n    0.8296700 0.0329800;\n    0.8535500 0.0286400;\n    0.8759201 0.0244700;\n    0.8966800 0.0205300;\n    0.9157300 0.0168100;\n    0.9330100 0.0134200;\n    0.9484400 0.0103500;\n    0.9619400 0.0076600;\n    0.9734700 0.0053400;\n    0.9829600 0.0034100;\n    0.9903900 0.0019300;\n    0.9957200 0.0008600;\n    0.9989300 0.0002300;\n    1.0000000 0.0000000;\n    0.9989300 0.0001500;\n    0.9957200 0.0007000;\n    0.9903900 0.0015100;\n    0.9829600 0.00251;\n    0.9734700 0.00377;\n    0.9619400 0.00515;\n    0.9484400 0.00659;\n    0.9330100 0.00802;\n    0.9157300 0.00941;\n    0.8966800 0.01072;\n    0.8759201 0.01186;\n    0.8535500 0.0128;\n    0.8296700 0.01347;\n    0.8043801 0.01381;\n    0.7777900 0.01373;\n    0.7500000 0.01329;\n    0.7211400 0.01241;\n    0.6913400 0.01118;\n    0.6607200 0.00951;\n    0.6294100 0.00748;\n    0.5975500 0.00496;\n    0.5652600 0.00217;\n    0.532700  -0.00092;\n    0.500000  -0.00405;\n    0.467300  -0.00731;\n    0.434740  -0.01045;\n    0.402450  -0.01357;\n    0.370590  -0.01637;\n    0.339280  -0.01895;\n    0.308660  -0.021;\n    0.278860  -0.02275;\n    0.250000  -0.02389;\n    0.222210  -0.02475;\n    0.195620  -0.025;\n    0.170330  -0.02503;\n    0.146450  -0.02447;\n    0.124080  -0.02377;\n    0.103320  -0.02246;\n    0.084270  -0.0211;\n    0.066990  -0.01913;\n    0.051560  -0.0173;\n    0.038060  -0.01481;\n    0.026530  -0.01247;\n    0.017040  -0.0097;\n    0.009610  -0.00691;\n    0.004280  -0.00436;\n    0.001070  -0.002;\n    0.0        0.0;\n]\n\nsection = zeros(3, size(airfoil, 1))\nfor ic = 1:size(airfoil, 1)\n    section[1,ic] = airfoil[ic,1] - 0.5\n    section[2,ic] = 0\n    section[3,ic] = airfoil[ic,2]\nend\n\nmkpath(\"static-joined-wing-visualization\")\nwrite_vtk(\"static-joined-wing-visualization/static-joined-wing-visualization\", assembly, nonlinear_follower_states[end];\n    sections = section)\nrm(\"static-joined-wing-visualization\"; recursive=true) #hide","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"(Image: )","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"","category":"page"},{"location":"examples/static-joined-wing/","page":"Static Analysis of a Joined-Wing","title":"Static Analysis of a Joined-Wing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/tipforce.jl\"","category":"page"},{"location":"examples/tipforce/#tipforce","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"","category":"section"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"This example shows how to predict the behavior of a cantilever beam that is subjected to a constant shear force at the tip.","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"(Image: )","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"tip: Tip\nThis example is also available as a Jupyter notebook: tipforce.ipynb.","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"using GXBeam, LinearAlgebra\n\nL = 1\nEI = 1e6\n\n# shear force (applied at end)\nλ = 0:0.5:16\np = EI/L^2\nP = λ*p\n\n# create points\nnelem = 16\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([0, 0, 0, 0, 1/EI, 0]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# pre-initialize system storage\nsystem = StaticSystem(assembly)\n\n# run an analysis for each prescribed tip load\nstates = Vector{AssemblyState{Float64}}(undef, length(P))\nfor i = 1:length(P)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n            theta_z=0),\n        # shear force on right tip\n        nelem+1 => PrescribedConditions(Fz = P[i])\n    )\n\n    # perform a static analysis\n    static_analysis!(system, assembly;\n        prescribed_conditions=prescribed_conditions)\n\n    # post-process the results\n    states[i] = AssemblyState(system, assembly;\n        prescribed_conditions=prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"The analytical solution to this problem has been presented by several authors.  Here we follow the solution by H. J. Barten in \"On the Deflection of a Cantilever Beam\", after incorporating the corrections they submitted for finding the tip angle.","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"import Elliptic\n\nδ = range(pi/4, pi/2, length=10^5)[2:end-1]\n\nk = @. cos(pi/4)/sin(δ)\nλ_a = @. (Elliptic.F(pi/2, k^2) - Elliptic.F(δ,  k^2))^2\n\nθ_a = @. 2*(pi/4 - acos(k))\n\nξ_a = @. sqrt(2*sin(θ_a)/λ_a) .- 1\n\nη_a = @. 1-2/sqrt(λ_a)*(Elliptic.E(pi/2, k^2) - Elliptic.E(δ, k^2))\n\nnothing #hide","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"Plotting the results reveals that the analytical and computational solutions show excellent agreement.","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"using Plots\nusing Suppressor #hide\npyplot()\nnothing #hide","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"@suppress_err begin #hide\n\nu = [states[i].points[end].u[1] for i = 1:length(P)]\nθ = [states[i].points[end].theta[2] for i = 1:length(P)]\nw = [states[i].points[end].u[3] for i = 1:length(P)]\n\n# set up the plot\nplot(\n    xlim = (0, 16),\n    xticks = 0:1:16,\n    xlabel = \"Nondimensional Force \\$\\\\left(\\\\frac{PL^2}{EI}\\\\right)\\$\",\n    ylim = (0, 1.2),\n    yticks = 0.0:0.2:1.2,\n    ylabel = \"Nondimensional Tip Displacements\",\n    legend=:bottomright,\n    grid = false,\n    overwrite_figure=false\n    )\n\nplot!([0], [0], color=:black, label=\"Analytical\")\nscatter!([0], [0], color=:black, label=\"GXBeam\")\nplot!([0], [0], color=1, label=\"\\$ \\\\theta/(\\\\pi/2) \\$\")\nplot!([0], [0], color=2, label=\"Vertical \\$\\\\left(w/L\\\\right)\\$\")\nplot!([0], [0], color=3, label=\"Horizontal \\$\\\\left(-u/L\\\\right)\\$\")\n\nplot!(λ_a, θ_a*2/pi, color=1, label=\"\")\nscatter!(λ, -4*atan.(θ/4)*2/pi, color=1, label=\"\")\n\nplot!(λ_a, η_a, color=2, label=\"\")\nscatter!(λ, w/L, color=2, label=\"\")\n\nplot!(λ_a, -ξ_a, color=3, label=\"\")\nscatter!(λ, -u/L, color=3, label=\"\")\n\nplot!(show=true)\nsavefig(\"../assets/tipforce-displacement.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"(Image: )","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"","category":"page"},{"location":"examples/tipforce/","page":"Cantilever with a Tip Force","title":"Cantilever with a Tip Force","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/tipmoment.jl\"","category":"page"},{"location":"examples/tipmoment/#tipmoment","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"","category":"section"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"This example shows how to predict the behavior of a cantilever beam that is subjected to a constant tip moment.  This is a common benchmark problem for the geometrically nonlinear analysis of beams.","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"(Image: )","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"tip: Tip\nThis example is also available as a Jupyter notebook: tipmoment.ipynb.","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"using GXBeam, LinearAlgebra\n\nL = 12 # inches\nh = w = 1 # inches\nE = 30e6 # lb/in^4 Young's Modulus\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\n\n# bending moment (applied at end)\nλ = [0.0, 0.4, 0.8, 1.2, 1.6, 1.8, 2.0]\nm = pi*E*Iyy/L\nM = λ*m\n\n# create points\nnelem = 16\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([1/(E*A), 0, 0, 0, 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# pre-initialize system storage\nsystem = StaticSystem(assembly)\n\n# run an analysis for each prescribed bending moment\nstates = Vector{AssemblyState{Float64}}(undef, length(M))\nfor i = 1:length(M)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # moment on right side\n        nelem+1 => PrescribedConditions(Mz = M[i])\n    )\n\n    # perform a static analysis\n    static_analysis!(system, assembly;\n        prescribed_conditions = prescribed_conditions)\n\n    # post-process the results\n    states[i] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"This problem has a simple analytical solution, which we obtained from \"Study of the Geometric Stiffening Effect: Comparison of Different Formulations\" by Juana M. Mayo, Daniel Garcia-Vallejo, and Jaime Dominguez.","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"# analytical solution (ρ = E*I/M)\nanalytical(x, ρ) = ifelse(ρ == Inf, zeros(3), [ρ*sin(x/ρ)-x, ρ*(1-cos(x/ρ)), 0])\nnothing #hide","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"Plotting the results reveals that the analytical and computational results show excellent agreement.","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"using Plots\nusing Suppressor #hide\npyplot()\nnothing #hide","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"@suppress_err begin #hide\n\n# set up the plot\nplot(\n    xlim = (-0.25, 1.1),\n    xticks = -0.25:0.25:1.0,\n    xlabel = \"x/L\",\n    ylim = (-0.05, 0.8),\n    yticks = 0.0:0.2:0.8,\n    ylabel = \"y/L\",\n    aspect_ratio = 1.0,\n    grid = false,\n    overwrite_figure=false\n    )\n\n# create dummy legend entries for GXBeam and Analytical\nscatter!([], [], color=:black, label=\"GXBeam\")\nplot!([], [], color=:black, label=\"Analytical\")\n\n# plot the data\nfor i = 1:length(M)\n\n    local x, y\n\n    # GXBeam\n    x = [assembly.points[ipoint][1] + states[i].points[ipoint].u[1] for ipoint =\n        1:length(assembly.points)]\n    y = [assembly.points[ipoint][2] + states[i].points[ipoint].u[2] for ipoint =\n        1:length(assembly.points)]\n    scatter!(x/L, y/L, label=\"\", color = i)\n\n    # Analytical\n    x0 = range(0, L, length=100)\n    deflection = analytical.(x0, E*Iyy/M[i])\n    x = (x0 + getindex.(deflection, 1))\n    y = getindex.(deflection, 2)\n    plot!(x/L, y/L, label=\"\\$\\\\lambda\\$=$(λ[i])\", color=i)\nend\nplot!(show=true)\nsavefig(\"../assets/tipmoment-deflection.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"(Image: )","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"We can use this problem to test the accuracy and convergence of this package.  To do so we set lambda = 1 and repeat the analysis for a variety of grid sizes.  We measure the normalized tip displacement error varepsilon(u) using the following expression","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"varepsilon(u) = left fracu - u^au^a right","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"where u is the calculated tip displacement (at x=L) and u^a is the analytical tip displacement.","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"grid_sizes = unique(round.(Int, 10 .^ range(0,3,length=25)))\n\nL = 12 # inches\nh = w = 1 # inches\nE = 30e6 # lb/in^4 Young's Modulus\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\n\n# bending moment (applied at end)\nλ = 1.0\nm = pi*E*Iyy/L\nM = λ*m\n\n# run an analysis for each grid size\nstates = Vector{AssemblyState{Float64}}(undef, length(grid_sizes))\nfor (igrid, nelem) in enumerate(grid_sizes)\n\n    local x, y, z, points, start, stop, compliance, assembly, system\n\n    # create points\n    x = range(0, L, length=nelem+1)\n    y = zero(x)\n    z = zero(x)\n    points = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n    # index of endpoints of each beam element\n    start = 1:nelem\n    stop = 2:nelem+1\n\n    # compliance matrix for each beam element\n    compliance = fill(Diagonal([1/(E*A), 0, 0, 0, 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\n    # create assembly of interconnected nonlinear beams\n    assembly = Assembly(points, start, stop, compliance=compliance)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # moment on right side\n        nelem+1 => PrescribedConditions(Mz = M)\n    )\n\n    # perform a static analysis\n    system, converged = static_analysis(assembly;\n        prescribed_conditions = prescribed_conditions)\n\n    # post-process the results\n    states[igrid] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"# calculate analytical solution\ndxa, dya = analytical(L, E*Iyy/M)\n\n# extract computational solution\ndx = [states[igrid].points[end].u[1] for igrid = 1:length(grid_sizes)]\ndy = [states[igrid].points[end].u[2] for igrid = 1:length(grid_sizes)]\n\n# compute error\nεx = abs.((dx .- dxa) ./ dxa)\nεy = abs.((dy .- dya) ./ dya)\n\nnothing #hide","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"using Plots\nusing Suppressor #hide\npyplot()\nnothing #hide","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"@suppress_err begin #hide\n\n# plot the x-error\np1 = plot(grid_sizes .+ 1, εx, label=\"\",\n    xlabel = \"Number of Nodes\",\n    xaxis=:log,\n    xlim = (10^0, 10^3),\n    xtick = 10.0 .^ (0:3),\n    ylabel = \"\\$\\\\varepsilon(u_x)\\$\",\n    yaxis=:log,\n    ylim = (-Inf, 10^0),\n    ytick = 10.0 .^ -(0:7),\n    overwrite_figure=false,\n    show=true)\n\nsavefig(\"../assets/tipmoment-x-convergence.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"(Image: )","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"@suppress_err begin #hide\n\n# plot the y-error\np2 = plot(grid_sizes .+ 1, εy, label=\"\",\n    xlabel = \"Number of Nodes\",\n    xaxis=:log,\n    xlim = (10^0, 10^3),\n    xtick = 10.0 .^ (0:3),\n    ylabel = \"\\$\\\\varepsilon(u_y)\\$\",\n    yaxis=:log,\n    ylim = (-Inf, 10^0),\n    ytick = 10.0 .^ -(0:7),\n    overwrite_figure=false,\n    show=true)\n\nsavefig(\"../assets/tipmoment-y-convergence.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"(Image: )","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"We observe second-order algebraic convergence for both x and y tip displacement errors. We can therefore conclude that a large number of elements are likely necessary in order to obtain highly accurate solutions using this package.  For problems where high accuracy solutions are critical, higher order shape functions, such as the Legendre spectral finite elements used by BeamDyn are likely more computationally efficient.","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"","category":"page"},{"location":"examples/tipmoment/","page":"Cantilever with a Tip Moment","title":"Cantilever with a Tip Moment","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/wind-turbine-blade.jl\"","category":"page"},{"location":"examples/wind-turbine-blade/#wind-turbine-blade","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"","category":"section"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"tip: Tip\nThis example is also available as a Jupyter notebook: wind-turbine-blade.ipynb.","category":"page"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"using GXBeam, LinearAlgebra\n\nL = 60 # m\n\n# create points\nnelem = 10\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# stiffness matrix for each beam element\nstiffness = fill(\n    [2.389e9  1.524e6  6.734e6 -3.382e7 -2.627e7 -4.736e8\n     1.524e6  4.334e8 -3.741e6 -2.935e5  1.527e7  3.835e5\n     6.734e6 -3.741e6  2.743e7 -4.592e5 -6.869e5 -4.742e6\n    -3.382e7 -2.935e5 -4.592e5  2.167e7 -6.279e5  1.430e6\n    -2.627e7  1.527e7 -6.869e5 -6.279e5  1.970e7  1.209e7\n    -4.736e8  3.835e5 -4.742e6  1.430e6  1.209e7  4.406e8],\n    nelem)\n\n# mass matrix for each beam element\nmass = fill(\n    [258.053      0.0        0.0      0.0      7.07839  -71.6871\n       0.0      258.053      0.0     -7.07839  0.0        0.0\n       0.0        0.0      258.053   71.6871   0.0        0.0\n       0.0       -7.07839   71.6871  48.59     0.0        0.0\n       7.07839    0.0        0.0      0.0      2.172      0.0\n     -71.6871     0.0        0.0      0.0      0.0       46.418],\n     nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop; stiffness=stiffness, mass=mass)\n\n# prescribed conditions\nprescribed_conditions = (t) -> begin\n    Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force on right side\n        nelem+1 => PrescribedConditions(Fz = 1e5*sin(20*t))\n    )\nend\n\n# simulation time\nt = 0:0.001:2.0\n\nsystem, history, converged = time_domain_analysis(assembly, t;\n    prescribed_conditions = prescribed_conditions,\n    structural_damping = false)\n\nnothing #hide","category":"page"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"We can visualize tip displacements and the resultant forces in the root by accessing the post-processed results for each time step contained in the variable history. Note that the root resultant forces for this case are equal to the external forces/moments, but with opposite sign.","category":"page"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"using Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\npoint = vcat(fill(nelem+1, 6), fill(1, 6))\nfield = [:u, :u, :u, :theta, :theta, :theta, :F, :F, :F, :M, :M, :M]\ndirection = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\nylabel = [\"\\$u_x\\$ (\\$m\\$)\", \"\\$u_y\\$ (\\$m\\$)\", \"\\$u_z\\$ (\\$m\\$)\",\n    \"Rodriguez Parameter \\$\\\\theta_x\\$ (degree)\",\n    \"Rodriguez Parameter \\$\\\\theta_y\\$ (degree)\",\n    \"Rodriguez Parameter \\$\\\\theta_z\\$ (degree)\",\n    \"\\$F_x\\$ (\\$N\\$)\", \"\\$F_y\\$ (\\$N\\$)\", \"\\$F_z\\$ (\\$N\\$)\",\n    \"\\$M_x\\$ (\\$Nm\\$)\", \"\\$M_y\\$ (\\$Nm\\$)\", \"\\$M_z\\$ (\\$N\\$)\"]\n\nfor i = 1:12\n\n    local y\n\n   plot(\n        xlim = (0, 2.0),\n        xticks = 0:0.5:2.0,\n        xlabel = \"Time (s)\",\n        ylabel = ylabel[i],\n        grid = false,\n        overwrite_figure=false\n        )\n    y = [getproperty(state.points[point[i]], field[i])[direction[i]]\n        for state in history]\n\n    if field[i] == :theta\n        # convert to Rodriguez parameter\n        @. y = 4*atan(y/4)\n        # convert to degrees\n        @. y = rad2deg(y)\n    end\n\n    if field[i] == :F || field[i] == :M\n        y = -y\n    end\n\n    plot!(t, y, label=\"\")\n    plot!(show=true)\n    savefig(\"../assets/wind-turbine-blade-\"*string(field[i])*string(direction[i])*\".svg\"); #hide\n    closeall() #hide\nend\n\nend #hide\nnothing #hide","category":"page"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"These plots are identical to those presented by Qi Wang, Wenbin Yu, and Michael A. Sprague in \"Geometric Nonlinear Analysis of Composite Beams Using Wiener-Milenkovic Parameters\".","category":"page"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"We can also visualize the time history of the system using ParaView.","category":"page"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"root_chord = 1.9000\ntip_chord =  0.4540\nairfoil = [ # MH-104\n    1.00000000  0.00000000;\n    0.99619582  0.00017047;\n    0.98515158  0.00100213;\n    0.96764209  0.00285474;\n    0.94421447  0.00556001;\n    0.91510964  0.00906779;\n    0.88074158  0.01357364;\n    0.84177999  0.01916802;\n    0.79894110  0.02580144;\n    0.75297076  0.03334313;\n    0.70461763  0.04158593;\n    0.65461515  0.05026338;\n    0.60366461  0.05906756;\n    0.55242353  0.06766426;\n    0.50149950  0.07571157;\n    0.45144530  0.08287416;\n    0.40276150  0.08882939;\n    0.35589801  0.09329359;\n    0.31131449  0.09592864;\n    0.26917194  0.09626763;\n    0.22927064  0.09424396;\n    0.19167283  0.09023579;\n    0.15672257  0.08451656;\n    0.12469599  0.07727756;\n    0.09585870  0.06875796;\n    0.07046974  0.05918984;\n    0.04874337  0.04880096;\n    0.03081405  0.03786904;\n    0.01681379  0.02676332;\n    0.00687971  0.01592385;\n    0.00143518  0.00647946;\n    0.00053606  0.00370956;\n    0.00006572  0.00112514;\n    0.00001249 -0.00046881;\n    0.00023032 -0.00191488;\n    0.00079945 -0.00329201;\n    0.00170287 -0.00470585;\n    0.00354717 -0.00688469;\n    0.00592084 -0.00912202;\n    0.01810144 -0.01720842;\n    0.03471169 -0.02488211;\n    0.05589286 -0.03226730;\n    0.08132751 -0.03908459;\n    0.11073805 -0.04503763;\n    0.14391397 -0.04986836;\n    0.18067874 -0.05338180;\n    0.22089879 -0.05551392;\n    0.26433734 -0.05636585;\n    0.31062190 -0.05605816;\n    0.35933893 -0.05472399;\n    0.40999990 -0.05254383;\n    0.46204424 -0.04969990;\n    0.51483073 -0.04637175;\n    0.56767889 -0.04264894;\n    0.61998250 -0.03859653;\n    0.67114514 -0.03433153;\n    0.72054815 -0.02996944;\n    0.76758733 -0.02560890;\n    0.81168064 -0.02134397;\n    0.85227225 -0.01726049;\n    0.88883823 -0.01343567;\n    0.92088961 -0.00993849;\n    0.94797259 -0.00679919;\n    0.96977487 -0.00402321;\n    0.98607009 -0.00180118;\n    0.99640466 -0.00044469;\n    1.00000000  0.00000000;\n]\n\nsections = zeros(3, size(airfoil, 1), length(points))\nfor ip = 1:length(points)\n    chord = root_chord * (1 - x[ip]/L) + tip_chord * x[ip]/L\n    sections[1, :, ip] .= 0\n    sections[2, :, ip] .= chord .* (airfoil[:,1] .- 0.5)\n    sections[3, :, ip] .= chord .* airfoil[:,2]\nend\n\nmkpath(\"wind-turbine-blade-simulation\")\nwrite_vtk(\"wind-turbine-blade-simulation/wind-turbine-blade-simulation\", assembly, history, t; sections = sections)\nrm(\"wind-turbine-blade-simulation\"; recursive=true) #hide","category":"page"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"(Image: )","category":"page"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"","category":"page"},{"location":"examples/wind-turbine-blade/","page":"Time-Domain Simulation of a Wind Turbine Blade","title":"Time-Domain Simulation of a Wind Turbine Blade","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#GXBeam","page":"Home","title":"GXBeam","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: ) (Image: status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pure Julia Implementation of Geometrically Exact Beam Theory","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Taylor McDonnell","category":"page"},{"location":"","page":"Home","title":"Home","text":"GXBeam is a pure Julia implementation of Geometrically Exact Beam Theory, originally based on the open source code GEBT and its associated papers[1][2], though it has since been augmented with a number of additional features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a sample of one of the many things this package can do, here's a time domain simulation of the dynamic response of a joined wing subjected to a simulated gust, scaled up in order to visualize the deflections: (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"And here's a dynamic simulation of a wind turbine subjected to a sinusoidal tip load. (Image: )","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Performs multiple types of analyses including:\nLinear/Nonlinear static analyses\nLinear/Nonlinear steady-state analyses\nLinear/Nonlinear eigenvalue analyses (by linearizing about a steady state condition)\nLinear/Nonlinear time-marching dynamic analyses\nAccurately models arbitrary systems of interconnected highly flexible composite beams.\nCaptures all geometric nonlinearities due to large deflections and rotations (subject to a small strain assumption)\nModels angular displacements of any magnitude using only three parameters\nUses the full 6x6 Timoshenko beam stiffness matrix\nCalculate section compliance and inertia matrices \nUses quadrilateral finite elements rather than classical lamiante theory for much better accuracy and cross coupling\nAllows for general geometry with inhomogenous properties and anisotropic behavior (computes full 6x6 matrix)\nPly materials are general orthotropic\nProvides convenience method for paramterizing airfoil layups\nModels time-varying distributed forces/moments including\nPoint and distributed loads which remain fixed in the body-frame\nPoint and distributed loads which rotate with the structure\nLoads due to known body frame velocities and accelerations\nGravitational loads acting on beam elements and point masses\nLoads resulting from stiffness-proportional structural damping\nOptional DifferentialEquations interface.\nConstant mass matrix differential algebraic equation formulation\nFully implicit differential algebraic equation formulation\nProvides derivatives with ForwardDiff (including overloading internal solvers with implicit analytic methods)\nResult visualization using WriteVTK\nVerified and validated against published analytical and computational results.  See the examples in the documentation.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the package manager by typing ] and then run the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add GXBeam","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This code has been optimized to be highly performant.  In our tests we found that GXBeam outperforms GEBT by a significant margin across all analysis types, as seen in the following table.  More details about the specific cases which we test may be found by inspecting the scripts and input files and scripts for these tests in the benchmark folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Package Steady Analysis Eigenvalue Analysis Time Marching Analysis\nGEBT 13.722 ms 33.712 ms 26.870 s\nGXBeam 4.716 ms 18.478 ms 9.019 s","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the guide.","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"By using the simplest possible shape functions (constant or linear shape functions), this package avoids using numerical quadrature except when integrating applied distributed loads (which can be pre-integrated).  As a result, element properties are approximated as constant throughout each beam element and a relatively large number of beam elements may be necessary to achieve grid-independent results.  More details about the convergence of this package may be found in the examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package does not currently model cross section warping, and therefore should not be used to model open cross sections (such as I, C, or L-beams).  The one exception to this rule is if the beam's width is much greater than its height, in which case the beam may be considered to be strip-like (like a helicopter blade).  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package relies on the results of linear cross-sectional analyses.  Most notably, it does not model the nonlinear component of the Trapeze effect, which is the tendency of a beam to untwist when subjected to axial tension.  This nonlinear effect is typically most important when modeling rotating structures such as helicopter blades due to the presence of large centrifugal forces.  It is also more important when modeling strip-like beams than for modeling closed cross-section beams due to their low torsional rigidity.","category":"page"},{"location":"#Related-Codes","page":"Home","title":"Related Codes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GEBT: Open source geometrically exact beam theory code developed in Fortran as a companion to the proprietary cross sectional analysis tool VABS.  The theory for this code is provided in references 1 and 2.  GXBeam was originally developed based on this package and its associated papers, but has since been augmented with additional features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BeamDyn: Open source geometrically exact beam theory code developed in Fortran by NREL as part of the OpenFAST project.  This code was also developed based on GEBT, but uses Legendre spectral finite elements.  This allows for exponential rather than algebraic convergence when the solution is smooth.  This makes this code a good candidate for use when analyzing beams with smoothly varying properties.  Unfortunately, the code is limited to analyzing a single beam, rather than an assembly of beams.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The cross sectional analysis uses the same underlying theory as in BECAS, but was written to be fast and optimization-friendly.  VABS and PreComp are other popular tools for composite cross sectional analysis.  The former is not freely available, whereas the latter is lower fidelity as it is based on classical laminate theory.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are welcome and encouraged.  If at any point you experience issues or have suggestions related to this package, create a new Github issue so we can discuss it.  If you're willing to help solve an issue yourself, we encourage you to create a fork of this repository and submit a pull request with the requested change.  Pull requests should generally also add a unit test in test/runtests.jl to ensure that issues do not reoccur along with future changes.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Yu, W., & Blair, M. (2012). GEBT: A general-purpose nonlinear analysis tool for composite beams. Composite Structures, 94(9), 2677-2689.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Wang, Q., & Yu, W. (2017). Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters. Journal of Renewable and Sustainable Energy, 9(3), 033306.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3] Hodges, D. (2006). Nonlinear Composite Beam Theory. American Institute of Aeronautics and Astronautics.","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"EditURL = \"https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/literate/cantilever.jl\"","category":"page"},{"location":"examples/cantilever/#cantilever","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"","category":"section"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"This example shows how to predict the behavior of a cantilever beam which is partially subjected to a uniform distributed load.","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"(Image: )","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"tip: Tip\nThis example is also available as a Jupyter notebook: cantilever.ipynb.","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"using GXBeam, LinearAlgebra\n\nnelem = 12\n\n# create points\na = 0.3\nb = 0.7\nL = 1.0\nn1 = n3 = div(nelem, 3)\nn2 = nelem - n1 - n3\nx1 = range(0, 0.3, length=n1+1)\nx2 = range(0.3, 0.7, length=n2+1)\nx3 = range(0.7, 1.0, length=n3+1)\nx = vcat(x1, x2[2:end], x3[2:end])\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints for each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# create compliance matrix for each beam element\nEI = 1e9\ncompliance = fill(Diagonal([0, 0, 0, 0, 1/EI, 0]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# set prescribed conditions (fixed right endpoint)\nprescribed_conditions = Dict(\n    nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n    theta_z=0)\n)\n\n# create distributed load\nq = 1000\ndistributed_loads = Dict(\n    ielem => DistributedLoads(assembly, ielem; fz = (s) -> q) for ielem in\n    n1+1:n1+n2\n)\n\nsystem, converged = static_analysis(assembly;\n    prescribed_conditions = prescribed_conditions,\n    distributed_loads = distributed_loads,\n    linear = true)\n\nstate = AssemblyState(system, assembly;\n    prescribed_conditions = prescribed_conditions)\n\nnothing #hide","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"We can construct the analytical solution for this problem by integrating from the free end of the beam and applying the appropriate boundary conditions.","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"# construct analytical solution\ndx = 1e-6\nx_a = 0.0:dx:L\nq_a = (x) -> a <= x <= b ? -q : 0 # define distributed load\nV_a = cumsum(-q_a.(x_a) .* dx) # integrate to get shear\nM_a = cumsum(V_a .* dx) # integrate to get moment\nslope_a = cumsum(M_a./EI .* dx) # integrate to get slope\nslope_a .-= slope_a[end] # apply boundary condition\ndeflection_a = cumsum(slope_a .* dx) # integrate to get deflection\ndeflection_a .-= deflection_a[end] # apply boundary condition\n\n# get elastic twist angle\ntheta_a = -atan.(slope_a)\n\n# switch analytical system frame of reference\nM_a = -M_a\n\nnothing #hide","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"Plotting the results reveals that the analytical and computational solutions show excellent agreement.","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"using Plots\nusing Suppressor #hide\npyplot()\nnothing #hide","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"@suppress_err begin #hide\nlocal x #hide\n\n# deflection plot\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Deflection (m)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint =\n    1:length(assembly.points)]\ndeflection = [state.points[ipoint].u[3] for ipoint = 1:length(assembly.points)]\nplot!(x_a, deflection_a, label=\"Analytical\")\nscatter!(x, deflection, label=\"GXBeam\")\nplot!(show=true)\nsavefig(\"../assets/cantilever-deflection.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"(Image: )","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"@suppress_err begin #hide\nlocal x #hide\n\n# elastic twist plot (euler angle)\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Rotation Angle (rad)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1]\n    for ipoint = 1:length(assembly.points)]\ntheta = [4*atan.(state.points[ipoint].theta[2]/4) for ipoint =\n    1:length(assembly.points)]\nplot!(x_a, theta_a, label=\"Analytical\")\nscatter!(x, theta, label=\"GXBeam\")\nplot!(show=true)\nsavefig(\"../assets/cantilever-twist.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"(Image: )","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"@suppress_err begin #hide\nlocal x #hide\n\n# bending moment plot\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Bending Moment (\\$Nm\\$)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.elements[ielem].x[1] + state.elements[ielem].u[1] for\n    ielem = 1:length(assembly.elements)]\nM = [state.elements[ielem].Mi[2] for ielem = 1:length(assembly.elements)]\nplot!(x_a, M_a, label=\"Analytical\")\nscatter!(x, M, label=\"GXBeam\")\nplot!(show=true)\nsavefig(\"../assets/cantilever-moment.svg\") #hide\ncloseall() #hide\nend #hide\nnothing #hide","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"(Image: )","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"Note that we could have easily performed a nonlinear analysis for this problem by setting linear=false.","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"","category":"page"},{"location":"examples/cantilever/","page":"Cantilever with a Uniform Load","title":"Cantilever with a Uniform Load","text":"This page was generated using Literate.jl.","category":"page"}]
}
